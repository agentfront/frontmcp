---
title: MCP Bridge & Interactivity
sidebarTitle: MCP Bridge
icon: bolt
description: The MCP Bridge (window.mcpBridge) provides a unified API for widget interactivity across platforms. It enables widgets to call tools, send messages, and interact with the host environment.
---

## What is MCP Bridge?

MCP Bridge is a runtime adapter that:

- Normalizes platform APIs (OpenAI, Claude, etc.)
- Provides tool invocation capabilities
- Manages widget state
- Handles theme and display mode changes

```typescript
// Available as window.mcpBridge in widgets
interface MCPBridge {
  readonly provider: 'openai' | 'ext-apps' | 'claude' | 'unknown';

  // Core methods
  callTool(name: string, params: object): Promise<unknown>;
  sendMessage(content: string): Promise<void>;
  openLink(url: string): Promise<void>;

  // ext-apps specific methods (SEP-1865)
  updateModelContext(context: unknown, merge?: boolean): Promise<void>;
  log(level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown): Promise<void>;
  registerTool(name: string, description: string, inputSchema: object): Promise<void>;
  unregisterTool(name: string): Promise<void>;

  readonly toolInput: Record<string, unknown>;
  readonly toolOutput: unknown;
  readonly structuredContent: unknown;
  readonly widgetState: Record<string, unknown>;
  readonly context: HostContext;

  setWidgetState(state: object): void;
  onContextChange(callback: (ctx: Partial<HostContext>) => void): () => void;
  onToolResult(callback: (result: unknown) => void): () => void;
}
```

## Calling Tools

Invoke MCP tools from your widget:

```typescript
// In your widget script
async function loadMoreItems() {
  try {
    const result = await window.mcpBridge.callTool('list_items', {
      page: 2,
      limit: 10,
    });

    // Update widget with results
    document.getElementById('items').innerHTML = renderItems(result.items);
  } catch (error) {
    console.error('Tool call failed:', error);
  }
}
```

### Button with Tool Call

```typescript
import { button } from '@frontmcp/ui/components';

const html = `
${button('Load More', { id: 'load-more-btn' })}

<script>
  document.getElementById('load-more-btn').addEventListener('click', async () => {
    const btn = document.getElementById('load-more-btn');
    btn.disabled = true;
    btn.textContent = 'Loading...';

    try {
      const result = await window.mcpBridge.callTool('get_more_data', {});
      // Handle result
    } finally {
      btn.disabled = false;
      btn.textContent = 'Load More';
    }
  });
</script>
`;
```

## Sending Messages

Send follow-up messages to the chat:

```typescript
async function askQuestion(question) {
  await window.mcpBridge.sendMessage(question);
}
```

```html
<input type="text" id="question" placeholder="Ask a question...">
<button onclick="askQuestion(document.getElementById('question').value)">
  Ask
</button>
```

## Opening Links

Open external URLs:

```typescript
await window.mcpBridge.openLink('https://example.com/docs');
```

This uses the platform's native link opening mechanism (new tab, in-app browser, etc.).

## Accessing Tool Data

Get the original tool input and output:

```typescript
// In your widget script
const input = window.mcpBridge.toolInput;
const output = window.mcpBridge.toolOutput;
const structured = window.mcpBridge.structuredContent;

console.log('Tool was called with:', input);
console.log('Tool returned:', output);
```

## Widget State

Persist state across sessions:

```typescript
// Get current state
const state = window.mcpBridge.widgetState;

// Update state
window.mcpBridge.setWidgetState({
  ...state,
  selectedTab: 'details',
  expandedSections: ['info', 'history'],
});
```

<Warning>
  Widget state is platform-specific. Not all platforms support persistence.
  Check `supportsFullInteractivity()` before relying on this feature.
</Warning>

## Host Context

Access theme, display mode, and other context:

```typescript
const context = window.mcpBridge.context;

console.log(context.theme);        // 'light' | 'dark' | 'system'
console.log(context.displayMode);  // 'inline' | 'fullscreen' | 'pip'
console.log(context.locale);       // 'en-US'
console.log(context.viewport);     // { width, height, maxHeight }
```

### Subscribe to Context Changes

React to theme or display mode changes:

```typescript
const unsubscribe = window.mcpBridge.onContextChange((changes) => {
  if (changes.theme) {
    document.documentElement.classList.toggle('dark', changes.theme === 'dark');
  }

  if (changes.displayMode) {
    updateLayoutForMode(changes.displayMode);
  }
});

// Later: cleanup
unsubscribe();
```

## Tool Result Updates

Listen for tool result updates (streaming, progressive loading):

```typescript
const unsubscribe = window.mcpBridge.onToolResult((result) => {
  // Update widget with new result
  renderWidget(result);
});
```

## ext-apps Methods (SEP-1865)

The MCP Apps Extension protocol (SEP-1865) provides additional bidirectional communication methods for ext-apps widgets.

### Update Model Context

Share widget state with the AI model:

```typescript
// Update context (merged with existing by default)
await window.mcpBridge.updateModelContext({
  selectedItem: 'item-123',
  userPreference: 'detailed',
});

// Replace context entirely
await window.mcpBridge.updateModelContext(newContext, false);
```

This allows the model to reference widget state in subsequent interactions.

### Widget Logging

Send log messages to the host for debugging:

```typescript
await window.mcpBridge.log('info', 'Widget initialized');
await window.mcpBridge.log('debug', 'User clicked button', { buttonId: 'submit' });
await window.mcpBridge.log('warn', 'Connection slow');
await window.mcpBridge.log('error', 'Failed to fetch data', { error: err.message });
```

### Dynamic Tool Registration

Widgets can register tools dynamically:

```typescript
// Register a widget-defined tool
await window.mcpBridge.registerTool(
  'widget_action',
  'Performs an action from the widget',
  {
    type: 'object',
    properties: {
      action: { type: 'string', enum: ['approve', 'reject'] },
      reason: { type: 'string' },
    },
    required: ['action'],
  }
);

// Later, unregister when no longer needed
await window.mcpBridge.unregisterTool('widget_action');
```

### Check Host Capabilities

Before using ext-apps features, check if the host supports them:

```typescript
// The bridge falls back gracefully, but you can check explicitly
try {
  await window.mcpBridge.updateModelContext({ key: 'value' });
} catch (err) {
  if (err.message.includes('not supported')) {
    console.log('Host does not support model context updates');
  }
}
```

## Complete Interactive Widget

```typescript
import { Tool, ToolContext } from '@frontmcp/sdk';
import { card, button, input, badge } from '@frontmcp/ui/components';

@Tool({
  name: 'todo_list',
  description: 'Interactive todo list',
  ui: {
    template: (ctx) => {
      const { output, helpers } = ctx;

      const todoItems = output.todos.map(todo => `
        <li class="flex items-center gap-2 py-2">
          <input type="checkbox"
                 ${todo.done ? 'checked' : ''}
                 onchange="toggleTodo(${JSON.stringify(todo.id)}, this.checked)">
          <span class="${todo.done ? 'line-through text-gray-500' : ''}">
            ${helpers.escapeHtml(todo.text)}
          </span>
          ${badge(todo.priority, { variant: todo.priority === 'high' ? 'danger' : 'default' })}
        </li>
      `).join('');

      return card(`
        <ul class="divide-y">${todoItems}</ul>

        <div class="flex gap-2 mt-4">
          ${input({ id: 'new-todo', placeholder: 'New todo...' })}
          ${button('Add', { id: 'add-btn' })}
        </div>

        <script>
          async function toggleTodo(id, done) {
            await window.mcpBridge.callTool('update_todo', { id, done });
          }

          document.getElementById('add-btn').addEventListener('click', async () => {
            const input = document.getElementById('new-todo');
            if (input.value.trim()) {
              await window.mcpBridge.callTool('add_todo', { text: input.value });
              input.value = '';
            }
          });
        </script>
      `, { title: 'My Todos' });
    },
    widgetAccessible: true, // Enable tool calls from widget
  },
})
export class TodoListTool extends ToolContext {
  // ...
}
```

## Security Considerations

### Enable Widget Access Explicitly

```typescript
ui: {
  template: ...,
  widgetAccessible: true, // Must opt-in
}
```

### Validate Tool Calls

Server-side, validate all tool calls from widgets:

```typescript
// In your tool's execute method
async execute(input: Input): Promise<Output> {
  // Validate input
  const validated = inputSchema.parse(input);

  // Check permissions
  if (!this.scope.hasPermission('todos:write')) {
    throw new UnauthorizedError();
  }

  // Process request...
}
```

### Content Security Policy

Restrict what the widget can access:

```typescript
ui: {
  csp: {
    connectDomains: ['api.yourdomain.com'],
    resourceDomains: ['cdn.yourdomain.com'],
  },
}
```

## Platform Compatibility

| Feature              | OpenAI | ext-apps | Claude | Gemini |
| -------------------- | ------ | -------- | ------ | ------ |
| `callTool`           | Yes    | Yes\*    | Yes\*  | No     |
| `sendMessage`        | Yes    | Yes      | Yes    | No     |
| `openLink`           | Yes    | Yes\*    | Yes\*  | Yes    |
| `setWidgetState`     | Yes    | Yes      | Yes    | No     |
| `onContextChange`    | Yes    | Yes      | Yes    | No     |
| `updateModelContext` | No     | Yes\*    | Yes\*  | No     |
| `log`                | No     | Yes\*    | Yes\*  | No     |
| `registerTool`       | No     | Yes\*    | Yes\*  | No     |
| `unregisterTool`     | No     | Yes\*    | Yes\*  | No     |
| `resourceUri`        | Yes    | Yes      | Yes    | No     |

\*Features depend on host capabilities negotiated during initialization.

<Note>
  **Claude MCP Apps:** Claude supports the ext-apps protocol with full
  bidirectional JSON-RPC communication via `window.__mcpAppsEnabled`.

See: [MCP Apps Announcement](https://blog.modelcontextprotocol.io/posts/2026-01-26-mcp-apps/)

</Note>

<Note>
  **Platform Detection:** The bridge uses explicit markers to detect each platform.
  For ext-apps, set `window.__mcpPlatform = 'ext-apps'` before loading the bridge.
  Generic iframes without markers will use the fallback generic adapter.
</Note>

Always check capabilities before using features:

```typescript
if (window.mcpBridge?.callTool) {
  await window.mcpBridge.callTool('my_tool', params);
} else {
  showMessage('Interactive features not available on this platform');
}
```

## Best Practices

1. **Check feature availability** - Not all platforms support all features
2. **Handle errors gracefully** - Tool calls can fail
3. **Show loading states** - Give feedback during async operations
4. **Validate on server** - Never trust client-side input
5. **Use CSP** - Limit what widgets can access
6. **Clean up subscriptions** - Prevent memory leaks
