---
title: Getting Started with FrontMCP UI
sidebarTitle: Getting Started
icon: rocket-launch
description: This guide walks you through adding visual widgets to your FrontMCP tools using @frontmcp/ui.
---

## Prerequisites

- A FrontMCP server project set up with `@frontmcp/sdk`
- Node.js 22 or newer (Node 24 Active LTS recommended to match the dev runtime)

## Installation

FrontMCP UI is split into two packages:

| Package            | Use Case                                                         |
| ------------------ | ---------------------------------------------------------------- |
| `@frontmcp/uipack` | HTML shell builder, import resolver, component loader (no React) |
| `@frontmcp/ui`     | React components, hooks, SSR rendering                           |

<CodeGroup>
```bash npm
# For HTML templates only (no React required)
npm install @frontmcp/uipack

# For React templates

npm install @frontmcp/ui react react-dom

````

```bash yarn
# For HTML templates only (no React required)
yarn add @frontmcp/uipack

# For React templates
yarn add @frontmcp/ui react react-dom
````

```bash pnpm
# For HTML templates only (no React required)
pnpm add @frontmcp/uipack

# For React templates
pnpm add @frontmcp/ui react react-dom
```

</CodeGroup>

## Step 1: Add UI Config to Your Tool

The simplest way to add a widget is with an HTML template function:

```typescript title="src/tools/hello.tool.ts"
import { Tool, ToolContext } from '@frontmcp/sdk';
import { z } from 'zod';

@Tool({
  name: 'say_hello',
  description: 'Greet a user',
  inputSchema: {
    name: z.string().describe('Name to greet'),
  },
  ui: {
    template: (ctx) => `
      <div class="p-6 bg-white rounded-xl shadow-lg">
        <h1 class="text-2xl font-bold text-gray-800">
          Hello, ${ctx.helpers.escapeHtml(ctx.output.name)}!
        </h1>
        <p class="text-gray-600 mt-2">
          Welcome to FrontMCP UI
        </p>
      </div>
    `,
  },
})
export class HelloTool extends ToolContext {
  async execute(input: { name: string }) {
    return { name: input.name };
  }
}
```

<Warning>
  Always use `ctx.helpers.escapeHtml()` for user-provided content to prevent XSS attacks.
</Warning>

## Step 2: Use Template Helpers

The template context provides several helper functions:

```typescript
ui: {
  template: (ctx) => {
    const { input, output, helpers } = ctx;

    return `
      <div class="p-4">
        <!-- Escape HTML to prevent XSS -->
        <p>${helpers.escapeHtml(output.message)}</p>

        <!-- Format dates -->
        <p>Created: ${helpers.formatDate(output.createdAt)}</p>

        <!-- Format currency -->
        <p>Total: ${helpers.formatCurrency(output.amount, 'USD')}</p>

        <!-- Generate unique IDs -->
        <input id="${helpers.uniqueId('input')}" type="text" />

        <!-- Safely embed JSON -->
        <script>
          const data = ${helpers.jsonEmbed(output.data)};
        </script>
      </div>
    `;
  },
}
```

### Available Helpers

| Helper                              | Description                    |
| ----------------------------------- | ------------------------------ |
| `escapeHtml(str)`                   | Escape HTML special characters |
| `formatDate(date, format?)`         | Format a date for display      |
| `formatCurrency(amount, currency?)` | Format a number as currency    |
| `uniqueId(prefix?)`                 | Generate a unique DOM ID       |
| `jsonEmbed(data)`                   | Safely embed JSON in HTML      |

## Step 3: Use Pre-built Components

`@frontmcp/uipack` provides a library of styled HTML components:

```typescript title="src/tools/user-profile.tool.ts"
import { Tool, ToolContext } from '@frontmcp/sdk';
import { z } from 'zod';

@Tool({
  name: 'get_user',
  description: 'Get user profile',
  inputSchema: {
    userId: z.string(),
  },
  ui: {
    template: (ctx) => {
      const { output, helpers } = ctx;

      return `
        <div style="border:1px solid #e2e8f0; border-radius:8px; padding:16px;">
          <h3 style="margin:0 0 12px;">User Profile</h3>
          <div style="display:flex; align-items:center; gap:16px;">
            <img
              src="${helpers.escapeHtml(output.avatar)}"
              style="width:64px; height:64px; border-radius:50%;"
              alt="Avatar"
            />
            <div>
              <h2 style="font-size:1.25rem; font-weight:bold; margin:0;">
                ${helpers.escapeHtml(output.name)}
              </h2>
              <p style="color:#718096; margin:4px 0 0;">
                ${helpers.escapeHtml(output.email)}
              </p>
            </div>
            <span style="background:#3182ce; color:#fff; padding:2px 10px; border-radius:9999px; font-size:0.875rem;">
              ${helpers.escapeHtml(output.role)}
            </span>
          </div>
        </div>
      `;
    },
  },
})
export class GetUserTool extends ToolContext {
  async execute(input: { userId: string }) {
    return {
      name: 'John Doe',
      email: 'john@example.com',
      avatar: 'https://example.com/avatar.jpg',
      role: 'Admin',
    };
  }
}
```

## Complete Weather Example

Here's a full example combining multiple components:

```typescript title="src/tools/weather.tool.ts"
import { Tool, ToolContext } from '@frontmcp/sdk';
import { Card, Badge, Alert } from '@frontmcp/ui/components';
import { z } from 'zod';

const inputSchema = {
  location: z.string().describe('City name'),
  units: z.enum(['celsius', 'fahrenheit']).optional(),
};

const outputSchema = z.object({
  location: z.string(),
  temperature: z.number(),
  units: z.enum(['celsius', 'fahrenheit']),
  conditions: z.string(),
  humidity: z.number(),
  windSpeed: z.number(),
});

@Tool({
  name: 'get_weather',
  description: 'Get current weather for a location',
  inputSchema,
  outputSchema,
  ui: {
    template: (ctx) => {
      const { output, helpers } = ctx;
      const tempUnit = output.units === 'celsius' ? '¬∞C' : '¬∞F';

      const weatherIcons: Record<string, string> = {
        sunny: '‚òÄÔ∏è',
        cloudy: '‚òÅÔ∏è',
        rainy: 'üåßÔ∏è',
        foggy: 'üå´Ô∏è',
      };

      const icon = weatherIcons[output.conditions.toLowerCase()] || 'üå§Ô∏è';

      return card(`
        <div class="text-center">
          <div class="text-6xl mb-4">${icon}</div>
          <div class="text-4xl font-bold mb-2">
            ${output.temperature}${tempUnit}
          </div>
          ${badge(output.conditions, { variant: 'info' })}
        </div>

        <div class="grid grid-cols-2 gap-4 mt-6">
          <div class="text-center p-3 bg-gray-50 rounded-lg">
            <div class="text-sm text-gray-500">Humidity</div>
            <div class="text-lg font-semibold">${output.humidity}%</div>
          </div>
          <div class="text-center p-3 bg-gray-50 rounded-lg">
            <div class="text-sm text-gray-500">Wind</div>
            <div class="text-lg font-semibold">${output.windSpeed} km/h</div>
          </div>
        </div>
      `, {
        title: helpers.escapeHtml(output.location),
        subtitle: 'Current Weather',
      });
    },
    displayMode: 'inline',
    widgetDescription: 'Displays current weather conditions',
  },
})
export class GetWeatherTool extends ToolContext {
  async execute(input: { location: string; units?: 'celsius' | 'fahrenheit' }) {
    // In production, call a weather API here
    const units = input.units || 'celsius';

    return {
      location: input.location,
      temperature: units === 'celsius' ? 18 : 64,
      units,
      conditions: 'Cloudy',
      humidity: 65,
      windSpeed: 12,
    };
  }
}
```

## Testing Your Widget

1. Start your MCP server in development mode
2. Connect to it via an MCP client (OpenAI, Claude, etc.)
3. Call your tool and see the widget rendered

<Tip>
  Use the `displayMode` option to control how your widget appears:
  - `inline` - Rendered inline with the chat
  - `fullscreen` - Takes over the full viewport
  - `pip` - Picture-in-picture mode (OpenAI only)
</Tip>

## Try the UI Demo

<Steps>
<Step title="Spin up the UI demo server">

```bash
pnpm nx serve demo-e2e-ui --port 3003
```

This server exposes multiple tools with different UI types (React, MDX, HTML, Markdown), transparent auth defaults, and `publicMode`-friendly settings so you can hit it from the MCP Inspector.

</Step>
<Step title="Run the UI regression tests">

```bash
pnpm nx test demo-e2e-ui
```

The test suite relies on `@frontmcp/testing`'s `UIAssertions` helpers (`toHaveRenderedHtml`, `toNotContainRawContent`, `assertValidUI`) so you can copy/paste the assertions into your own projects.

<Check>
The Jest output should confirm every test as passing and report that rendered HTML contains widget metadata instead of the `mdx-fallback`.
</Check>

</Step>
</Steps>

<Tip>
Keep these demos around as golden references; updating them first helps catch regressions in new template renderers or auth transport tweaks before they land in production apps.
</Tip>

## Next Steps

<CardGroup cols={2}>
  <Card title="Components" icon="grid-2" href="/frontmcp/ui/components/overview">
    Explore all available components
  </Card>
  <Card title="Templates" icon="code" href="/frontmcp/ui/templates/overview">
    Learn about React and MDX templates
  </Card>
  <Card title="Theming" icon="paintbrush" href="/frontmcp/ui/theming/overview">
    Customize colors and styling
  </Card>
  <Card title="Platform Support" icon="globe" href="/frontmcp/ui/advanced/platforms">
    Platform-specific considerations
  </Card>
</CardGroup>
