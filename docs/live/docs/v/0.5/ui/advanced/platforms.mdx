---
title: Platform Support
sidebarTitle: Platforms
icon: globe
description: FrontMCP UI adapts to different AI platform capabilities. Each platform has different constraints for widget rendering.
---

## Platform Capabilities

| Platform   | Network | External Scripts | Widget Modes            | Theme   |
| ---------- | ------- | ---------------- | ----------------------- | ------- |
| **OpenAI** | Open    | CDN allowed      | inline, fullscreen, pip | Yes     |
| **Claude** | Blocked | Inline only      | Artifacts               | Limited |
| **Gemini** | Limited | Inline preferred | Basic                   | No      |

## Platform Detection

FrontMCP automatically detects the platform:

```typescript
import { getPlatform, OPENAI_PLATFORM, CLAUDE_PLATFORM } from '@frontmcp/ui';

// Auto-detect from user agent or context
const platform = getPlatform();

// Check capabilities
if (platform.network === 'open') {
  // Can fetch external resources
}

if (platform.scripts === 'inline') {
  // Must inline all scripts
}
```

## OpenAI

OpenAI's Apps SDK provides full widget capabilities:

### Features

- Full network access
- External CDN scripts (Tailwind, HTMX)
- Multiple display modes (inline, fullscreen, pip)
- Theme detection
- Tool invocation from widgets
- Widget state persistence

### Configuration

```typescript
import { OPENAI_PLATFORM } from '@frontmcp/ui';

// Platform preset
console.log(OPENAI_PLATFORM);
// {
//   id: 'openai',
//   network: 'open',
//   scripts: 'external',
//   capabilities: {
//     callTool: true,
//     sendMessage: true,
//     openExternal: true,
//     requestDisplayMode: true,
//     widgetState: true,
//   },
// }
```

### Runtime API

OpenAI exposes `window.openai`:

```typescript
// Properties
window.openai.theme         // 'light' | 'dark'
window.openai.displayMode   // 'inline' | 'fullscreen' | 'pip'
window.openai.toolInput     // Tool input arguments
window.openai.toolOutput    // Tool output/result
window.openai.userAgent     // Device info

// Methods
window.openai.callTool(name, args)        // Call MCP tool
window.openai.sendFollowUpMessage({ prompt }) // Send chat message
window.openai.openExternal({ href })      // Open link
window.openai.requestDisplayMode({ mode }) // Change display mode
window.openai.setWidgetState(state)       // Persist state
```

## Claude

Claude uses Artifacts with restricted capabilities:

### Constraints

- **Network blocked** - Cannot fetch external resources
- **Scripts must be inline** - No CDN script tags
- **Limited interactivity** - No tool invocation from widgets

### Configuration

```typescript
import { CLAUDE_PLATFORM } from '@frontmcp/ui';

// Platform preset
console.log(CLAUDE_PLATFORM);
// {
//   id: 'claude',
//   network: 'blocked',
//   scripts: 'inline',
//   capabilities: {
//     callTool: false,
//     sendMessage: false,
//     openExternal: true,
//     requestDisplayMode: false,
//     widgetState: false,
//   },
// }
```

### Handling Blocked Network

For Claude, inline all scripts:

```typescript
import { baseLayout, fetchAndCacheScriptsFromTheme } from '@frontmcp/ui';

// Pre-fetch and cache scripts at startup
await fetchAndCacheScriptsFromTheme(theme);

// Then build with inline scripts
const html = baseLayout({
  content: '...',
  theme,
  platform: 'claude',
  scripts: true, // Will inline cached scripts
});
```

### Tailwind Without CDN

For Claude, use pre-built CSS or inline styles:

```typescript
// Option 1: Pre-built Tailwind
const html = `
<style>
  /* Pre-compiled Tailwind classes you use */
  .p-4 { padding: 1rem; }
  .text-xl { font-size: 1.25rem; }
  /* ... */
</style>
<div class="p-4 text-xl">Content</div>
`;

// Option 2: Inline styles
const html = `
<div style="padding: 1rem; font-size: 1.25rem;">Content</div>
`;
```

## Gemini

Gemini has limited widget support:

### Configuration

```typescript
import { GEMINI_PLATFORM } from '@frontmcp/ui';

// Platform preset
console.log(GEMINI_PLATFORM);
// {
//   id: 'gemini',
//   network: 'limited',
//   scripts: 'inline',
//   capabilities: {
//     callTool: false,
//     sendMessage: false,
//     openExternal: true,
//     requestDisplayMode: false,
//     widgetState: false,
//   },
// }
```

### Best Practices

For Gemini, keep widgets simple:

- Use inline styles
- Avoid complex interactivity
- Focus on data display

## Platform-Aware Templates

Create templates that adapt to the platform:

```typescript
import { getPlatform, canUseCdn, needsInlineScripts } from '@frontmcp/ui';

@Tool({
  name: 'my_tool',
  ui: {
    template: (ctx) => {
      const platform = getPlatform();

      // Use CDN on capable platforms
      const useExternalScripts = canUseCdn(platform);

      // Build appropriate HTML
      return buildWidgetHtml({
        content: ctx.output,
        inlineScripts: needsInlineScripts(platform),
        useExternalScripts,
      });
    },
  },
})
```

## Fallback Modes

Handle missing capabilities gracefully:

```typescript
import { supportsFullInteractivity, getFallbackMode } from '@frontmcp/ui';

const platform = getPlatform();

if (supportsFullInteractivity(platform)) {
  // Full widget with tool calls
  return interactiveWidget(ctx);
} else {
  // Static display only
  const fallback = getFallbackMode(platform);
  return staticWidget(ctx, fallback);
}
```

## Custom Platforms

Define custom platform configurations:

```typescript
import { createPlatform } from '@frontmcp/ui';

const myPlatform = createPlatform({
  id: 'my-platform',
  network: 'open',
  scripts: 'external',
  capabilities: {
    callTool: true,
    sendMessage: true,
    openExternal: true,
    requestDisplayMode: false,
    widgetState: true,
  },
});
```

## Content Security Policy

Configure CSP based on platform:

```typescript
@Tool({
  name: 'my_tool',
  ui: {
    template: ...,
    csp: {
      // OpenAI: Allow CDNs
      connectDomains: ['api.example.com'],
      resourceDomains: ['cdn.example.com', 'fonts.googleapis.com'],
    },
  },
})
```

For Claude (blocked network), CSP is largely irrelevant since external resources can't be fetched anyway.

## Testing Across Platforms

Test your widgets on each platform:

```typescript
// Mock platform for testing
import { getPlatform } from '@frontmcp/ui';

// Override for testing
jest.mock('@frontmcp/ui', () => ({
  ...jest.requireActual('@frontmcp/ui'),
  getPlatform: jest.fn().mockReturnValue({
    id: 'claude',
    network: 'blocked',
    scripts: 'inline',
  }),
}));
```

## Best Practices

1. **Design for constraints** - Start with Claude's limitations, enhance for OpenAI
2. **Progressive enhancement** - Add features based on platform capabilities
3. **Test on all platforms** - Verify appearance and functionality
4. **Cache scripts** - Pre-fetch for blocked-network platforms
5. **Provide fallbacks** - Graceful degradation when features unavailable
6. **Document platform differences** - Help users understand what to expect
