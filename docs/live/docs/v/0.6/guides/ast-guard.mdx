---
title: ast-guard - JavaScript Security Validator
sidebarTitle: ast-guard
slug: guides/ast-guard
description: Bank-grade AST validation for JavaScript. 100% CVE coverage, 600+ security tests, zero dependencies. Block code injection before it runs.
icon: shield-check
---

**ast-guard** is a zero-dependency JavaScript validator that inspects code at the AST level before execution. It blocks dangerous constructs, enforces API policies, and provides **100% coverage** against known vm2/isolated-vm CVEs with **600+ security tests**.

<CardGroup cols={3}>
  <Card title="100% CVE Coverage" icon="shield-check">
    Every known vm2 and isolated-vm bypass is blocked. 600+ security tests.
  </Card>
  <Card title="Layer 0 Defense" icon="radar">
    Pre-scanner catches DoS attacks BEFORE the parser runs.
  </Card>
  <Card title="Zero Dependencies" icon="feather">
    Pure TypeScript using only acorn for parsing. Works everywhere.
  </Card>
</CardGroup>

---

## Why ast-guard?

Runtime sandboxes alone aren't enough. By the time code reaches runtime, the damage may already be done. ast-guard validates code **before** execution, blocking attacks at the source.

| Feature                        | vm2 Runtime            | ast-guard + Enclave   |
| ------------------------------ | ---------------------- | --------------------- |
| Validation timing              | After execution starts | **Before execution**  |
| eval/Function detection        | Sometimes              | **Always blocked**    |
| Prototype pollution            | Partial                | **100% blocked**      |
| ReDoS protection               | No                     | **Pre-scanner layer** |
| Trojan Source (CVE-2021-42574) | No                     | **Blocked**           |
| Security tests                 | ~100                   | **600+**              |

<Note>
  ast-guard powers [Enclave's](/docs/guides/enclave) first security layer and can be used standalone for any JavaScript validation needs.
</Note>

---

## Installation

<CodeGroup>
```bash npm
npm install ast-guard
```
```bash pnpm
pnpm add ast-guard
```
```bash yarn
yarn add ast-guard
```
</CodeGroup>

---

## Quick Start

```ts
import { JSAstValidator, createAgentScriptPreset } from 'ast-guard';

const validator = new JSAstValidator(createAgentScriptPreset());

const result = await validator.validate(`
  const users = await callTool('users:list', { limit: 10 });
  return users.filter(u => u.active);
`);

if (result.valid) {
  console.log('Code is safe to execute');
} else {
  console.log('Blocked:', result.issues);
}
```

---

## Pre-Scanner (Layer 0)

The pre-scanner runs **before** the JavaScript parser to catch attacks that could DoS or crash the parser itself. This is critical defense that other validators miss.

```ts
import { PreScanner, createPreScannerConfig } from 'ast-guard';

const scanner = new PreScanner(createPreScannerConfig('agentscript'));
const result = scanner.scan(userCode);

if (!result.valid) {
  // Don't even attempt to parse - could DoS the parser
  console.log('Pre-scan failed:', result.issues);
}
```

### Attacks Blocked by Pre-Scanner

| Attack                | Description                                     | Impact                                  |
| --------------------- | ----------------------------------------------- | --------------------------------------- |
| **ReDoS**             | `(a+)+` patterns cause exponential backtracking | Parser hangs for hours                  |
| **Trojan Source**     | Unicode BiDi characters hide malicious code     | Code appears different than it executes |
| **Stack Overflow**    | Deeply nested `(((((x)))))` crashes parser      | Server crashes                          |
| **Memory Exhaustion** | 100MB input exhausts memory                     | OOM kill                                |

### Mandatory Limits (Cannot Disable)

| Limit             | Value         | Purpose              |
| ----------------- | ------------- | -------------------- |
| Max Input Size    | 100MB         | Memory protection    |
| Max Nesting Depth | 200 levels    | Stack protection     |
| Max Line Length   | 100,000 chars | Minified code safety |
| Max Regex Length  | 1,000 chars   | ReDoS protection     |

---

## AgentScript Preset

The AgentScript preset is purpose-built for LLM-generated code. It uses a **whitelist-only** approach where only explicitly allowed constructs are permitted.

```ts
import { JSAstValidator, createAgentScriptPreset } from 'ast-guard';

const validator = new JSAstValidator(createAgentScriptPreset({
  requireCallTool: true,      // Must call at least one tool
  allowArrowFunctions: true,  // For array methods
  allowedLoops: {
    allowFor: true,           // for (let i = 0; ...)
    allowForOf: true,         // for (const x of arr)
    allowWhile: false,        // while (cond) - BLOCKED
    allowDoWhile: false,      // do-while - BLOCKED
    allowForIn: false,        // for-in - BLOCKED (prototype walking)
  },
}));
```

### What AgentScript Blocks

| Category            | Blocked                             | Why                 |
| ------------------- | ----------------------------------- | ------------------- |
| **Code Execution**  | `eval`, `Function`, `AsyncFunction` | Code injection      |
| **System Access**   | `process`, `require`, `module`      | Node.js escape      |
| **Global Objects**  | `window`, `globalThis`, `this`      | Sandbox escape      |
| **Timers**          | `setTimeout`, `setInterval`         | Async escape        |
| **Prototype**       | `__proto__`, `constructor`          | Prototype pollution |
| **Network**         | `fetch`, `XMLHttpRequest`           | Data exfiltration   |
| **Unbounded Loops** | `while`, `do-while`, `for-in`       | Infinite loops      |

### What AgentScript Allows

```js
// Tool calls
const result = await callTool('users:list', { limit: 10 });

// Variables
const users = result.items;
let count = 0;

// Bounded loops
for (let i = 0; i < users.length; i++) { count++; }
for (const user of users) { console.log(user.name); }

// Array methods with arrows
const active = users.filter(u => u.active);
const names = users.map(u => u.name);

// Safe globals
const max = Math.max(1, 2, 3);
const parsed = JSON.parse('{"a":1}');

// Return values
return { count, names };
```

---

## Security Presets

ast-guard provides four security presets for different use cases:

| Preset          | Use Case             | Security Level            |
| --------------- | -------------------- | ------------------------- |
| **AgentScript** | LLM-generated code   | Highest - whitelist only  |
| **STRICT**      | Untrusted guest code | High - no loops, no async |
| **SECURE**      | Automation scripts   | Medium - bounded loops    |
| **STANDARD**    | Trusted scripts      | Low - basic guardrails    |

```ts
import { JSAstValidator, createAgentScriptPreset, Presets } from 'ast-guard';

// AgentScript (recommended for LLM code)
const agentScript = new JSAstValidator(createAgentScriptPreset());

// STRICT preset
const strict = new JSAstValidator(Presets.strict());

// SECURE preset
const secure = new JSAstValidator(Presets.secure());
```

---

## Built-in Rules

ast-guard ships with comprehensive security rules:

### UnicodeSecurityRule

Blocks Trojan Source attacks (CVE-2021-42574) and homoglyphs:

```ts
import { UnicodeSecurityRule } from 'ast-guard';

const rule = new UnicodeSecurityRule({
  blockBidi: true,        // Block bidirectional overrides
  blockHomoglyphs: true,  // Block lookalike characters
  blockZeroWidth: true,   // Block invisible characters
});
```

### StaticCallTargetRule

Enforces static string literals for call targets:

```ts
import { StaticCallTargetRule } from 'ast-guard';

const rule = new StaticCallTargetRule({
  targetFunctions: ['callTool'],
  argumentPosition: 0,
});

// Blocks:
callTool(toolName, args);           // Variable reference
callTool("tool" + suffix, args);    // Concatenation
callTool(`tool_${id}`, args);       // Template with expressions
```

### NoRegexLiteralRule

Blocks or analyzes regex for ReDoS:

```ts
import { NoRegexLiteralRule } from 'ast-guard';

// Block all regex (AgentScript)
new NoRegexLiteralRule({ blockAll: true });

// Analyze for ReDoS (STRICT/SECURE)
new NoRegexLiteralRule({
  analyzePatterns: true,
  analysisLevel: 'catastrophic',
  blockThreshold: 80,
});
```

### ReservedPrefixRule

Protects internal identifiers:

```ts
import { ReservedPrefixRule } from 'ast-guard';

const rule = new ReservedPrefixRule({
  prefixes: ['__ag_', '__safe_'],
});

// Blocks:
const __ag_hack = 'foo';    // Reserved prefix
let __safe_bypass = 123;    // Reserved prefix
```

---

## Code Transformation

ast-guard can transform validated code for safe execution:

```ts
import { transformAgentScript } from 'ast-guard';

const code = `
  const users = await callTool('users:list', {});
  for (const user of users) {
    console.log(user.name);
  }
`;

const transformed = transformAgentScript(code, {
  wrapInMain: true,         // Wrap in async main()
  transformCallTool: true,  // callTool â†’ __safe_callTool
  transformLoops: true,     // Add iteration limits
});

// Result:
// async function __ag_main() {
//   const users = await __safe_callTool('users:list', {});
//   __safe_forOf(users, (user) => {
//     console.log(user.name);
//   });
// }
```

---

## Validation in Tools

Use ast-guard inside FrontMCP tools:

```ts
import { Tool, ToolContext } from '@frontmcp/sdk';
import { JSAstValidator, createAgentScriptPreset } from 'ast-guard';

const validator = new JSAstValidator(createAgentScriptPreset());

@Tool({
  name: 'run-script',
  description: 'Execute JavaScript in sandbox',
})
export default class RunScriptTool extends ToolContext {
  async execute(input: { source: string }) {
    const result = await validator.validate(input.source);

    if (!result.valid) {
      throw new Error(`Validation failed: ${result.issues[0].message}`);
    }

    // Safe to execute
    return { status: 'accepted' };
  }
}
```

---

## Error Handling

Validation results include actionable error information:

```ts
const result = await validator.validate(source);

if (!result.valid) {
  for (const issue of result.issues) {
    console.log({
      code: issue.code,           // 'DISALLOWED_IDENTIFIER'
      severity: issue.severity,   // 'error' | 'warning'
      message: issue.message,     // 'eval is not allowed'
      location: issue.location,   // { line: 5, column: 12 }
    });
  }
}
```

---

## Configuration Options

<ParamField path="stopOnFirstError" type="boolean" default="false">
  Halt validation on first error (faster for latency-sensitive flows)
</ParamField>

<ParamField path="maxIssues" type="number" default="100">
  Maximum issues to return per validation
</ParamField>

<ParamField path="parseOptions" type="object">
  Acorn parser options (`sourceType`, `ecmaVersion`, etc.)
</ParamField>

---

## Resources

<CardGroup cols={2}>
  <Card title="Enclave" icon="lock" href="/docs/guides/enclave">
    Runtime sandbox that uses ast-guard for validation
  </Card>
  <Card title="CodeCall Plugin" icon="code" href="/docs/plugins/codecall/overview">
    See ast-guard in action with CodeCall
  </Card>
  <Card title="GitHub" icon="github" href="https://github.com/agentfront/enclave/tree/main/libs/ast-guard">
    View source code and security tests
  </Card>
  <Card title="Security Audit" icon="file-shield" href="https://github.com/agentfront/enclave/blob/main/libs/ast-guard/docs/SECURITY-AUDIT.md">
    Full list of 600+ blocked attack vectors
  </Card>
</CardGroup>
