---
title: VectoriaDB - Lightweight Vector Search
sidebarTitle: VectoriaDB
slug: guides/vectoriadb
description: Zero-dependency vector database for AI agents. Offline semantic search, HNSW indexing, TF-IDF fallback. No API keys, no cloud, instant results.
icon: magnifying-glass
---

**VectoriaDB** is a lightweight, offline-first vector database designed for AI agent systems. Run semantic search without sending data to external services. **No API keys, no cloud dependencies, instant results.**

<CardGroup cols={3}>
  <Card title="100% Offline" icon="bolt">
    Embeddings run locally via transformers.js. Your data never leaves the server.
  </Card>
  <Card title="Sub-Millisecond Search" icon="clock">
    HNSW indexing delivers >95% recall with 10,000+ documents.
  </Card>
  <Card title="Zero-Dep TF-IDF Mode" icon="feather">
    Pure TypeScript fallback when ML models aren't an option.
  </Card>
</CardGroup>

---

## Why VectoriaDB?

External embedding APIs add latency, cost, and privacy concerns. VectoriaDB runs **entirely on your server** with no network calls.

| Feature | External APIs (OpenAI, etc.) | VectoriaDB |
|---------|------------------------------|------------|
| Data privacy | Sent to third party | **Stays local** |
| Latency | 100-500ms network RTT | **Sub-1ms local** |
| Cost | Per-token pricing | **Free** |
| Offline support | Requires internet | **Works offline** |
| Rate limits | Yes | **None** |

<Note>
  The default `all-MiniLM-L6-v2` model is ~22MB. Downloaded once on first use and cached locally.
</Note>

---

## Installation

<CodeGroup>
```bash npm
npm install vectoriadb
```
```bash pnpm
pnpm add vectoriadb
```
```bash yarn
yarn add vectoriadb
```
</CodeGroup>

---

## Quick Start

```ts
import { VectoriaDB, DocumentMetadata } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  category: string;
}

const db = new VectoriaDB<ToolDocument>({
  cacheDir: './.cache/transformers',
  defaultSimilarityThreshold: 0.4,
});

await db.initialize();

// Add documents
await db.add('tool-1', 'User authentication and login management', {
  id: 'tool-1',
  toolName: 'auth:login',
  category: 'security',
});

await db.add('tool-2', 'Send email notifications to users', {
  id: 'tool-2',
  toolName: 'notifications:sendEmail',
  category: 'communication',
});

// Semantic search
const results = await db.search('how do users log in?', { topK: 5 });

console.log(results[0].metadata.toolName); // 'auth:login'
console.log(results[0].score);             // 0.87
```

---

## Use Cases

### Tool Discovery for AI Agents

Let AI models find the right tools by description:

```ts
const matches = await db.search('send notification to user', {
  topK: 3,
  threshold: 0.5,
  filter: (m) => m.category === 'communication',
});

// Returns tools like 'notifications:sendEmail', 'notifications:sendSMS'
```

### Document Retrieval (RAG)

Build retrieval-augmented generation without external APIs:

```ts
const context = await db.search(userQuery, { topK: 5 });
const contextText = context.map(r => r.text).join('\n');

// Pass to LLM as context
const response = await llm.generate({
  prompt: userQuery,
  context: contextText,
});
```

### Semantic Deduplication

Find similar documents before adding new ones:

```ts
const similar = await db.search(newDocument, { threshold: 0.9 });
if (similar.length > 0) {
  console.log('Duplicate detected:', similar[0].metadata.id);
} else {
  await db.add(newId, newDocument, metadata);
}
```

---

## Embedding Strategies

### ML Embeddings (Default)

Full semantic understanding using transformer models:

```ts
const db = new VectoriaDB<MyDoc>({
  modelName: 'Xenova/all-MiniLM-L6-v2',  // Default
  cacheDir: './.cache/transformers',
});

await db.initialize(); // Downloads model on first run
```

**Pros:** Best semantic accuracy, understands synonyms and context
**Cons:** ~22MB model download, async initialization

### TF-IDF (Zero Dependencies)

Keyword-based search with no ML models:

```ts
import { TFIDFVectoria } from 'vectoriadb';

const db = new TFIDFVectoria<MyDoc>();

db.addDocument('tool-1', 'User authentication login', metadata);
db.addDocument('tool-2', 'Email notification sender', metadata);

db.reindex(); // Required after adding documents

const results = db.search('authentication', { topK: 5 });
```

**Pros:** Zero dependencies, synchronous, instant startup
**Cons:** Keyword-only, no semantic understanding

### When to Use Each

| Scenario | Recommendation |
|----------|----------------|
| General semantic search | **ML Embeddings** |
| Small corpus (under 1K docs) | Either works well |
| Large corpus (>10K docs) | ML + HNSW indexing |
| No model downloads allowed | **TF-IDF** |
| Extremely latency-sensitive | **TF-IDF** |
| Need synonyms/context | **ML Embeddings** |

---

## HNSW Indexing

For large document collections, enable HNSW (Hierarchical Navigable Small World) indexing:

```ts
const db = new VectoriaDB<MyDoc>({
  useHNSW: true,
  hnsw: {
    M: 16,              // Connections per node (higher = better recall)
    efConstruction: 200, // Build-time search depth
    efSearch: 64,        // Query-time search depth
  },
});
```

### HNSW vs Linear Search

| Documents | Linear Search | HNSW |
|-----------|---------------|------|
| 1,000 | 5ms | 1ms |
| 10,000 | 50ms | **2ms** |
| 100,000 | 500ms | **5ms** |

Enable HNSW when you have more than ~5,000 documents.

---

## Persistence

### File Storage

Save embeddings to disk for fast restarts:

```ts
import { VectoriaDB, FileStorageAdapter } from 'vectoriadb';

const db = new VectoriaDB<MyDoc>({
  storageAdapter: new FileStorageAdapter({
    cacheDir: './.cache/vectoriadb',
    namespace: 'tools',
  }),
});

await db.initialize(); // Loads from cache if available

// After adding documents
await db.saveToStorage();
```

### Redis Storage

Share embeddings across multiple pods:

```ts
import { VectoriaDB, RedisStorageAdapter } from 'vectoriadb';
import Redis from 'ioredis';

const db = new VectoriaDB<MyDoc>({
  storageAdapter: new RedisStorageAdapter({
    client: new Redis(),
    namespace: 'tools',
    ttl: 86400, // 24 hours
  }),
});
```

### Cache Invalidation

Use `toolsHash` to automatically invalidate when tools change:

```ts
import { createToolsHash } from 'vectoriadb';

const db = new VectoriaDB<MyDoc>({
  storageAdapter: new FileStorageAdapter({ ... }),
  toolsHash: createToolsHash(documents), // Hash of all documents
  version: process.env.npm_package_version,
});

// Cache auto-invalidates when hash or version changes
```

---

## Filtering & Metadata

Apply runtime filters on search results:

```ts
const results = await db.search('user management', {
  topK: 10,
  threshold: 0.3,
  filter: (metadata) => {
    return metadata.category === 'admin' && !metadata.deprecated;
  },
});
```

### Metadata Updates

Update metadata without re-embedding:

```ts
// Fast: metadata only
await db.updateMetadata('tool-1', { deprecated: true });

// Slow: re-embeds the document
await db.update('tool-1', 'New description text', { ...newMetadata });
```

---

## Configuration Reference

<ParamField path="modelName" type="string" default="Xenova/all-MiniLM-L6-v2">
  Transformer model for embeddings
</ParamField>

<ParamField path="cacheDir" type="string" default="./.cache/transformers">
  Model cache directory
</ParamField>

<ParamField path="defaultSimilarityThreshold" type="number" default="0.3">
  Minimum similarity score for results
</ParamField>

<ParamField path="defaultTopK" type="number" default="10">
  Default number of results
</ParamField>

<ParamField path="useHNSW" type="boolean" default="false">
  Enable HNSW indexing for large corpora
</ParamField>

<ParamField path="maxDocuments" type="number" default="100000">
  Maximum documents (DoS protection)
</ParamField>

<ParamField path="maxDocumentSize" type="number" default="1000000">
  Maximum document text size in characters
</ParamField>

---

## Error Handling

VectoriaDB provides typed errors for all failure modes:

```ts
import {
  VectoriaNotInitializedError,
  DocumentValidationError,
  DocumentNotFoundError,
  DocumentExistsError,
} from 'vectoriadb';

try {
  await db.add('doc-1', 'text', metadata);
} catch (error) {
  if (error instanceof VectoriaNotInitializedError) {
    await db.initialize();
  } else if (error instanceof DocumentExistsError) {
    await db.update('doc-1', 'text', metadata);
  }
}
```

---

## Monitoring

Track index health and memory usage:

```ts
const stats = db.getStats();

console.log({
  totalDocuments: stats.totalEmbeddings,
  dimensions: stats.dimensions,          // 384 for MiniLM
  memoryMB: stats.estimatedMemoryBytes / 1024 / 1024,
  model: stats.modelName,
});
```

---

## Resources

<CardGroup cols={2}>
  <Card title="CodeCall Plugin" icon="code" href="/docs/plugins/codecall/overview">
    VectoriaDB powers CodeCall's tool search
  </Card>
  <Card title="Enclave" icon="shield" href="/docs/guides/enclave">
    Secure sandbox that works with VectoriaDB
  </Card>
  <Card title="GitHub" icon="github" href="https://github.com/agentfront/enclave/tree/main/libs/vectoriadb">
    View source code and benchmarks
  </Card>
  <Card title="npm" icon="npm" href="https://www.npmjs.com/package/vectoriadb">
    Package details and version history
  </Card>
</CardGroup>
