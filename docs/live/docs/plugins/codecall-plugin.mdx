---
title: CodeCall Plugin
description: Hide large toolsets behind a small, code-first meta-API using CodeCall Plugin.
---

Instead of listing every tool in `list_tools`, CodeCall:

- Hides most tools.
- Exposes three main meta-tools:
- `codecall.search`
- `codecall.describe`
- `codecall.execute`
- And optionally, a direct-call helper:
- `codecall.invoke` (no code, no VM)

The model then:

1. Searches for relevant tools.
2. Describes selected tools (schemas).
3. Writes a JavaScript execution plan.
4. Executes that plan in a sandbox via `codecall.execute`, which calls your real tools.

This lets you:

- Expose **dozens or hundreds of tools** (including OpenAPI-generated ones).
- Avoid blowing up the context window.
- Let the LLM build richer workflows, joins, and filters in code.
- Work across **multiple apps** in the same FrontMCP server (e.g. `user` app + `billing` app).

---

## When to use CodeCall

Use CodeCall if:

- You have **many tools** (inline + adapters).
- You don’t want to dump them all into `list_tools`.
- You want the LLM to:
- Combine multiple tools.
- Filter and post-process results.
- Build logic your API doesn’t support directly.
- You run **multiple apps** (e.g. `user`, `billing`) and want the model to:
- Search tools within a specific app.
- Or search across all apps, depending on the task.

---

## Installation

```bash
npm install @frontmcp/plugins
# or
yarn add @frontmcp/plugins
# or
pnpm add @frontmcp/plugins
```

> CodeCall uses [`vm2`](https://github.com/patriksimek/vm2) to run LLM-authored JavaScript in a sandbox.

---

## Quick start

### 1. Add CodeCallPlugin to your app

```ts
import { App, Tool } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';

@Tool({
  name: 'health:ping',
  description: 'Simple health check',
  codecall: {
    visibleInListTools: true, // keep visible as a normal tool
    enabledInCodeCall: true, // also available inside CodeCall plans
  },
})
class HealthPingTool {
  async run() {
    return { status: 'ok' };
  }
}

@App({
  id: 'example',
  name: 'Example App',
  tools: [HealthPingTool],
  plugins: [
    CodeCallPlugin.init({
      // Recommended default: many tools, all accessible via CodeCall
      mode: 'codecall_only',

      topK: 8,
      maxDefinitions: 8,

      directCalls: {
        enabled: true,
        // optional allowlist, otherwise defaults to tools enabled for CodeCall
        allowedTools: ['users:getById', 'billing:getInvoice'],
      },

      vm: {
        preset: 'secure', // CSP-like preset
        timeoutMs: 4000,
        allowLoops: false,
        disabledBuiltins: ['eval', 'Function'],
        disabledGlobals: ['require', 'process', 'fetch', 'setTimeout', 'setInterval'],
        allowConsole: true,
      },
    }),
  ],
})
export default class ExampleApp {}
```

From the model’s perspective, `list_tools` now shows:

- `codecall.search`
- `codecall.describe`
- `codecall.execute`
- (optionally) `codecall.invoke`
- plus any tools with `codecall.visibleInListTools: true`.

Everything else is reachable only via CodeCall.

---

## Modes

CodeCall offers three **modes** that control which tools are:

- Visible in `list_tools`.
- Usable via `codecall.search/describe/execute`.

### `mode: 'codecall_only'` (default)

**Best when:**

- You have **many tools**.
- You want to expose **all of them** via CodeCall.
- You **don’t** want to list them all.

**Behavior:**

- Hide all tools from `list_tools` by default.
- Include all tools in CodeCall search/execute by default.
- Per-tool metadata can:

  - Keep a tool visible in `list_tools`.
  - Disable a tool from CodeCall if needed.

---

### `mode: 'codecall_opt_in'`

**Best when:**

- You have a large toolbox, but only a **subset** should be usable via CodeCall.
- You don’t want every tool to be part of the “code surface”.

**Behavior:**

- Hide all tools from `list_tools` by default.
- Only tools with `codecall.enabledInCodeCall: true` are available via CodeCall.
- `codecall.visibleInListTools` controls whether a tool appears in `list_tools`.

---

### `mode: 'metadata_driven'`

**Best when:**

- You have **up to ~10 tools**.
- You want to use **both** classic tool calls and CodeCall on the same tools.
- You’re happy to configure everything per-tool.

**Behavior:**

- CodeCall doesn’t assume anything by default.
- Only tools with:

  - `codecall.enabledInCodeCall: true` are used by CodeCall.
  - `codecall.visibleInListTools: true` appear in `list_tools`.

---

## Tool metadata

CodeCall adds a `codecall` section to `@Tool` options:

```ts
@Tool({
  name: 'users:list',
  description: 'List users with pagination',
  codecall: {
    enabledInCodeCall: true, // usable from codecall.execute
    visibleInListTools: false, // hidden from classic list_tools
  },
})
class ListUsersTool {
  // ...
}
```

Fields:

- `codecall.visibleInListTools?: boolean`

  - `true` → keep visible in `list_tools`.
  - `false` / omitted → plugin may hide it depending on `mode`.

- `codecall.enabledInCodeCall?: boolean`

  - Controls whether the tool is indexed and callable from CodeCall.
  - Defaults depend on `mode`:

  - `codecall_only`: default **true**
  - `codecall_opt_in`: default **false**
  - `metadata_driven`: default **false**

---

## Multi-app search

If your FrontMCP server has **multiple apps** (e.g. `user` app and `billing` app), CodeCall supports app-aware search:

- `codecall.search` accepts an optional `filter` object with `appIds`.
- The model can:

  - Search tools in just the `user` app.
  - Just the `billing` app.
  - Or across both.

Conceptually:

```jsonc
// Search only in "user" app
{
  "tool": "codecall.search",
  "input": {
    "query": "get current user profile",
    "filter": { "appIds": ["user"] }
  }
}

// Search across "user" AND "billing" apps
{
  "tool": "codecall.search",
  "input": {
    "query": "show unpaid invoices for the current user",
    "filter": { "appIds": ["user", "billing"] }
  }
}
```

The LLM can decide per task whether it needs data from a single app or to join data across apps.

---

## VM security presets

CodeCall runs code in a `vm2` sandbox with **CSP-style presets**.

```ts
vm: {
  preset?: 'locked_down' | 'secure' | 'balanced' | 'experimental';
  timeoutMs?: number;
  allowLoops?: boolean;
  disabledBuiltins?: string[];
  disabledGlobals?: string[];
  allowConsole?: boolean;
}
```

Suggested usage:

- `locked_down` – strictest; highly sensitive environments.
- `secure` – **default**; safe for untrusted LLM code.
- `balanced` – more permissive; internal/trusted models.
- `experimental` – dev-only; very relaxed, not for production.

You can override any fields on top of the preset.

---

## Meta-tools

CodeCall exposes **three primary** tools + **one optional**:

1. `codecall.search`
2. `codecall.describe`
3. `codecall.execute`
4. `codecall.invoke` (optional, no code/VM)

### `codecall.search`

Find relevant tools by natural language.

**Input (conceptual):**

```json
{
  "query": "get all users who logged in today",
  "topK": 8,
  "filter": {
    "appIds": ["user"],
    "tags": ["users", "sessions"]
  }
}
```

**Output:**

```jsonc
{
  "tools": [
    {
      "name": "users:list",
      "description": "List users with pagination",
      "appId": "user",
      "source": "inline",
      "score": 0.92
    }
  ]
}
```

Usage pattern:

1. Call `codecall.search` with your high-level goal.
2. Optionally scope by `appIds` if you want specific apps.
3. Pick tool names from the results.
4. Call `codecall.describe` on those tools.

---

### `codecall.describe`

Get input/output schemas for selected tools.

**Input:**

```json
{
  "tools": ["users:list", "billing:listInvoices"],
  "max": 8
}
```

**Output (simplified):**

```jsonc
{
  "tools": [
    {
      "name": "users:list",
      "description": "List users with pagination",
      "inputSchema": {
        /* JSON schema-like */
      },
      "outputSchema": {
        /* optional JSON schema-like */
      },
      "examples": [
        {
          "input": { "limit": 10 },
          "output": {
            "items": [
              /* ... */
            ]
          }
        }
      ]
    }
  ]
}
```

The model uses these schemas to build a valid JS plan for `codecall.execute`.

---

### `codecall.execute`

Run a **JavaScript execution plan** that calls tools from inside a sandbox.

**Input (conceptual):**

```json
{
  "script": "/* JavaScript code */",
  "allowedTools": ["users:list", "billing:listInvoices"],
  "context": {
    "tenantId": "t-123",
    "userId": "u-456"
  }
}
```

Inside the VM, the script has access to:

```js
await callTool('users:list', { limit: 100 });
const meta = getTool('users:list'); // name, description, schemas

codecallContext.tenantId; // read-only context

console.log('debug info'); // if allowConsole === true

mcpLog('info', 'Loaded users', { count: 100 });
mcpNotify('step_started', { step: 'load_users' });
```

> `console`, `mcpLog`, and `mcpNotify` are available only if enabled in config.

**Output (high level):**

CodeCall normalizes results into a shape with `status`:

- `ok` – script returned successfully.
- `syntax_error` – JS parse error.
- `illegal_access` – attempted to use a blocked builtin/global.
- `runtime_error` – bug in the JS plan (script-level error).
- `tool_error` – error thrown by a specific tool call (tool-level error).
- `timeout` – script exceeded the configured time.

This allows the LLM and the orchestrator to distinguish:

- “My code is wrong” vs
- “This specific tool call failed with input X”.

---

### `codecall.invoke` (direct call, no code)

For simple cases, you might want the model to call a tool **without** writing a
JavaScript plan and spinning up the VM.

When `directCalls.enabled === true`, CodeCall exposes an extra meta-tool:

- e.g. `codecall.invoke`

**Input (conceptual):**

```json
{
  "tool": "users:getById",
  "input": { "id": "123" }
}
```

**Behavior:**

- No VM is created.
- No user-written JS is executed.
- The call behaves just like a normal MCP tool call:

  - PII plugin still runs.
  - Auth, rate limiting, logging, etc. still run.

- On success: you get back the tool result.
- On error:

  - If the tool doesn’t exist or isn’t allowed, you get a clear “tool not found / not allowed” error.
  - If the tool throws, the error includes:

  - the tool name
  - the input that was used
  - optional error code/details

This is ideal when:

- The model just needs a **single tool action**.
- There’s no need for multi-step orchestration or cross-tool joins.
- You still want all the benefits of CodeCall’s tooling (modes, PII plugins, etc.)
  without paying the VM cost for simple cases.

---

## Logging & notifications from plans

CodeCall supports two types of visibility into what a plan is doing:

1. **Automatic notifications** for tool calls:

- Every `callTool()` can emit:

- A “tool call started” event (with tool name + input).
- A “tool call finished” event (with tool name + input + status).
- These can be surfaced by your transport as live updates (e.g. SSE).

2. **Script-driven logging/notifications**:

- CodeCall can expose FrontMCP builtin logging/notification methods into the VM.
- This lets the LLM decide **what** to notify about and **with which parameters**.

Example inside a plan:

```js
async function main() {
  mcpNotify('step_started', { step: 'sync_billing' });

  const invoices = await callTool('billing:listInvoices', { status: 'unpaid' });

  mcpLog('info', 'Loaded unpaid invoices', { count: invoices.items.length });

  mcpNotify('step_completed', {
    step: 'sync_billing',
    count: invoices.items.length,
  });

  return invoices.items;
}

return main();
```

If you don’t want models to emit custom notifications, you can disable these globals in the plugin configuration.

---

## PII & privacy

CodeCall runs **on top of** your existing FrontMCP tool pipeline – it does _not_ bypass it.

When a plan calls `callTool('some:tool', input)` inside `codecall.execute`:

- The request still goes through:

  - Any PII plugins (scrubbing/masking input and output).
  - Auth plugins.
  - Logging / audit.
  - Rate limiting.

- The response that CodeCall sees is exactly what a normal tool call would see
  after those plugins have run.

This means:

- CodeCall cannot leak more data than a normal tool call.
- PII redaction logic remains in your **PII plugin**, not inside CodeCall.
- The results you get from a CodeCall plan are equivalent (in terms of privacy)
  to calling the same tools one-by-one outside of CodeCall.

---

## Tool discovery, caching & notifications

CodeCall works with both **stateful** and **stateless** clients.

### With tool list change notifications

If your transport supports:

- A **transport session ID**, and
- **Tool list change notifications**,

then the recommended pattern is:

1. The client calls `codecall.search` and `codecall.describe` for a given session.
2. It caches tool definitions (names + schemas) in memory, keyed by session.
3. When tools relevant to that session change (added/updated/removed), the server sends a **“tool list changed”** notification.
4. The client refreshes only when notified, instead of re-describing tools on every round-trip.

### Without notifications

If the transport does **not** support notifications:

- The simplest pattern is:

> Before using a tool inside `codecall.execute`, call `codecall.describe` for that tool in the same turn.

- Treat search/describe as ephemeral and re-run them as needed to avoid stale schemas.

---

## Permissions & OAuth (future integration)

Some tools may:

- Be **listed and discoverable** to the user.
- But require **additional permissions or a separate OAuth flow** before they can be executed.

In these cases:

- The tool itself should return a structured “authorization required” result (e.g. including:

  - A URL to start an OAuth flow.
  - A reason / scope description.
  - The tool name.

- CodeCall does **not** handle OAuth directly — it simply returns what the tool returned.
- A dedicated **authorization/permissions plugin** can be added later to:

  - Detect this pattern in tool responses.
  - Coordinate running the OAuth flow.
  - Retry execution after permissions are granted.

This keeps a clear separation:

- CodeCall: code orchestration + sandboxing.
- Auth plugin: identity/permissions orchestration.

---

## Example: query-like behavior in code

Even if your REST API doesn’t support this query directly, CodeCall can:

> “Return all user IDs whose first name starts with `me` and logged in today.”

```js
// Example script for `codecall.execute`

async function main() {
  // 1. Get users from a coarse API
  const page = await callTool('users:list', { limit: 500 });

  // 2. Filter in JS
  const today = new Date().toISOString().slice(0, 10);

  const matching = page.items.filter((user) => {
    const firstName = (user.firstName || '').toLowerCase();
    const lastLogin = (user.lastLogin || '').slice(0, 10);
    return firstName.startsWith('me') && lastLogin === today;
  });

  // 3. Return just IDs
  return matching.map((u) => u.id);
}

return main();
```

The LLM can generate this plan after:

1. `codecall.search` → finds `users:list` (maybe from the `user` app).
2. `codecall.describe` → reads its schema.
3. `codecall.execute` → runs the plan.

---

## Summary

- Use **CodeCall** when you want to:

  - Hide large toolsets.
  - Expose a small, code-first meta-API.
  - Let the LLM orchestrate tools across one or more apps in JavaScript.

- Choose a **mode** based on your tool count and control preferences:

  - `codecall_only` – many tools, expose all via CodeCall.
  - `codecall_opt_in` – many tools, only some via CodeCall.
  - `metadata_driven` – few tools, mix classic tool calls + CodeCall.

- Use **VM presets** to balance power and safety.
- Use **direct calls (`codecall.invoke`)** for simple, single-tool actions without running a VM.
- Rely on your existing **PII and lifecycle plugins** for privacy and policy enforcement — CodeCall reuses the same pipeline.
- If your transport supports **tool list change notifications**, cache described tools per session and refresh on change; if not, re-describe before execution.

This gives you a scalable, safe, and flexible way to expose your entire tool universe to LLMs without overwhelming them.
