---
title: CodeCall Plugin
description: Hide large toolsets behind a small, code-first meta-API with bank-grade security.
icon: code
---

CodeCall lets LLMs orchestrate **hundreds of tools** through a code-first interface while maintaining strict security boundaries. Instead of flooding the context window with tool definitions, the model discovers, describes, and executes tools through a sandboxed JavaScript environment.

<CardGroup cols={2}>
  <Card title="Scalable Discovery" icon="magnifying-glass">
    Search across hundreds of tools using natural language
  </Card>
  <Card title="Code Orchestration" icon="code">
    LLMs write JavaScript to combine tools, filter data, and build workflows
  </Card>
  <Card title="Bank-Grade Security" icon="shield-check">
    Sandboxed execution with AST validation, resource limits, and audit logging
  </Card>
  <Card title="Direct Invocation" icon="bolt">
    Optionally bypass the VM for simple single-tool calls
  </Card>
</CardGroup>

---

## Quick Start

```bash
npm install @frontmcp/plugins
```

```ts
import { App, Tool, ToolContext } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';

@Tool({
  name: 'users:list',
  description: 'List all users with pagination',
  codecall: {
    enabledInCodeCall: true,
    visibleInListTools: false, // Hidden from direct list, accessible via CodeCall
  },
})
class ListUsersTool extends ToolContext {
  async execute(input: { limit?: number }) {
    return { users: [/* ... */] };
  }
}

@App({
  id: 'example',
  plugins: [
    CodeCallPlugin.init({
      mode: 'codecall_only',
      security: {
        level: 'SECURE', // Bank-grade security preset
      },
    }),
  ],
  tools: [ListUsersTool],
})
export default class ExampleApp {}
```

The model now sees only four meta-tools:
- `codecall:search` - Find relevant tools
- `codecall:describe` - Get detailed schemas
- `codecall:execute` - Run JavaScript orchestration plans
- `codecall:invoke` - Direct tool calls (optional)

---

## Security Model

CodeCall implements defense-in-depth with multiple security layers:

### Security Levels

Choose a preset that matches your threat model:

| Level | Timeout | Max Iterations | Tool Calls | Use Case |
|-------|---------|----------------|------------|----------|
| **STRICT** | 1s | 100 | 5 | Ultra-sensitive environments |
| **SECURE** | 3s | 1,000 | 20 | Production default |
| **STANDARD** | 5s | 10,000 | 50 | Internal/trusted models |
| **PERMISSIVE** | 30s | 100,000 | 200 | Development only |

```ts
CodeCallPlugin.init({
  security: {
    level: 'SECURE', // or 'STRICT', 'STANDARD', 'PERMISSIVE'
    // Override specific limits:
    timeout: 5000, // Override timeout
    maxToolCalls: 30, // Override tool call limit
  },
});
```

### Self-Reference Blocking

**Critical Security Feature**: Scripts cannot call CodeCall meta-tools from within scripts.

```js
// This is BLOCKED - returns error instead of executing
const result = await callTool('codecall:execute', { script: '...' });
// Result: { success: false, error: { code: 'SELF_REFERENCE_BLOCKED' } }
```

This prevents:
- Recursive script execution (infinite loops)
- Sandbox escape attempts
- Privilege escalation attacks

### AST Validation

Every script is parsed and validated before execution:

<AccordionGroup>
  <Accordion title="Blocked Constructs">
    - `eval()` and `Function()` constructor
    - `with` statements
    - Direct property access on dangerous objects
    - `__proto__`, `constructor`, `prototype` access
    - Async generators (resource exhaustion)
    - Import/export (module system bypass)
  </Accordion>

  <Accordion title="Allowed Safe Globals">
    - `callTool(name, args)` - Make tool calls
    - `parallel(fns, options)` - Concurrent execution
    - `Math`, `JSON`, `Array`, `Object`, `String`, `Number`, `Date`
    - Custom globals you explicitly allow
  </Accordion>
</AccordionGroup>

### Result-Based Error Handling

**Security Design**: Tool calls return results instead of throwing exceptions:

```ts
// Inside sandbox, callTool returns:
type ToolResult<T> =
  | { success: true; data: T }
  | { success: false; error: { code: string; message: string } };

// Usage in script:
const result = await callTool('users:get', { id: '123' });
if (!result.success) {
  // Handle error - no exception escapes
  return { error: result.error.message };
}
return result.data;
```

This prevents:
- Information leakage through stack traces
- Internal system path exposure
- Exception-based control flow manipulation

### Resource Limits

<CardGroup cols={3}>
  <Card title="Timeout" icon="clock">
    Enforced execution time limit prevents infinite loops
  </Card>
  <Card title="Iterations" icon="repeat">
    Loop iteration counter prevents while(true) attacks
  </Card>
  <Card title="Tool Calls" icon="wrench">
    Maximum tool invocations per script execution
  </Card>
</CardGroup>

```ts
// All loops are instrumented:
for (let i = 0; i < 1000; i++) {
  // Each iteration increments counter
  // Throws when maxIterations exceeded
}
```

---

## Tool Visibility Modes

Control which tools appear in `list_tools` vs. CodeCall:

### `codecall_only` (Recommended)

Hide all tools from `list_tools`, expose via CodeCall:

```ts
CodeCallPlugin.init({ mode: 'codecall_only' });
```

- **list_tools**: Only CodeCall meta-tools visible
- **CodeCall**: All tools searchable and callable
- **Override**: Set `visibleInListTools: true` per tool

### `codecall_opt_in`

Tools must explicitly opt into CodeCall:

```ts
CodeCallPlugin.init({ mode: 'codecall_opt_in' });

@Tool({
  codecall: {
    enabledInCodeCall: true, // Required for CodeCall access
    visibleInListTools: true, // Also visible normally
  },
})
```

### `metadata_driven`

Full control per tool:

```ts
CodeCallPlugin.init({ mode: 'metadata_driven' });

@Tool({
  codecall: {
    enabledInCodeCall: true,  // Available in scripts
    visibleInListTools: false, // Hidden from list_tools
  },
})
```

---

## Meta-Tools Reference

### codecall:search

Find tools by natural language query:

```json
{
  "tool": "codecall:search",
  "input": {
    "query": "get user profile information",
    "topK": 5,
    "filter": {
      "appIds": ["user-service"]
    }
  }
}
```

**Response:**
```json
{
  "tools": [
    {
      "name": "users:getProfile",
      "description": "Get user profile by ID",
      "score": 0.94,
      "appId": "user-service"
    }
  ]
}
```

### codecall:describe

Get detailed schemas for selected tools:

```json
{
  "tool": "codecall:describe",
  "input": {
    "tools": ["users:getProfile", "users:updateProfile"],
    "options": {
      "includeExamples": true,
      "verbosity": "full"
    }
  }
}
```

**Response includes:**
- Full JSON Schema for inputs/outputs
- Description and usage notes
- Example inputs/outputs
- Type information with constraints

### codecall:execute

Run a JavaScript orchestration script:

```json
{
  "tool": "codecall:execute",
  "input": {
    "script": "const users = await callTool('users:list', { limit: 100 });\nreturn users.data.filter(u => u.active);",
    "context": {
      "tenantId": "t-123"
    }
  }
}
```

**Response:**
```json
{
  "status": "success",
  "result": [/* filtered users */],
  "stats": {
    "duration": 234,
    "toolCallCount": 1,
    "iterationCount": 100
  }
}
```

**Error Response:**
```json
{
  "status": "error",
  "error": {
    "code": "TOOL_ERROR",
    "message": "Tool 'users:list' failed: Rate limit exceeded",
    "category": "tool_error",
    "suggestion": "The tool call failed. Check the input parameters and try again."
  }
}
```

### codecall:invoke

Direct tool invocation without JavaScript:

```json
{
  "tool": "codecall:invoke",
  "input": {
    "tool": "users:getById",
    "input": { "id": "user-123" }
  }
}
```

**Benefits:**
- No VM overhead for simple calls
- Still enforces access control
- Maintains audit logging
- Applies output sanitization

---

## AgentScript API

Inside `codecall:execute`, scripts have access to:

### callTool(name, args)

```js
// Returns result object, never throws
const result = await callTool('users:get', { id: '123' });

if (result.success) {
  console.log(result.data);
} else {
  console.log(result.error.message);
}
```

### parallel(functions, options)

Execute multiple operations concurrently:

```js
// Fetch multiple users in parallel
const results = await parallel([
  () => callTool('users:get', { id: '1' }),
  () => callTool('users:get', { id: '2' }),
  () => callTool('users:get', { id: '3' }),
], { maxConcurrency: 10 });

// Results are in order
const [user1, user2, user3] = results;
```

**Limits:**
- Maximum 100 parallel operations
- Maximum 20 concurrent executions
- Shares tool call limit with sequential calls

### Available Globals

```js
// Safe built-ins
Math.round(3.7);
JSON.parse('{"a":1}');
new Date().toISOString();
[1,2,3].filter(x => x > 1);
Object.keys({ a: 1, b: 2 });

// Context (read-only)
codecallContext.tenantId;
codecallContext.userId;
```

---

## Audit Logging

CodeCall emits detailed audit events for security monitoring:

```ts
import { AuditLoggerService, AUDIT_EVENT_TYPES } from '@frontmcp/plugins/codecall';

// Subscribe to audit events
const auditLogger = scope.get(AuditLoggerService);

auditLogger.subscribe((event) => {
  switch (event.type) {
    case AUDIT_EVENT_TYPES.EXECUTION_START:
      console.log(`Script started: ${event.executionId}`);
      break;
    case AUDIT_EVENT_TYPES.SECURITY_SELF_REFERENCE:
      console.warn(`Self-reference blocked: ${event.toolName}`);
      break;
    case AUDIT_EVENT_TYPES.TOOL_CALL:
      console.log(`Tool called: ${event.toolName}`);
      break;
  }
});
```

**Event Types:**
- `execution:start` / `execution:success` / `execution:failure`
- `security:self-reference` - Blocked recursive call
- `security:validation-failure` - AST validation failed
- `tool:call` / `tool:error` - Individual tool calls
- `resource:limit-exceeded` - Hit iteration/timeout/call limits

---

## Error Enrichment

Errors are categorized with actionable suggestions:

| Category | Example | Suggestion |
|----------|---------|------------|
| `syntax` | Unexpected token | Check JavaScript syntax at line X |
| `security` | eval is not allowed | Remove prohibited construct |
| `timeout` | Execution exceeded 3s | Simplify logic or increase timeout |
| `tool_not_found` | Unknown tool 'foo' | Use codecall:search to find tools |
| `tool_error` | Tool threw error | Check tool input parameters |
| `runtime` | Cannot read property | Debug the script logic |

---

## Output Sanitization

All outputs are sanitized before being returned:

```ts
// Configuration
CodeCallPlugin.init({
  sanitization: {
    maxDepth: 10,
    maxStringLength: 10000,
    maxArrayLength: 1000,
    maxObjectKeys: 100,
    removeStackTraces: true,
    removeFilePaths: true,
  },
});
```

**Sanitization includes:**
- Circular reference detection → `[circular]`
- Prototype pollution prevention → removes `__proto__`, `constructor`
- Large output truncation with warnings
- Stack trace removal (configurable)
- File path scrubbing (configurable)

---

## Configuration Reference

```ts
CodeCallPlugin.init({
  // Tool visibility mode
  mode: 'codecall_only' | 'codecall_opt_in' | 'metadata_driven',

  // Security configuration
  security: {
    level: 'STRICT' | 'SECURE' | 'STANDARD' | 'PERMISSIVE',
    timeout?: number,        // Override timeout (ms)
    maxIterations?: number,  // Override max loop iterations
    maxToolCalls?: number,   // Override max tool invocations
  },

  // Search configuration
  search: {
    topK: 8,                 // Default results per search
    similarityThreshold: 0.5, // Minimum relevance score
  },

  // Describe configuration
  describe: {
    maxTools: 10,            // Max tools per describe call
    includeExamples: true,   // Include example inputs/outputs
  },

  // Direct invocation
  directInvoke: {
    enabled: true,           // Enable codecall:invoke
    allowedTools?: string[], // Whitelist (optional)
  },

  // Output sanitization
  sanitization: {
    maxDepth: 10,
    maxStringLength: 10000,
    removeStackTraces: true,
    removeFilePaths: true,
  },

  // Custom globals for scripts
  globals: {
    MY_CONSTANT: 'value',
    config: { key: 'value' },
  },
});
```

---

## Best Practices

<AccordionGroup>
  <Accordion title="1. Use SECURE Level in Production">
    The `SECURE` preset provides the right balance of functionality and safety:
    ```ts
    CodeCallPlugin.init({
      security: { level: 'SECURE' },
    });
    ```
  </Accordion>

  <Accordion title="2. Prefer codecall_only Mode">
    For large tool sets, hide tools from `list_tools` to reduce context usage:
    ```ts
    CodeCallPlugin.init({
      mode: 'codecall_only',
    });
    ```
  </Accordion>

  <Accordion title="3. Monitor Audit Events">
    Set up alerting for security events:
    ```ts
    auditLogger.subscribe((event) => {
      if (event.type.startsWith('security:')) {
        alertSecurityTeam(event);
      }
    });
    ```
  </Accordion>

  <Accordion title="4. Use Direct Invoke for Simple Calls">
    Avoid VM overhead for single-tool operations:
    ```json
    { "tool": "codecall:invoke", "input": { "tool": "users:get", "input": { "id": "123" } } }
    ```
  </Accordion>

  <Accordion title="5. Include Scoping in Tool Inputs">
    Always include tenant/user IDs in tool calls:
    ```js
    callTool('users:list', { tenantId: codecallContext.tenantId })
    ```
  </Accordion>
</AccordionGroup>

---

## Security Checklist

<Steps>
  <Step title="Choose Security Level">
    Use `SECURE` for production, `STRICT` for ultra-sensitive environments
  </Step>
  <Step title="Enable Audit Logging">
    Subscribe to audit events and monitor for security incidents
  </Step>
  <Step title="Configure Output Sanitization">
    Ensure stack traces and file paths are removed in production
  </Step>
  <Step title="Review Tool Access">
    Use appropriate mode and metadata to control tool visibility
  </Step>
  <Step title="Test Security Boundaries">
    Verify self-reference blocking and resource limits work correctly
  </Step>
</Steps>

---

## Example: Multi-Tool Workflow

```js
// Script for codecall:execute
async function analyzeUserActivity() {
  // Search across multiple services in parallel
  const [users, orders, sessions] = await parallel([
    () => callTool('users:list', { status: 'active', limit: 100 }),
    () => callTool('orders:recent', { days: 7 }),
    () => callTool('sessions:active', {}),
  ]);

  if (!users.success || !orders.success || !sessions.success) {
    return { error: 'Failed to fetch data' };
  }

  // Join data in JavaScript
  const enrichedUsers = users.data.map(user => {
    const userOrders = orders.data.filter(o => o.userId === user.id);
    const userSession = sessions.data.find(s => s.userId === user.id);

    return {
      ...user,
      recentOrders: userOrders.length,
      isOnline: !!userSession,
      lastActivity: userSession?.lastActivity || user.lastLogin,
    };
  });

  // Filter and sort
  return enrichedUsers
    .filter(u => u.recentOrders > 0)
    .sort((a, b) => b.recentOrders - a.recentOrders)
    .slice(0, 10);
}

return analyzeUserActivity();
```

---

## Links & Resources

<CardGroup cols={2}>
  <Card title="Source Code" icon="github" href="https://github.com/agentfront/frontmcp/tree/main/libs/plugins/src/codecall">
    View the CodeCall plugin source
  </Card>
  <Card title="Enclave Library" icon="shield" href="https://github.com/agentfront/frontmcp/tree/main/libs/enclave">
    Sandbox execution engine
  </Card>
  <Card title="AST Guard" icon="lock" href="https://github.com/agentfront/frontmcp/tree/main/libs/ast-guard">
    JavaScript AST validation
  </Card>
  <Card title="Plugin Guide" icon="puzzle-piece" href="/docs/servers/extensibility/plugins">
    Learn about FrontMCP plugins
  </Card>
</CardGroup>
