---
title: Logging Transports
slug: servers/extensibility/logging
icon: receipt
--------------

FrontMCP logging is **extensible**. In addition to the default console logger, you can register one or more **custom transports** via the server config:

```ts
@FrontMcp({
  info: { name: 'Demo', version: '0.1.0' },
  apps: [App],
  logging: {
    level: LogLevel.Info,
    enableConsole: true,             // set false to disable the built‑in console transport
    transports: [StructuredJsonTransport, HttpBatchTransport],
  },
})
export default class Server {}
```

## Transport contract

A transport is a class decorated with `@LogTransport({...})` that implements `LogTransportInterface`.

```ts
export interface LogRecord {
  level: LogLevel;
  levelName: string;
  message: string;
  args: unknown[];
  timestamp: Date;
  prefix: string;
}

export type LogFn = (msg?: any, ...args: any[]) => void;

export abstract class LogTransportInterface {
  abstract log(rec: LogRecord): void
}
```

The framework filters by the configured `logging.level` **before** calling transports.

<Warning>
    Transports should never throw. Handle errors internally and keep I/O non‑blocking (use buffering/batching for remote
    sinks).
</Warning>

---

## Built‑in: Console

The default console transport formats messages with ANSI (when TTY) and falls back to plain text otherwise.

```ts
@LogTransport({ name: 'ConsoleLogger', description: 'Default console logger' })
export class ConsoleLogTransportInstance extends LogTransportInterface {
  log(rec: LogRecord): void {
    const fn = this.bind(rec.level, rec.prefix);
    fn(String(rec.message), ...rec.args);
  }
  // ...see source for details
}
```

Disable it by setting `enableConsole: false` in your server config.

---

## Example 1 — Structured JSON (JSONL)

Emit **machine‑readable** logs (one JSON per line). Useful for file shipping agents or centralized logging.

```ts
import { LogTransport, LogTransportInterface, LogRecord } from '@frontmcp/common';

@LogTransport({
  name: 'StructuredJsonTransport',
  description: 'Writes JSONL log records to stdout',
})
export class StructuredJsonTransport extends LogTransportInterface {
  log(rec: LogRecord): void {
    try {
      const payload = {
        ts: rec.timestamp.toISOString(),
        level: rec.levelName,           // e.g. INFO
        levelValue: rec.level,          // numeric
        prefix: rec.prefix || undefined,
        msg: stringify(rec.message),
        args: rec.args?.map(stringify),
      };
      // Avoid console formatting; write raw line
      process.stdout.write(JSON.stringify(payload) + '\n');
    } catch (err) {
      // Never throw from a transport
    }
  }
}

function stringify(x: unknown) {
  if (x instanceof Error) {
    return { name: x.name, message: x.message, stack: x.stack };
  }
  try { return typeof x === 'string' ? x : JSON.parse(JSON.stringify(x)); }
  catch { return String(x); }
}
```

**Register** it:

```ts
logging: { level: LogLevel.Info, enableConsole: false, transports: [StructuredJsonTransport] }
```

---

## Example 2 — HTTP batch transport (non‑blocking)

Buffer records in memory and POST them in batches. Implements basic retry with backoff.

```ts
import { LogTransport, LogTransportInterface, LogRecord } from '@frontmcp/common';

@LogTransport({ name: 'HttpBatchTransport', description: 'POST logs in batches' })
export class HttpBatchTransport extends LogTransportInterface {
  private queue: any[] = [];
  private timer: NodeJS.Timeout | null = null;
  private flushing = false;
  private readonly maxBatch = 50;
  private readonly flushMs = 1000;

  constructor(private endpoint = process.env.LOG_ENDPOINT || 'https://logs.example.com/ingest') { super(); }

  log(rec: LogRecord): void {
    this.queue.push({
      ts: rec.timestamp.toISOString(),
      lvl: rec.levelName,
      pfx: rec.prefix || undefined,
      msg: String(rec.message),
      args: safeArgs(rec.args),
    });
    if (this.queue.length >= this.maxBatch) this.flush();
    else if (!this.timer) this.timer = setTimeout(() => this.flush(), this.flushMs);
  }

  private async flush() {
    if (this.flushing) return;
    this.flushing = true;
    if (this.timer) { clearTimeout(this.timer); this.timer = null; }

    const batch = this.queue.splice(0, this.maxBatch);
    if (!batch.length) { this.flushing = false; return; }

    try {
      await postJson(this.endpoint, batch);
    } catch {
      // simple backoff and requeue
      this.queue.unshift(...batch);
      setTimeout(() => this.flush(), 1500);
    } finally {
      this.flushing = false;
    }
  }
}

function safeArgs(a: unknown[]) {
  return (a || []).map((x) => (x instanceof Error ? { name: x.name, message: x.message, stack: x.stack } : x));
}

async function postJson(url: string, body: unknown) {
  const res = await fetch(url, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(body) });
  if (!res.ok) throw new Error(`log sink ${res.status}`);
}
```

**Notes**

* Keep batches small and time‑bounded; avoid blocking the event loop.
* On process exit, you may add a `beforeExit`/`SIGTERM` handler to flush synchronously.

---

## Prefixes & levels

* `logging.prefix` adds a static scope tag to all records (e.g., app name or environment).
* Transports receive `rec.level` and `rec.levelName`; the framework already filtered below‑level logs.

```ts
logging: {
  level: LogLevel.Warn,
  prefix: 'billing‑edge',
  transports: [StructuredJsonTransport]
}
```

---

## Testing your transport

1. Start your server with your transport registered.
2. Trigger some logs (e.g., tool execution, startup).
3. Verify output or remote ingestion.

For local JSONL, tail your logs:

```bash
node app.js | jq -c .
```

---

## Best practices

* **Never throw** from `log()`; swallow and self‑heal.
* **Avoid heavy sync I/O**; prefer buffering and async flush.
* **Redact** sensitive fields before emit (tokens, PII).
* **Serialize** `Error` objects explicitly (name, message, stack).
* **Backpressure**: if the sink is down, drop or sample rather than blocking the server.
