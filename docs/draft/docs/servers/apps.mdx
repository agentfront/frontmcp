---
title: Apps
slug: servers/apps
icon: cube
---

Apps are how you **group capabilities** in FrontMCP. Each app can contribute **tools**, **resources**, **prompts**, plus **providers**, **adapters**, and **plugins**. Apps may run _locally_ (in this process) or be _remote_ (URL/worker).

## Minimal local app

```ts
import { App } from '@frontmcp/sdk';

@App({
  id: 'hello',
  name: 'Hello App',
  tools: [],
})
export default class HelloApp {}
```

Add it to your server:

```ts
@FrontMcp({ info: { name: 'Demo', version: '0.1.0' }, apps: [HelloApp] })
export default class Server {}
```

---

## Local app options

```ts
@App({
  id?: string,
  name: string,
  description?: string,
  providers?: ProviderType[],
  authProviders?: AuthProviderType[],
  plugins?: PluginType[],
  adapters?: AdapterType[],
  tools?: ToolType[],
  resources?: ResourceType[],
  prompts?: PromptType[],
  auth?: AuthOptions,                 // app‑default auth (overrides server auth)
  standalone?: 'includeInParent' | boolean, // isolate scope / expose separately
})
```

**Scoping & auth**

- If the server uses **`splitByApp: true`**, each app is isolated and **must** configure its own auth (server-level `auth` is disallowed).
- `standalone: true` makes the app expose its own scope/entry; `'includeInParent'` lists it under the parent while keeping isolation.

**Dependency resolution**

- Providers resolve **tool → app → server**.
- Plugins/adapters attach at app scope; generated items inherit the app’s policies and provenance.

---

## Remote apps

Define an app that proxies to a **worker file** or a **URL**:

```ts
@App({
  name: 'Remote CRM',
  urlType: 'url', // 'url' | 'worker'
  url: 'https://crm.example.com/mcp',
  auth: { type: 'remote', name: 'crm-idp', baseUrl: 'https://idp.example.com' },
  standalone: true,
})
export default class CrmApp {}
```

**Fields**

```ts
{
  id?: string;
  name: string;
  description?: string;
  urlType: 'worker' | 'url';
  url: string;
  auth?: AuthOptions;
  standalone?: 'includeInParent' | boolean;
}
```

---

## Example: app with adapter + providers

```ts
@App({
  id: 'billing',
  name: 'Billing',
  providers: [DbProvider, CacheProvider],
  adapters: [
    // e.g. OpenAPI adapter that generates tools/resources from a spec
    BillingOpenApiAdapter,
  ],
})
export default class BillingApp {}
```

---

## Example: CodeCall-enabled CRM app

Need to orchestrate dozens of tools without overwhelming `list_tools`? The demo CRM app wires CodeCallPlugin into a focused group of user and activity tools so models plan in JavaScript while you keep a single entry point.

```ts
import { App } from '@frontmcp/sdk';
import { CodeCallPlugin } from '@frontmcp/plugins';

import UsersListTool from './tools/users-list.tool';
import UsersGetTool from './tools/users-get.tool';
import UsersCreateTool from './tools/users-create.tool';
import UsersUpdateTool from './tools/users-update.tool';
import UsersDeleteTool from './tools/users-delete.tool';
import ActivitiesListTool from './tools/activities-list.tool';
import ActivitiesLogTool from './tools/activities-log.tool';
import ActivitiesStatsTool from './tools/activities-stats.tool';

@App({
  id: 'crm',
  name: 'CRM Demo with CodeCall',
  description: 'A demo CRM application showcasing CodeCall plugin for AgentScript-based tool orchestration',
  plugins: [
    CodeCallPlugin.init({
      topK: 10, // Return up to 10 tools in search results
      // Default mode is `codecall_only`, so individual tools stay hidden from list_tools
    }),
  ],
  tools: [
    UsersListTool,
    UsersGetTool,
    UsersCreateTool,
    UsersUpdateTool,
    UsersDeleteTool,
    ActivitiesListTool,
    ActivitiesLogTool,
    ActivitiesStatsTool,
  ],
})
export default class CrmMcpApp {}
```

Each tool talks to the in-memory `CrmStore` (`apps/demo/src/apps/crm/data/store.ts`) so the sample can list, create, update, delete users, and capture activities without a database. `ActivitiesLogTool` updates `lastLoginAt` on login events, while `ActivitiesStatsTool` surfaces per-user counts that you can feed back into CodeCall plans.

Key ideas demonstrated:

- Keep every CRUD tool available to CodeCall by setting `enabledInCodeCall: true` in each `@Tool` definition.
- Let CodeCall orchestrate multiple concerns (users + activities) while the app exposes only the CodeCall meta-tools to clients.

<Tip>
  Need to mix direct tool calls with CodeCall? Switch the plugin to `mode: 'metadata_driven'` or disable `enabledInCodeCall` per tool so you can decide which ones stay searchable only through the meta-API.
</Tip>
