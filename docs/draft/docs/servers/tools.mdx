---
title: Tools
slug: servers/tools
icon: wrench
---

Tools are **typed actions** your server can execute. They're described with Zod schemas and exposed via MCP. Implement as a class with `@Tool({...})` or as a function via `tool()`.

<Info>
This feature implements the [MCP Tools specification](https://modelcontextprotocol.io/specification/2025-11-25/server/tools). FrontMCP handles all protocol details automatically.
</Info>

## Minimal tool (class)

```ts
import { Tool } from '@frontmcp/sdk';
import { z } from 'zod';

@Tool({
  name: 'greet',
  description: 'Greets a user by name',
  inputSchema: { name: z.string() },
})
export default class GreetTool {
  async execute({ name }: { name: string }) {
    return `Hello, ${name}!`;
  }
}
```

Register it on an app:

```ts
@App({ id: 'hello', name: 'Hello', tools: [GreetTool] })
export default class HelloApp {}
```

## Inline tool (function builder)

```ts
import { tool } from '@frontmcp/sdk';
import { z } from 'zod';

export const Add = tool({
  name: 'add',
  description: 'Add two numbers',
  inputSchema: { a: z.number(), b: z.number() },
})((input) => input.a + input.b);
```

Add to app:

```ts
@App({ name: 'Calc', tools: [Add] })
class CalcApp {}
```

---

## Tool metadata

```ts
@Tool({
  id?: string,
  name: string,
  description?: string,
  inputSchema: ZodSchema,
  rawInputSchema?: JSONSchema7,
  outputSchema?: ZodSchema,
  tags?: string[],
  annotations?: {
    title?: string,
    readOnlyHint?: boolean,
    destructiveHint?: boolean,
    idempotentHint?: boolean,
    openWorldHint?: boolean,
  },
  hideFromDiscovery?: boolean, // default false
})
```

**Notes**

- `annotations` hint model & UI behavior (read-only, idempotent, etc.).
- `hideFromDiscovery` keeps a tool callable but off `tool/list`.
- Tools can attach **per-tool hooks** (see _Advanced â†’ Hooks_).

---

## Return values

- Return any serializable type; if you provide `outputSchema`, it will validate.
- Errors are surfaced via MCP error responses; you can also throw typed errors inside executors.

---

## MCP Protocol Integration

Tools integrate with the MCP protocol via two flows:

| Flow | Description |
|------|-------------|
| `tools/list` | Returns all available tools with their metadata and input schemas |
| `tools/call` | Executes a specific tool with provided arguments |

When a client requests `tools/call` with a name and arguments:
1. The SDK locates the tool by name
2. Arguments are validated against the tool's `inputSchema`
3. The `execute()` method is called with the validated arguments
4. The return value is validated against `outputSchema` (if provided) and converted to MCP format

### Capabilities

FrontMCP automatically advertises tool capabilities during MCP initialization:

```json
{
  "capabilities": {
    "tools": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

| Capability | Description |
|------------|-------------|
| `subscribe` | When `true`, clients can subscribe to tool list changes |
| `listChanged` | When `true`, the server will send `notifications/tools/list_changed` when tools are added or removed |

The SDK sets `listChanged: true` when you have any tools registered, enabling clients to receive real-time notifications when tools are dynamically added or removed (e.g., via adapters or plugins).

### Change Notifications

When tools change dynamically, FrontMCP automatically sends `notifications/tools/list_changed` to connected clients. Clients that support this notification will refresh their tool list.

<Tip>
For the full protocol specification, see [MCP Tools](https://modelcontextprotocol.io/specification/2025-11-25/server/tools).
</Tip>
