---
title: CodeCall Plugin
description: Hide large toolsets behind a code-first meta-API that lets models search, describe, and orchestrate tools using JavaScript execution plans.
icon: code
---

The CodeCall Plugin transforms how you expose large toolsets to models. Instead of listing hundreds of tools in `list_tools`, CodeCall provides a small meta-API that lets models discover tools dynamically, then orchestrate them using JavaScript execution plans running in a secure sandbox.

## Why Use CodeCall?

<CardGroup cols={2}>
  <Card title="Scale Beyond Context Limits" icon="arrows-maximize">
    Expose hundreds or thousands of tools without overwhelming the model's context window
  </Card>
  <Card title="Enable Complex Workflows" icon="diagram-project">
    Let models build multi-step workflows, joins, and filters that your API doesn't support directly
  </Card>

  <Card title="Multi-App Orchestration" icon="layer-group">
    Search and call tools across multiple apps in the same server with app-aware filtering
  </Card>

  <Card title="Safe Code Execution" icon="shield-check">
    Run model-generated JavaScript in Enclave with AST validation, transformation, and runtime sandboxing
  </Card>
</CardGroup>

## Installation

```bash
npm install @frontmcp/plugins
```

## How It Works

<Steps>
  <Step title="Search for Tools">
    Model calls `codecall.search` with natural language to discover relevant tools across apps
  </Step>
  <Step title="Describe Schemas">
    Model calls `codecall.describe` to get input/output schemas for selected tools
  </Step>

  <Step title="Generate Execution Plan">
    Model writes a JavaScript plan that orchestrates multiple tools, filters results, and builds custom logic
  </Step>

  <Step title="Execute in Sandbox">
    CodeCall runs the plan in Enclave - a secure sandbox using ast-guard validation and Node.js vm module - calling your real tools through the normal FrontMCP pipeline
  </Step>
</Steps>

<Info>
  CodeCall uses [Enclave](/docs/guides/enclave) - FrontMCP's defense-in-depth execution environment - which combines AST validation (ast-guard), code transformation, and runtime sandboxing for bank-grade security.
</Info>

---

## Quick Start

### Basic Setup

```ts
import { App, Tool, ToolContext } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';
import { z } from 'zod';

@Tool({
  name: 'users:list',
  description: 'List users with pagination',
  inputSchema: { limit: z.number().default(100) },
  codecall: {
    visibleInListTools: false, // Hidden from list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
class ListUsersTool extends ToolContext {
  async execute(input: { limit: number }) {
    return await this.database.getUsers(input.limit);
  }
}

@App({
  id: 'user',
  name: 'User App',
  tools: [ListUsersTool],
  plugins: [
    CodeCallPlugin.init({
      mode: 'codecall_only', // Recommended: many tools, all via CodeCall
      topK: 8, // Return top 8 search results
      maxDefinitions: 8, // Max tools to describe at once
      enclave: {
        timeoutMs: 5000,
        maxToolCalls: 100,
        maxIterations: 10000,
        allowConsole: true,
      },
    }),
  ],
})
export default class UserApp {}
```

From the model's perspective, `list_tools` now shows:

- `codecall.search` - Find tools by natural language
- `codecall.describe` - Get tool schemas
- `codecall.execute` - Run JavaScript execution plans
- (Optional) `codecall.invoke` - Direct tool calls without VM

All other tools are hidden from `list_tools` but discoverable via `codecall.search`.

---

## Configuration Options

### Plugin-Level Configuration

Configure CodeCall behavior when registering the plugin:

<ParamField path="mode" type="'codecall_only' | 'codecall_opt_in' | 'metadata_driven'" default="'codecall_only'">
  Controls which tools are visible in `list_tools` and usable via CodeCall:
  - **`codecall_only`** - Hide all tools by default, make all available via CodeCall (best for large toolsets)
  - **`codecall_opt_in`** - Hide all tools, only enable specific tools for CodeCall (best for selective exposure)
  - **`metadata_driven`** - No defaults, configure everything per-tool (best for small toolsets with mixed usage)
</ParamField>

<ParamField path="topK" type="number" default="8">
  Maximum number of tools to return from `codecall.search`
</ParamField>

<ParamField path="maxDefinitions" type="number" default="8">
  Maximum number of tools that can be described in a single `codecall.describe` call
</ParamField>

<ParamField path="directCalls" type="object">
  Configure direct tool invocation without VM execution

  <Expandable title="properties">
    <ResponseField name="enabled" type="boolean" default="false">
      Enable `codecall.invoke` for simple single-tool calls without running the VM
    </ResponseField>
    <ResponseField name="allowedTools" type="string[]">
      Optional allowlist of tool names. If omitted, all CodeCall-enabled tools are allowed
    </ResponseField>
  </Expandable>
</ParamField>

<ParamField path="enclave" type="object">
  Enclave sandbox configuration (defense-in-depth security with ast-guard + Node.js vm)

  <Expandable title="properties">
    <ResponseField name="timeoutMs" type="number" default="30000">
      Maximum execution time in milliseconds (30 seconds default)
    </ResponseField>
    <ResponseField name="maxToolCalls" type="number" default="100">
      Maximum number of tool calls allowed per execution
    </ResponseField>
    <ResponseField name="maxIterations" type="number" default="10000">
      Maximum loop iterations allowed (prevents infinite loops)
    </ResponseField>
    <ResponseField name="allowConsole" type="boolean" default="false">
      Enable console.log/warn/error in execution plans
    </ResponseField>
  </Expandable>
</ParamField>

<ParamField path="sidecar" type="object">
  Configuration for handling large data in AgentScript. The sidecar stores large tool responses separately and provides them via reference tokens.

  <Expandable title="properties">
    <ResponseField name="enabled" type="boolean" default="false">
      Enable the sidecar feature for large data handling
    </ResponseField>
    <ResponseField name="maxTotalSize" type="number" default="10485760">
      Maximum total size of all stored references in bytes (default 10MB)
    </ResponseField>
    <ResponseField name="maxReferenceSize" type="number" default="1048576">
      Maximum size of a single reference in bytes (default 1MB)
    </ResponseField>
    <ResponseField name="extractionThreshold" type="number" default="1024">
      Minimum string size in bytes to extract to sidecar. Smaller strings stay inline.
    </ResponseField>
    <ResponseField name="maxResolvedSize" type="number" default="5242880">
      Maximum size when resolving references in bytes (default 5MB)
    </ResponseField>
    <ResponseField name="allowComposites" type="boolean" default="false">
      Allow string concatenation with reference tokens. Set to `false` (default) for security - prevents attacks like `ref + "__proto__"`
    </ResponseField>
    <ResponseField name="maxScriptLengthWhenDisabled" type="number | null" default="65536">
      Maximum script length in bytes when sidecar is disabled. If exceeded, execution fails with `ScriptTooLargeError`. Set to `null` to disable this check.
    </ResponseField>
  </Expandable>
</ParamField>

<Note>
  Enclave automatically blocks dangerous constructs via AST validation:
  - `eval`, `Function`, `setTimeout`, `setInterval` are blocked
  - Global objects like `process`, `require`, `window`, `globalThis` are blocked
  - Loops are transformed to safe versions with iteration limits
  - All identifiers are validated against a whitelist
</Note>

### Tool-Level Configuration

Configure CodeCall behavior per tool in the `@Tool` or `tool()` metadata:

<CodeGroup>

```ts Hide from list_tools, enable for CodeCall
@Tool({
  name: 'users:list',
  description: 'List users with pagination',
  codecall: {
    visibleInListTools: false, // Hidden from list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
```

```ts Keep visible, also enable for CodeCall
@Tool({
  name: 'health:ping',
  description: 'Health check',
  codecall: {
    visibleInListTools: true, // Keep in list_tools
    enabledInCodeCall: true, // Also available via CodeCall
  },
})
```

```ts Disable from CodeCall
@Tool({
  name: 'admin:deleteUser',
  description: 'Delete user (admin only)',
  codecall: {
    visibleInListTools: true, // Keep in list_tools
    enabledInCodeCall: false, // NOT available via CodeCall
  },
})
```

</CodeGroup>

<ParamField path="codecall.visibleInListTools" type="boolean">
  Whether the tool appears in `list_tools`. Defaults depend on `mode`:
  - `codecall_only`: default `false`
  - `codecall_opt_in`: default `false`
  - `metadata_driven`: default `false` (must be explicit)
</ParamField>

<ParamField path="codecall.enabledInCodeCall" type="boolean">
  Whether the tool is searchable and callable via CodeCall. Defaults depend on `mode`:
  - `codecall_only`: default `true`
  - `codecall_opt_in`: default `false`
  - `metadata_driven`: default `false` (must be explicit)
</ParamField>

---

## Advanced Usage

### Multi-App Search

When your FrontMCP server has multiple apps (e.g., `user`, `billing`), models can scope searches by app:

```ts
// Search only in "user" app
await callTool('codecall.search', {
  query: 'get current user profile',
  filter: { appIds: ['user'] }
});

// Search across "user" AND "billing" apps
await callTool('codecall.search', {
  query: 'show unpaid invoices for current user',
  filter: { appIds: ['user', 'billing'] }
});
```

<Tip>
  Multi-app search lets models decide per-task whether they need data from a single app or to join data across apps.
</Tip>

### Direct Tool Calls (No VM)

For simple single-tool invocations, enable `codecall.invoke` to bypass VM overhead:

```ts
CodeCallPlugin.init({
  directCalls: {
    enabled: true,
    allowedTools: ['users:getById', 'billing:getInvoice'], // Optional allowlist
  },
});
```

The model can then call tools directly without writing JavaScript:

```json
{
  "tool": "codecall.invoke",
  "input": {
    "tool": "users:getById",
    "input": { "id": "u-123" }
  }
}
```

This is ideal when the model needs a single tool action without multi-step orchestration.

### Logging and Notifications

CodeCall supports visibility into execution plan progress:

#### Automatic Tool Call Events

Every `callTool()` inside a plan can emit:

- **"tool call started"** event (with tool name + input)
- **"tool call finished"** event (with tool name + result + status)

These can be surfaced by your transport as live updates (e.g., SSE).

#### Script-Driven Logging

Enable `allowConsole` to let models add custom logging:

```js
async function main() {
  console.log('Starting user sync...');

  const users = await callTool('users:list', { limit: 100 });
  console.log(`Loaded ${users.length} users`);

  return users;
}

return main();
```

For structured notifications:

```js
mcpNotify('step_started', { step: 'sync_billing' });
mcpLog('info', 'Loaded invoices', { count: invoices.length });
mcpNotify('step_completed', { step: 'sync_billing' });
```

<Warning>
  Disable `mcpLog` and `mcpNotify` if you don't want models to emit custom notifications in production.
</Warning>

### PII and Privacy

CodeCall runs **on top of** your existing FrontMCP pipeline. When a plan calls `callTool()`:

- The request still flows through:

  - PII plugins (scrubbing/masking)
  - Auth plugins
  - Rate limiting
  - Audit logging

- CodeCall sees the **same response** a normal tool call would see after plugins run

**This means:**

- CodeCall cannot leak more data than normal tool calls
- PII redaction logic stays in your PII plugin, not in CodeCall
- Privacy guarantees are consistent across all tool invocations

### Tool Discovery and Caching

#### With Tool List Change Notifications

If your transport supports sessions and notifications:

1. Client calls `codecall.search` and `codecall.describe` for a session
2. Cache tool definitions (names + schemas) in memory, keyed by session
3. When tools change, server sends **"tool list changed"** notification
4. Client refreshes only when notified

#### Without Notifications

If your transport doesn't support notifications:

- Call `codecall.describe` before using a tool in `codecall.execute`
- Treat search/describe as ephemeral and re-run as needed to avoid stale schemas

### OAuth and Permissions (Future)

Some tools may be discoverable but require additional authorization before execution. In these cases:

- The tool returns a structured "authorization required" response with:

  - OAuth URL to start the flow
  - Required scope/reason
  - Tool name

- CodeCall returns this response as-is (no special handling)
- A future **authorization plugin** can:
  - Detect this pattern
  - Coordinate the OAuth flow
  - Retry execution after permissions are granted

This keeps separation of concerns:

- **CodeCall:** Code orchestration + sandboxing
- **Auth plugin:** Identity/permissions orchestration

---

## Best Practices

<AccordionGroup>
  <Accordion title="1. Choose the Right Mode">
    - **`codecall_only`** - Best for large toolsets (50+ tools), especially OpenAPI-generated tools
    - **`codecall_opt_in`** - Best when only a subset of tools should be orchestratable
    - **`metadata_driven`** - Best for small toolsets (< 10 tools) with mixed usage patterns
  </Accordion>

  <Accordion title="2. Configure Enclave Appropriately">
    - **Production:** Use default settings - Enclave's defense-in-depth security is enabled by default
    - **Timeout:** Set `timeoutMs` based on expected execution time (default 30s)
    - **Iterations:** Set `maxIterations` for loop-heavy workloads (default 10K)
    - **Tool calls:** Set `maxToolCalls` to limit API calls per execution (default 100)
    - Enclave automatically blocks eval, Function, dangerous globals via ast-guard
  </Accordion>

  <Accordion title="3. Enable Direct Calls for Simple Cases">
    Enable `codecall.invoke` to bypass VM overhead for single-tool invocations:
    ```ts
    directCalls: {
      enabled: true,
      allowedTools: ['users:getById', 'health:ping'] // Optional allowlist
    }
    ```
    This reduces latency and resource usage when complex orchestration isn't needed.
  </Accordion>

  <Accordion title="4. Scope Tools by App">
    When using multi-app servers, encourage models to scope searches:
    ```ts
    // Good: scoped to specific app
    filter: { appIds: ['user'] }

    // Okay: cross-app when needed
    filter: { appIds: ['user', 'billing'] }

    // Avoid: no scoping (searches all apps)
    // Only use when truly needed
    ```

  </Accordion>

  <Accordion title="5. Set Appropriate Limits">
    Configure `topK` and `maxDefinitions` based on your use case:
    ```ts
    topK: 8, // Enough for most tasks, not too noisy
    maxDefinitions: 8, // Balance between context and capability
    ```
    Lower values reduce context usage but may limit complex workflows.
  </Accordion>
</AccordionGroup>

---

## AgentScript Language Reference

AgentScript is the restricted JavaScript subset that runs inside CodeCall's `codecall.execute`. It's designed for safe AI-generated orchestration code with predictable behavior and no escape vectors.

### Language Overview

<CardGroup cols={2}>
  <Card title="What You CAN Do" icon="check">
    - Call tools with `await callTool(name, args)`
    - Declare variables with `const` and `let`
    - Use conditionals (`if`/`else`, ternary `? :`)
    - Iterate with `for` and `for...of` loops
    - Use array methods (`.map()`, `.filter()`, `.reduce()`)
    - Work with `Math`, `JSON`, `Array`, `Object`, `String`, `Number`, `Date`
    - Return results from your script
  </Card>
  <Card title="What You CANNOT Do" icon="xmark">
    - Define named functions or use recursion
    - Use `eval()`, `Function()`, or dynamic code execution
    - Access `process`, `require`, `window`, `globalThis`
    - Use `setTimeout`, `setInterval`, or timers
    - Access prototype chains (`__proto__`, `constructor`)
    - Use `while` or `do...while` loops (unbounded)
    - Create `Proxy`, use `Reflect`, or metaprogramming
  </Card>
</CardGroup>

### Syntax Quick Reference

```js
// ✅ Variable declarations
const users = await callTool('users:list', { limit: 10 });
let total = 0;

// ✅ Tool calls (the primary API)
const result = await callTool('toolName', { arg1: 'value', arg2: 123 });

// ✅ Conditionals
if (users.length > 0) {
  total = users.length;
} else {
  total = 0;
}

// ✅ For loops (with iteration limits enforced by Enclave)
for (let i = 0; i < users.length; i++) {
  total += users[i].score;
}

// ✅ For-of loops (preferred for iteration)
for (const user of users) {
  console.log(user.name);
}

// ✅ Array methods with arrow functions
const activeUsers = users.filter(u => u.active);
const names = users.map(u => u.name);
const sum = numbers.reduce((acc, n) => acc + n, 0);

// ✅ Object/array literals
const data = { userId: user.id, items: [1, 2, 3] };

// ✅ Template literals
const message = `Found ${users.length} users`;

// ✅ Return values
return { users: activeUsers, total };
```

### Allowed Globals

AgentScript provides a limited set of safe globals:

| Global      | Description                   | Example                            |
| ----------- | ----------------------------- | ---------------------------------- |
| `callTool`  | Call MCP tools                | `await callTool('users:list', {})` |
| `Math`      | Mathematical operations       | `Math.max(1, 2, 3)`                |
| `JSON`      | JSON parsing/stringification  | `JSON.parse('{"a":1}')`            |
| `Array`     | Array constructor and methods | `Array.isArray(x)`                 |
| `Object`    | Object methods                | `Object.keys(obj)`                 |
| `String`    | String methods                | `String(123)`                      |
| `Number`    | Number methods                | `Number.isNaN(x)`                  |
| `Date`      | Date operations               | `new Date()`                       |
| `console`\* | Logging (if enabled)          | `console.log('debug')`             |

<Note>
  `console` is only available when `enclave.allowConsole: true` is configured. Standard safe globals like `undefined`, `null`, `true`, `false`, `NaN`, `Infinity`, `isNaN`, `isFinite`, `parseInt`, `parseFloat` are also available.
</Note>

### Blocked Constructs

These constructs are blocked by ast-guard's AST validation:

<AccordionGroup>
  <Accordion title="Code Execution">
    ```js
    // ❌ All blocked
    eval('code');
    new Function('return 1')();
    setTimeout(() => {}, 100);
    setInterval(() => {}, 100);
    ```
    **Why:** Prevents arbitrary code execution and timing attacks.
  </Accordion>

  <Accordion title="System Access">
    ```js
    // ❌ All blocked
    process.env.SECRET;
    require('fs');
    import('module');
    global.foo;
    globalThis.bar;
    window.location;
    ```
    **Why:** Prevents sandbox escape and access to host environment.
  </Accordion>

  <Accordion title="Prototype Manipulation">
    ```js
    // ❌ All blocked
    obj.__proto__;
    obj.constructor;
    Object.prototype.foo = 'bar';
    this.constructor.constructor;
    ```
    **Why:** Prevents prototype pollution and sandbox escape via constructor chains.
  </Accordion>

  <Accordion title="User-Defined Functions">
    ```js
    // ❌ Blocked (prevents recursion)
    function myFunc() { /* ... */ }
    const myFunc = function() { /* ... */ };

    // ✅ Arrow functions ARE allowed (for array methods)
    const doubled = nums.map(n => n * 2);
    ```
    **Why:** Prevents recursion and complex control flow. Arrow functions are allowed for functional array operations.

  </Accordion>

  <Accordion title="Unbounded Loops">
    ```js
    // ❌ Blocked (unbounded)
    while (condition) { /* ... */ }
    do { /* ... */ } while (condition);
    for (key in obj) { /* ... */ }  // prototype walking

    // ✅ Allowed (bounded, with iteration limits)
    for (let i = 0; i < 10; i++) { /* ... */ }
    for (const item of array) { /* ... */ }
    ```
    **Why:** Prevents infinite loops. Allowed loops are transformed to enforce iteration limits.

  </Accordion>

  <Accordion title="Dangerous APIs">
    ```js
    // ❌ All blocked
    fetch('https://evil.com');
    new WebSocket('ws://evil.com');
    new Proxy(target, handler);
    Reflect.get(obj, 'prop');
    new Worker('worker.js');
    WebAssembly.compile(bytes);
    crypto.getRandomValues(arr);
    ```
    **Why:** Prevents network access, metaprogramming, native code execution, and sandbox escape.
  </Accordion>
</AccordionGroup>

### Reserved Identifiers

User code cannot declare or use identifiers starting with these prefixes:

- `__ag_` - Reserved for AgentScript compiler (e.g., `__ag_main`)
- `__safe_` - Reserved for runtime-injected safe functions (e.g., `__safe_callTool`)

```js
// ❌ Blocked
const __ag_hack = 'value';
let __safe_override = function() {};

// ✅ Allowed
const agentData = 'value';
let safeValue = 123;
```

### Common Patterns

<CodeGroup>

```js Sequential tool calls
// Call tools one after another
const user = await callTool('users:getById', { id: 'u-123' });
const orders = await callTool('orders:listByUser', { userId: user.id });
const invoice = await callTool('billing:getInvoice', { orderId: orders[0].id });

return { user, orderCount: orders.length, latestInvoice: invoice };
```

```js Parallel-like execution (sequential in practice)
// Collect multiple results
const results = [];
const userIds = ['u-1', 'u-2', 'u-3'];

for (const id of userIds) {
  const user = await callTool('users:getById', { id });
  results.push(user);
}

return results;
```

```js Filtering and aggregation
// Get data, filter, and aggregate
const users = await callTool('users:list', { limit: 100 });

const activeAdmins = users.items
  .filter(u => u.active && u.role === 'admin');

const totalScore = activeAdmins
  .reduce((sum, u) => sum + u.score, 0);

return {
  count: activeAdmins.length,
  totalScore,
  averageScore: totalScore / activeAdmins.length
};
```

```js Conditional logic
// Branch based on conditions
const user = await callTool('users:getById', { id: userId });

if (user.role === 'admin') {
  const allUsers = await callTool('users:list', { limit: 1000 });
  return { type: 'admin_view', users: allUsers.items };
} else {
  const myOrders = await callTool('orders:listByUser', { userId: user.id });
  return { type: 'user_view', orders: myOrders.items };
}
```

```js Data transformation
// Transform and reshape data
const orders = await callTool('orders:list', { status: 'pending' });

const summary = orders.items.map(order => ({
  id: order.id,
  customer: order.customerName,
  total: order.items.reduce((sum, item) => sum + item.price, 0),
  itemCount: order.items.length
}));

return {
  pendingOrders: summary,
  totalValue: summary.reduce((sum, o) => sum + o.total, 0)
};
```

</CodeGroup>

### Runtime Limits

Even valid AgentScript code is subject to runtime limits enforced by Enclave:

| Limit           | Default     | Purpose                                      |
| --------------- | ----------- | -------------------------------------------- |
| `timeoutMs`     | 30000 (30s) | Maximum execution time                       |
| `maxToolCalls`  | 100         | Maximum `callTool()` invocations             |
| `maxIterations` | 10000       | Maximum loop iterations (all loops combined) |

When limits are exceeded, execution stops immediately with an appropriate error status.

### Error Handling in Scripts

AgentScript doesn't support `try/catch` for user code - errors propagate to the `codecall.execute` response:

```js
// If this tool fails, the entire script fails with status: "tool_error"
const user = await callTool('users:getById', { id: 'nonexistent' });

// This code never runs if the above fails
return user;
```

For conditional handling, check tool results:

```js
const result = await callTool('users:getById', { id: userId });

// Check for error indicators in the result itself
if (result.error || !result.data) {
  return { success: false, message: 'User not found' };
}

return { success: true, user: result.data };
```

---

## Meta-Tools Reference

CodeCall exposes four meta-tools to models:

| Tool                    | Purpose                                | VM Required | Best For                               |
| ----------------------- | -------------------------------------- | ----------- | -------------------------------------- |
| **`codecall.search`**   | Find tools by natural language query   | No          | Tool discovery, app-scoped searches    |
| **`codecall.describe`** | Get input/output schemas for tools     | No          | Schema inspection before execution     |
| **`codecall.execute`**  | Run JavaScript execution plans         | Yes         | Multi-tool workflows, filtering, joins |
| **`codecall.invoke`**   | Direct tool call without VM (optional) | No          | Simple single-tool invocations         |

### Search Tool API (`codecall.search`)

Find tools by natural language description.

**Input:**

<ParamField path="query" type="string" required>
  Natural language description of what tools you need. Be specific about the functionality you are looking for.
</ParamField>

<ParamField path="filter" type="object">
  Optional filters to narrow down the search scope

  <Expandable title="properties">
    <ResponseField name="appIds" type="string[]">
      Optional array of app IDs to search within. If not provided, searches across all apps. Use this to narrow down results to specific domains (e.g., `["user", "billing"]`)
    </ResponseField>
  </Expandable>
</ParamField>

<ParamField path="excludeToolNames" type="string[]">
  Array of tool names you have ALREADY fetched or described in this conversation. These tools will be excluded from search results to avoid redundant lookups.

**IMPORTANT:** Only include tools you have actually searched for or described before - do not guess or assume tool names.

</ParamField>

<ParamField path="topK" type="number" default="8">
  Maximum number of matching tools to return. Defaults to 8. Maximum value is 50.
</ParamField>

**Output:**

<ResponseField name="results" type="array">
  Array of matching tools, sorted by relevance (most relevant first)

  <Expandable title="properties">
    <ResponseField name="name" type="string" required>
      The unique name of the tool (e.g., `"users:list"`, `"billing:getInvoice"`)
    </ResponseField>
    <ResponseField name="appId" type="string" required>
      The app ID this tool belongs to
    </ResponseField>
    <ResponseField name="description" type="string" required>
      Brief description of what this tool does
    </ResponseField>
    <ResponseField name="relevanceScore" type="number" required>
      Relevance score between 0 and 1, where 1 is most relevant to your query
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="warnings" type="array">
  Warnings about the search operation. Check this for:
  1. Excluded tools that do not exist in the index
  2. Empty results
  3. Partial results due to filtering

  <Expandable title="properties">
    <ResponseField name="type" type="enum" required>
      Type of warning: `excluded_tool_not_found`, `no_results`, or `partial_results`
    </ResponseField>
    <ResponseField name="message" type="string" required>
      Human-readable warning message
    </ResponseField>
    <ResponseField name="affectedTools" type="string[]">
      Tool names affected by this warning (for `excluded_tool_not_found` warnings)
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="totalAvailableTools" type="number" required>
  Total number of tools available in the search scope (before excluding and limiting to topK)
</ResponseField>

**Example:**

```json
{
  "query": "get all users who logged in today",
  "filter": { "appIds": ["user"] },
  "excludeToolNames": ["users:getById"],
  "topK": 5
}
```

**Response:**

```json
{
  "results": [
    {
      "name": "users:list",
      "appId": "user",
      "description": "List users with pagination and filtering",
      "relevanceScore": 0.92
    }
  ],
  "warnings": [
    {
      "type": "excluded_tool_not_found",
      "message": "Some excluded tools were not found in the index",
      "affectedTools": ["users:nonexistent"]
    }
  ],
  "totalAvailableTools": 15
}
```

### Describe Tool API (`codecall.describe`)

Get detailed schemas and usage examples for specific tools discovered through search.

**Input:**

<ParamField path="toolNames" type="string[]" required>
  Array of unique tool names (from codecall:search results) to fetch their detailed schemas and usage examples.

Example: `["users:list", "billing:getInvoice"]`

**Note:** Duplicate tool names are not allowed and will cause a validation error.

</ParamField>

**Output:**

<ResponseField name="tools" type="array">
  Array of tool descriptions with schemas and usage examples

  <Expandable title="properties">
    <ResponseField name="name" type="string" required>
      Tool name to be used in `callTool()` within codecall:execute scripts
    </ResponseField>
    <ResponseField name="appId" type="string" required>
      The app ID this tool belongs to
    </ResponseField>
    <ResponseField name="description" type="string" required>
      Detailed description of what this tool does
    </ResponseField>
    <ResponseField name="inputSchema" type="object" required>
      JSON Schema object describing the tool's input parameters
    </ResponseField>
    <ResponseField name="outputSchema" type="object">
      JSON Schema object describing the tool's output structure (optional)
    </ResponseField>
    <ResponseField name="annotations" type="object">
      MCP tool annotations (metadata)
    </ResponseField>
    <ResponseField name="usageExample" type="object" required>
      A practical example of how to use this tool in a codecall:execute script

      <Expandable title="properties">
        <ResponseField name="description" type="string" required>
          Description of what this example demonstrates
        </ResponseField>
        <ResponseField name="code" type="string" required>
          JavaScript code example showing how to call this tool using `callTool()`.

          Format: `const result = await callTool("tool:name", { ...params });`
        </ResponseField>
      </Expandable>
    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="notFound" type="string[]">
  Tool names that were requested but not found in the index. Check these for typos.
</ResponseField>

**Example:**

```json
{
  "toolNames": ["users:list", "billing:getInvoice"]
}
```

**Response:**

```json
{
  "tools": [
    {
      "name": "users:list",
      "appId": "user",
      "description": "List users with pagination and filtering",
      "inputSchema": {
        "type": "object",
        "properties": {
          "limit": { "type": "number", "default": 100 },
          "offset": { "type": "number", "default": 0 }
        }
      },
      "outputSchema": {
        "type": "object",
        "properties": {
          "items": { "type": "array" },
          "total": { "type": "number" }
        }
      },
      "usageExample": {
        "description": "Fetch first 10 users",
        "code": "const result = await callTool('users:list', { limit: 10, offset: 0 });"
      }
    }
  ],
  "notFound": []
}
```

### Invoke Tool API (`codecall.invoke`)

Directly invoke a single tool without running JavaScript code. Use this for simple, one-and-done actions.

**Input:**

<ParamField path="tool" type="string" required>
  The name of the tool to invoke (e.g., `"users:getById"`, `"billing:getInvoice"`).

Must be a tool you discovered via codecall:search.

</ParamField>

<ParamField path="input" type="object" required>
  The input parameters for the tool. Structure must match the tool's input schema (check codecall:describe for schema details).
</ParamField>

**Output (Success):**

<ResponseField name="status" type="'success'" required>
  Indicates successful execution
</ResponseField>

<ResponseField name="result" type="unknown" required>
  The tool execution result
</ResponseField>

**Output (Error):**

<ResponseField name="status" type="'error'" required>
  Indicates an error occurred
</ResponseField>

<ResponseField name="error" type="object" required>
  Error details

  <Expandable title="properties">
    <ResponseField name="type" type="enum" required>
      Type of error that occurred:
      - `tool_not_found` - The tool name doesn't exist (typo or wrong app)
      - `validation_error` - Input doesn't match the tool's schema
      - `execution_error` - The tool failed during execution
      - `permission_denied` - You don't have access to this tool
    </ResponseField>
    <ResponseField name="message" type="string" required>
      Human-readable error message
    </ResponseField>
    <ResponseField name="details" type="unknown">
      Additional error details if available
    </ResponseField>
  </Expandable>
</ResponseField>

**Example (Success):**

```json
{
  "tool": "users:getById",
  "input": { "id": "user_123" }
}
```

**Response:**

```json
{
  "status": "success",
  "result": {
    "id": "user_123",
    "name": "John Doe",
    "email": "john@example.com"
  }
}
```

**Example (Error):**

```json
{
  "status": "error",
  "error": {
    "type": "validation_error",
    "message": "Input validation failed: 'id' is required",
    "details": {
      "field": "id",
      "expected": "string"
    }
  }
}
```

### Execute Tool API (`codecall.execute`)

Run JavaScript code in a sandboxed VM to orchestrate multiple tools, filter results, join data, or implement complex workflows.

**Input:**

<ParamField path="script" type="string" required>
  JavaScript code to execute in the sandboxed VM. The script can call tools using the `callTool(toolName, input)` function and access results.

Example:

```js
const user = await callTool('users:getById', { id: 'user_123' });
const orders = await callTool('orders:listByUser', { userId: user.id });
return { user, orderCount: orders.length };
```

</ParamField>

<ParamField path="allowedTools" type="string[]">
  Optional allowlist of tools that can be called from the script. If not provided, all discovered tools are allowed.

Use this to restrict script capabilities:

```json
{
  "script": "const user = await callTool('users:getById', { id: '123' });",
  "allowedTools": ["users:getById", "users:list"]
}
```

</ParamField>

<ParamField path="timeoutMs" type="number">
  Optional execution timeout in milliseconds. Defaults to the plugin's configured timeout.

If the script exceeds this time, execution is terminated with a `timeout` status.

</ParamField>

**Output (Success):**

<ResponseField name="status" type="'ok'" required>
  Indicates successful execution
</ResponseField>

<ResponseField name="result" type="unknown" required>
  The return value from the script (whatever the script's final expression or `return` statement produces)
</ResponseField>

<ResponseField name="executionTime" type="number">
  Time taken to execute the script in milliseconds
</ResponseField>

**Output (Error):**

<ResponseField name="status" type="enum" required>
  Type of error that occurred:
  - `syntax_error` - JavaScript parse error (invalid syntax)
  - `illegal_access` - Script attempted to use blocked builtin or global
  - `runtime_error` - Bug in the JavaScript code (e.g., null reference, type error)
  - `tool_error` - A specific tool call failed
  - `timeout` - Script exceeded the configured timeout
</ResponseField>

<ResponseField name="error" type="object" required>
  Error details

  <Expandable title="properties">
    <ResponseField name="message" type="string" required>
      Human-readable error message
    </ResponseField>
    <ResponseField name="details" type="unknown">
      Additional error context (e.g., which tool failed, validation details, stack trace)
    </ResponseField>
    <ResponseField name="toolName" type="string">
      For `tool_error` status: the name of the tool that failed
    </ResponseField>
  </Expandable>
</ResponseField>

**Example (Success):**

```json
{
  "script": "const user = await callTool('users:getById', { id: 'user_123' }); const orders = await callTool('orders:listByUser', { userId: user.id }); return { userName: user.name, totalOrders: orders.length };"
}
```

**Response:**

```json
{
  "status": "ok",
  "result": {
    "userName": "John Doe",
    "totalOrders": 5
  },
  "executionTime": 234
}
```

**Example (Syntax Error):**

```json
{
  "script": "const user = await callTool('users:getById', { id: 'user_123' }"
}
```

**Response:**

```json
{
  "status": "syntax_error",
  "error": {
    "message": "Unexpected end of input",
    "details": {
      "line": 1,
      "column": 65
    }
  }
}
```

**Example (Tool Error):**

```json
{
  "script": "const user = await callTool('users:getById', { id: 'nonexistent' }); return user;"
}
```

**Response:**

```json
{
  "status": "tool_error",
  "error": {
    "message": "Tool execution failed: User not found",
    "toolName": "users:getById",
    "details": {
      "statusCode": 404,
      "error": "User with id 'nonexistent' does not exist"
    }
  }
}
```

### Execution Result Status Codes

When `codecall.execute` runs, results include a `status` field:

| Status               | Meaning                                 | Retry?                              |
| -------------------- | --------------------------------------- | ----------------------------------- |
| **`ok`**             | Script executed successfully            | N/A                                 |
| **`syntax_error`**   | JavaScript parse error                  | No - fix the script                 |
| **`illegal_access`** | Attempted to use blocked builtin/global | No - rewrite without forbidden APIs |
| **`runtime_error`**  | Bug in the JavaScript plan              | No - fix the script logic           |
| **`tool_error`**     | Specific tool call failed               | Maybe - check tool input            |
| **`timeout`**        | Script exceeded `timeoutMs`             | No - optimize or increase timeout   |

This lets models distinguish "my code is wrong" from "this specific tool call failed with input X".

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Tools not appearing in search">
    **Possible causes:**
    - Tool has `codecall.enabledInCodeCall: false`
    - Using `codecall_opt_in` mode but tool not explicitly enabled
    - Search query too specific or using wrong terminology

    **Solutions:**
    - Verify `codecall.enabledInCodeCall: true` in tool metadata
    - Check that plugin `mode` matches your intent
    - Improve tool descriptions to match search queries
    - Use broader search terms

  </Accordion>

  <Accordion title="Execution plans timing out">
    **Possible causes:**
    - Script contains loops with many iterations
    - Tools being called are slow
    - `timeoutMs` set too low

    **Solutions:**
    - Increase `enclave.timeoutMs` (default is 30s)
    - Lower `maxIterations` if loops aren't needed (default 10K)
    - Optimize slow tools or use caching
    - Check for accidental blocking operations
    - Enclave automatically enforces iteration limits to prevent infinite loops

  </Accordion>

  <Accordion title="Illegal access errors">
    **Possible cause:**
    - Script trying to use blocked globals or dangerous constructs

    **Solutions:**
    - Review the error message - ast-guard provides specific details
    - Ensure execution plan doesn't use `eval`, `Function`, `require`, `process`, etc.
    - Check the [ast-guard documentation](/docs/guides/ast-guard) for allowed globals
    - Use whitelisted globals: `Math`, `JSON`, `Array`, `Object`, `String`, `Number`, `Date`, `callTool`

  </Accordion>

  <Accordion title="Tool not allowed in execution plan">
    **Possible causes:**
    - Tool name misspelled in `allowedTools` array
    - Tool not enabled for CodeCall
    - Using `directCalls` allowlist that's too restrictive

    **Solutions:**
    - Verify tool name matches exactly (case-sensitive)
    - Check `codecall.enabledInCodeCall: true` in tool metadata
    - Review `directCalls.allowedTools` configuration
    - Try removing allowlist to allow all CodeCall-enabled tools

  </Accordion>

  <Accordion title="PII leaking through execution plans">
    **This should not happen** - CodeCall runs through the normal FrontMCP pipeline.

    **If you see PII leaks:**
    - Verify your PII plugin is registered and running
    - Check that PII plugin runs on `afterToolCall` hook
    - Ensure tool results are being scrubbed properly
    - CodeCall cannot bypass pipeline hooks

  </Accordion>
</AccordionGroup>

---

## Complete Example

```ts
import { FrontMcp, App, Tool, ToolContext } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';
import { z } from 'zod';

// User management tools
@Tool({
  name: 'users:list',
  description: 'List users with pagination and filtering',
  inputSchema: {
    limit: z.number().default(100),
    filter: z.object({
      role: z.enum(['admin', 'user', 'guest']).optional(),
      active: z.boolean().optional(),
    }).optional(),
  },
  codecall: {
    visibleInListTools: false, // Hidden from classic list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
class ListUsersTool extends ToolContext {
  async execute(input: { limit: number; filter?: any }) {
    this.logger.info('Listing users', input);
    return await this.database.getUsers(input);
  }
}

@Tool({
  name: 'users:getById',
  description: 'Get user details by ID',
  inputSchema: { id: z.string() },
  codecall: {
    visibleInListTools: false,
    enabledInCodeCall: true,
  },
})
class GetUserByIdTool extends ToolContext {
  async execute(input: { id: string }) {
    return await this.database.getUserById(input.id);
  }
}

// Billing tools
@Tool({
  name: 'billing:listInvoices',
  description: 'List invoices for a user',
  inputSchema: {
    userId: z.string(),
    status: z.enum(['paid', 'unpaid', 'overdue']).optional(),
  },
  codecall: {
    visibleInListTools: false,
    enabledInCodeCall: true,
  },
})
class ListInvoicesTool extends ToolContext {
  async execute(input: { userId: string; status?: string }) {
    return await this.billing.getInvoices(input.userId, input.status);
  }
}

// Configure CodeCall with Enclave settings
const codecallPlugin = CodeCallPlugin.init({
  mode: 'codecall_only', // Hide all tools, expose via CodeCall
  topK: 8,
  maxDefinitions: 8,

  directCalls: {
    enabled: true, // Enable direct calls for simple cases
    allowedTools: ['users:getById'], // Only allow safe read operations
  },

  enclave: {
    timeoutMs: 5000, // 5 second timeout
    maxToolCalls: 100, // Max 100 tool calls per execution
    maxIterations: 10000, // Max 10K loop iterations
    allowConsole: true, // Enable logging for debugging
  },
  // Note: Enclave automatically blocks eval, Function, process, require
  // via ast-guard AST validation - no manual configuration needed
});

@App({
  id: 'user',
  name: 'User Management',
  tools: [ListUsersTool, GetUserByIdTool],
  plugins: [codecallPlugin],
})
class UserApp {}

@App({
  id: 'billing',
  name: 'Billing',
  tools: [ListInvoicesTool],
  plugins: [codecallPlugin],
})
class BillingApp {}

@FrontMcp({
  info: { name: 'Multi-App Server', version: '1.0.0' },
  apps: [UserApp, BillingApp],
  http: { port: 3000 },
})
export default class Server {}

/*
Example model workflow:

1. Search for tools:
   codecall.search({
     query: "show unpaid invoices for active admin users",
     filter: { appIds: ["user", "billing"] }
   })

2. Describe relevant tools:
   codecall.describe({
     tools: ["users:list", "billing:listInvoices"]
   })

3. Execute orchestration plan:
   codecall.execute({
     script: `
       async function main() {
         // Get active admin users
         const users = await callTool('users:list', {
           limit: 100,
           filter: { role: 'admin', active: true }
         });

         // Get unpaid invoices for each admin
         const results = [];
         for (const user of users.items) {
           const invoices = await callTool('billing:listInvoices', {
             userId: user.id,
             status: 'unpaid'
           });

           if (invoices.items.length > 0) {
             results.push({
               userId: user.id,
               userName: user.name,
               unpaidCount: invoices.items.length,
               totalAmount: invoices.items.reduce((sum, inv) => sum + inv.amount, 0)
             });
           }
         }

         return results;
       }

       return main();
     `,
     allowedTools: ["users:list", "billing:listInvoices"]
   })
*/
```

---

## Links & Resources

<CardGroup cols={2}>
  <Card title="Source Code" icon="github" href="https://github.com/agentfront/frontmcp/tree/main/libs/plugins/src/codecall">
    View the CodeCall plugin source code
  </Card>

  <Card title="Demo Application" icon="code" href="https://github.com/agentfront/frontmcp/tree/main/apps/demo">
    See CodeCall in action with real examples
  </Card>

  <Card title="Plugin Guide" icon="puzzle-piece" href="/docs/servers/extensibility/plugins">
    Learn more about FrontMCP plugins
  </Card>

  <Card title="Enclave Guide" icon="shield-halved" href="/docs/guides/enclave">
    Learn about Enclave's defense-in-depth security model
  </Card>

  <Card title="AST Guard Guide" icon="shield-check" href="/docs/guides/ast-guard">
    Understand ast-guard's AST validation and transformation
  </Card>
</CardGroup>
