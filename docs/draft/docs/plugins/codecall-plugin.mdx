---
title: CodeCall Plugin
description: Hide large toolsets behind a code-first meta-API that lets models search, describe, and orchestrate tools using JavaScript execution plans.
icon: code
---

The CodeCall Plugin transforms how you expose large toolsets to models. Instead of listing hundreds of tools in `list_tools`, CodeCall provides a small meta-API that lets models discover tools dynamically, then orchestrate them using JavaScript execution plans running in a secure sandbox.

## Why Use CodeCall?

<CardGroup cols={2}>
  <Card title="Scale Beyond Context Limits" icon="arrows-maximize">
    Expose hundreds or thousands of tools without overwhelming the model's context window
  </Card>
  <Card title="Enable Complex Workflows" icon="diagram-project">
    Let models build multi-step workflows, joins, and filters that your API doesn't support directly
  </Card>

  <Card title="Multi-App Orchestration" icon="layer-group">
    Search and call tools across multiple apps in the same server with app-aware filtering
  </Card>

  <Card title="Safe Code Execution" icon="shield-check">
    Run model-generated JavaScript in a vm2 sandbox with CSP-style security presets
  </Card>
</CardGroup>

## Installation

```bash
npm install @frontmcp/plugins
```

## How It Works

<Steps>
  <Step title="Search for Tools">
    Model calls `codecall.search` with natural language to discover relevant tools across apps
  </Step>
  <Step title="Describe Schemas">
    Model calls `codecall.describe` to get input/output schemas for selected tools
  </Step>

  <Step title="Generate Execution Plan">
    Model writes a JavaScript plan that orchestrates multiple tools, filters results, and builds custom logic
  </Step>

  <Step title="Execute in Sandbox">
    CodeCall runs the plan in a secure vm2 sandbox, calling your real tools through the normal FrontMCP pipeline
  </Step>
</Steps>

<Info>
  CodeCall uses [vm2](https://github.com/patriksimek/vm2) to run model-generated JavaScript in a secure sandbox with configurable security presets.
</Info>

---

## Quick Start

### Basic Setup

```ts
import { App, Tool, ToolContext } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';
import { z } from 'zod';

@Tool({
  name: 'users:list',
  description: 'List users with pagination',
  inputSchema: { limit: z.number().default(100) },
  codecall: {
    visibleInListTools: false, // Hidden from list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
class ListUsersTool extends ToolContext {
  async execute(input: { limit: number }) {
    return await this.database.getUsers(input.limit);
  }
}

@App({
  id: 'user',
  name: 'User App',
  tools: [ListUsersTool],
  plugins: [
    CodeCallPlugin.init({
      mode: 'codecall_only', // Recommended: many tools, all via CodeCall
      topK: 8, // Return top 8 search results
      maxDefinitions: 8, // Max tools to describe at once
      vm: {
        preset: 'secure', // CSP-style security preset
        timeoutMs: 4000,
        allowConsole: true,
      },
    }),
  ],
})
export default class UserApp {}
```

From the model's perspective, `list_tools` now shows:

- `codecall.search` - Find tools by natural language
- `codecall.describe` - Get tool schemas
- `codecall.execute` - Run JavaScript execution plans
- (Optional) `codecall.invoke` - Direct tool calls without VM

All other tools are hidden from `list_tools` but discoverable via `codecall.search`.

---

## Configuration Options

### Plugin-Level Configuration

Configure CodeCall behavior when registering the plugin:

<ParamField path="mode" type="'codecall_only' | 'codecall_opt_in' | 'metadata_driven'" default="'codecall_only'">
  Controls which tools are visible in `list_tools` and usable via CodeCall

  - **`codecall_only`** - Hide all tools by default, make all available via CodeCall (best for large toolsets)
  - **`codecall_opt_in`** - Hide all tools, only enable specific tools for CodeCall (best for selective exposure)
  - **`metadata_driven`** - No defaults, configure everything per-tool (best for small toolsets with mixed usage)
</ParamField>

<ParamField path="topK" type="number" default="8">
  Maximum number of tools to return from `codecall.search`
</ParamField>

<ParamField path="maxDefinitions" type="number" default="8">
  Maximum number of tools that can be described in a single `codecall.describe` call
</ParamField>

<ParamField path="directCalls" type="object">
  Configure direct tool invocation without VM execution

  <Expandable title="properties">
    <ResponseField name="enabled" type="boolean" default="false">
      Enable `codecall.invoke` for simple single-tool calls without running the VM
    </ResponseField>
    <ResponseField name="allowedTools" type="string[]">
      Optional allowlist of tool names. If omitted, all CodeCall-enabled tools are allowed
    </ResponseField>
  </Expandable>
</ParamField>

<ParamField path="vm" type="object">
  VM sandbox configuration

  <Expandable title="properties">
    <ResponseField name="preset" type="'locked_down' | 'secure' | 'balanced' | 'experimental'" default="'secure'">
      Security preset. Use `secure` for production, `locked_down` for highly sensitive environments
    </ResponseField>
    <ResponseField name="timeoutMs" type="number" default="4000">
      Maximum execution time in milliseconds
    </ResponseField>
    <ResponseField name="allowLoops" type="boolean" default="false">
      Allow for/while loops in execution plans (increases runtime risk)
    </ResponseField>
    <ResponseField name="disabledBuiltins" type="string[]">
      Built-in JavaScript functions to disable (e.g., `['eval', 'Function']`)
    </ResponseField>
    <ResponseField name="disabledGlobals" type="string[]">
      Global objects to disable (e.g., `['process', 'require', 'fetch']`)
    </ResponseField>
    <ResponseField name="allowConsole" type="boolean" default="false">
      Enable console.log/warn/error in execution plans
    </ResponseField>
  </Expandable>
</ParamField>

### Tool-Level Configuration

Configure CodeCall behavior per tool in the `@Tool` or `tool()` metadata:

<CodeGroup>

```ts Hide from list_tools, enable for CodeCall
@Tool({
  name: 'users:list',
  description: 'List users with pagination',
  codecall: {
    visibleInListTools: false, // Hidden from list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
```

```ts Keep visible, also enable for CodeCall
@Tool({
  name: 'health:ping',
  description: 'Health check',
  codecall: {
    visibleInListTools: true, // Keep in list_tools
    enabledInCodeCall: true, // Also available via CodeCall
  },
})
```

```ts Disable from CodeCall
@Tool({
  name: 'admin:deleteUser',
  description: 'Delete user (admin only)',
  codecall: {
    visibleInListTools: true, // Keep in list_tools
    enabledInCodeCall: false, // NOT available via CodeCall
  },
})
```

</CodeGroup>

<ParamField path="codecall.visibleInListTools" type="boolean">
  Whether the tool appears in `list_tools`. Defaults depend on `mode`:
  - `codecall_only`: default `false`
  - `codecall_opt_in`: default `false`
  - `metadata_driven`: default `false` (must be explicit)
</ParamField>

<ParamField path="codecall.enabledInCodeCall" type="boolean">
  Whether the tool is searchable and callable via CodeCall. Defaults depend on `mode`:
  - `codecall_only`: default `true`
  - `codecall_opt_in`: default `false`
  - `metadata_driven`: default `false` (must be explicit)
</ParamField>

---

## Advanced Usage

### Multi-App Search

When your FrontMCP server has multiple apps (e.g., `user`, `billing`), models can scope searches by app:

```ts
// Search only in "user" app
await callTool('codecall.search', {
  query: 'get current user profile',
  filter: { appIds: ['user'] }
});

// Search across "user" AND "billing" apps
await callTool('codecall.search', {
  query: 'show unpaid invoices for current user',
  filter: { appIds: ['user', 'billing'] }
});
```

<Tip>
  Multi-app search lets models decide per-task whether they need data from a single app or to join data across apps.
</Tip>

### Direct Tool Calls (No VM)

For simple single-tool invocations, enable `codecall.invoke` to bypass VM overhead:

```ts
CodeCallPlugin.init({
  directCalls: {
    enabled: true,
    allowedTools: ['users:getById', 'billing:getInvoice'], // Optional allowlist
  },
});
```

The model can then call tools directly without writing JavaScript:

```json
{
  "tool": "codecall.invoke",
  "input": {
    "tool": "users:getById",
    "input": { "id": "u-123" }
  }
}
```

This is ideal when the model needs a single tool action without multi-step orchestration.

### Logging and Notifications

CodeCall supports visibility into execution plan progress:

#### Automatic Tool Call Events

Every `callTool()` inside a plan can emit:
- **"tool call started"** event (with tool name + input)
- **"tool call finished"** event (with tool name + result + status)

These can be surfaced by your transport as live updates (e.g., SSE).

#### Script-Driven Logging

Enable `allowConsole` to let models add custom logging:

```js
async function main() {
  console.log('Starting user sync...');

  const users = await callTool('users:list', { limit: 100 });
  console.log(`Loaded ${users.length} users`);

  return users;
}

return main();
```

For structured notifications:

```js
mcpNotify('step_started', { step: 'sync_billing' });
mcpLog('info', 'Loaded invoices', { count: invoices.length });
mcpNotify('step_completed', { step: 'sync_billing' });
```

<Warning>
  Disable `mcpLog` and `mcpNotify` if you don't want models to emit custom notifications in production.
</Warning>

### PII and Privacy

CodeCall runs **on top of** your existing FrontMCP pipeline. When a plan calls `callTool()`:

- The request still flows through:
  - PII plugins (scrubbing/masking)
  - Auth plugins
  - Rate limiting
  - Audit logging

- CodeCall sees the **same response** a normal tool call would see after plugins run

**This means:**
- CodeCall cannot leak more data than normal tool calls
- PII redaction logic stays in your PII plugin, not in CodeCall
- Privacy guarantees are consistent across all tool invocations

### Tool Discovery and Caching

#### With Tool List Change Notifications

If your transport supports sessions and notifications:

1. Client calls `codecall.search` and `codecall.describe` for a session
2. Cache tool definitions (names + schemas) in memory, keyed by session
3. When tools change, server sends **"tool list changed"** notification
4. Client refreshes only when notified

#### Without Notifications

If your transport doesn't support notifications:

- Call `codecall.describe` before using a tool in `codecall.execute`
- Treat search/describe as ephemeral and re-run as needed to avoid stale schemas

### OAuth and Permissions (Future)

Some tools may be discoverable but require additional authorization before execution. In these cases:

- The tool returns a structured "authorization required" response with:
  - OAuth URL to start the flow
  - Required scope/reason
  - Tool name

- CodeCall returns this response as-is (no special handling)
- A future **authorization plugin** can:
  - Detect this pattern
  - Coordinate the OAuth flow
  - Retry execution after permissions are granted

This keeps separation of concerns:
- **CodeCall:** Code orchestration + sandboxing
- **Auth plugin:** Identity/permissions orchestration

---

## Best Practices

<AccordionGroup>
  <Accordion title="1. Choose the Right Mode">
    - **`codecall_only`** - Best for large toolsets (50+ tools), especially OpenAPI-generated tools
    - **`codecall_opt_in`** - Best when only a subset of tools should be orchestratable
    - **`metadata_driven`** - Best for small toolsets (< 10 tools) with mixed usage patterns
  </Accordion>

  <Accordion title="2. Use Secure VM Presets">
    - **Production:** Use `secure` or `locked_down` presets
    - **Development:** Use `balanced` or `experimental` for faster iteration
    - **Sensitive data:** Use `locked_down` + disable loops + minimal globals
    - Always set `timeoutMs` to prevent runaway scripts
  </Accordion>

  <Accordion title="3. Enable Direct Calls for Simple Cases">
    Enable `codecall.invoke` to bypass VM overhead for single-tool invocations:
    ```ts
    directCalls: {
      enabled: true,
      allowedTools: ['users:getById', 'health:ping'] // Optional allowlist
    }
    ```
    This reduces latency and resource usage when complex orchestration isn't needed.
  </Accordion>

  <Accordion title="4. Scope Tools by App">
    When using multi-app servers, encourage models to scope searches:
    ```ts
    // Good: scoped to specific app
    filter: { appIds: ['user'] }

    // Okay: cross-app when needed
    filter: { appIds: ['user', 'billing'] }

    // Avoid: no scoping (searches all apps)
    // Only use when truly needed
    ```
  </Accordion>

  <Accordion title="5. Set Appropriate Limits">
    Configure `topK` and `maxDefinitions` based on your use case:
    ```ts
    topK: 8, // Enough for most tasks, not too noisy
    maxDefinitions: 8, // Balance between context and capability
    ```
    Lower values reduce context usage but may limit complex workflows.
  </Accordion>
</AccordionGroup>

---

## Meta-Tools Reference

CodeCall exposes four meta-tools to models:

| Tool | Purpose | VM Required | Best For |
| ---- | ------- | ----------- | -------- |
| **`codecall.search`** | Find tools by natural language query | No | Tool discovery, app-scoped searches |
| **`codecall.describe`** | Get input/output schemas for tools | No | Schema inspection before execution |
| **`codecall.execute`** | Run JavaScript execution plans | Yes | Multi-tool workflows, filtering, joins |
| **`codecall.invoke`** | Direct tool call without VM (optional) | No | Simple single-tool invocations |

### Execution Result Status Codes

When `codecall.execute` runs, results include a `status` field:

| Status | Meaning | Retry? |
| ------ | ------- | ------ |
| **`ok`** | Script executed successfully | N/A |
| **`syntax_error`** | JavaScript parse error | No - fix the script |
| **`illegal_access`** | Attempted to use blocked builtin/global | No - rewrite without forbidden APIs |
| **`runtime_error`** | Bug in the JavaScript plan | No - fix the script logic |
| **`tool_error`** | Specific tool call failed | Maybe - check tool input |
| **`timeout`** | Script exceeded `timeoutMs` | No - optimize or increase timeout |

This lets models distinguish "my code is wrong" from "this specific tool call failed with input X".

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Tools not appearing in search">
    **Possible causes:**
    - Tool has `codecall.enabledInCodeCall: false`
    - Using `codecall_opt_in` mode but tool not explicitly enabled
    - Search query too specific or using wrong terminology

    **Solutions:**
    - Verify `codecall.enabledInCodeCall: true` in tool metadata
    - Check that plugin `mode` matches your intent
    - Improve tool descriptions to match search queries
    - Use broader search terms
  </Accordion>

  <Accordion title="Execution plans timing out">
    **Possible causes:**
    - Script contains infinite loops
    - Tools being called are slow
    - `timeoutMs` set too low

    **Solutions:**
    - Increase `vm.timeoutMs` (but keep under 10s for production)
    - Disable loops with `allowLoops: false` if not needed
    - Optimize slow tools or use caching
    - Check for accidental blocking operations
  </Accordion>

  <Accordion title="Illegal access errors">
    **Possible cause:**
    - Script trying to use disabled builtins/globals

    **Solutions:**
    - Check `disabledBuiltins` and `disabledGlobals` configuration
    - Ensure execution plan doesn't use `eval`, `Function`, `require`, etc.
    - Use a less restrictive preset for development/testing
    - Review AST validation errors for specifics
  </Accordion>

  <Accordion title="Tool not allowed in execution plan">
    **Possible causes:**
    - Tool name misspelled in `allowedTools` array
    - Tool not enabled for CodeCall
    - Using `directCalls` allowlist that's too restrictive

    **Solutions:**
    - Verify tool name matches exactly (case-sensitive)
    - Check `codecall.enabledInCodeCall: true` in tool metadata
    - Review `directCalls.allowedTools` configuration
    - Try removing allowlist to allow all CodeCall-enabled tools
  </Accordion>

  <Accordion title="PII leaking through execution plans">
    **This should not happen** - CodeCall runs through the normal FrontMCP pipeline.

    **If you see PII leaks:**
    - Verify your PII plugin is registered and running
    - Check that PII plugin runs on `afterToolCall` hook
    - Ensure tool results are being scrubbed properly
    - CodeCall cannot bypass pipeline hooks
  </Accordion>
</AccordionGroup>

---

## Complete Example

```ts
import { FrontMcp, App, Tool, ToolContext } from '@frontmcp/sdk';
import CodeCallPlugin from '@frontmcp/plugins/codecall';
import { z } from 'zod';

// User management tools
@Tool({
  name: 'users:list',
  description: 'List users with pagination and filtering',
  inputSchema: {
    limit: z.number().default(100),
    filter: z.object({
      role: z.enum(['admin', 'user', 'guest']).optional(),
      active: z.boolean().optional(),
    }).optional(),
  },
  codecall: {
    visibleInListTools: false, // Hidden from classic list_tools
    enabledInCodeCall: true, // Available via CodeCall
  },
})
class ListUsersTool extends ToolContext {
  async execute(input: { limit: number; filter?: any }) {
    this.logger.info('Listing users', input);
    return await this.database.getUsers(input);
  }
}

@Tool({
  name: 'users:getById',
  description: 'Get user details by ID',
  inputSchema: { id: z.string() },
  codecall: {
    visibleInListTools: false,
    enabledInCodeCall: true,
  },
})
class GetUserByIdTool extends ToolContext {
  async execute(input: { id: string }) {
    return await this.database.getUserById(input.id);
  }
}

// Billing tools
@Tool({
  name: 'billing:listInvoices',
  description: 'List invoices for a user',
  inputSchema: {
    userId: z.string(),
    status: z.enum(['paid', 'unpaid', 'overdue']).optional(),
  },
  codecall: {
    visibleInListTools: false,
    enabledInCodeCall: true,
  },
})
class ListInvoicesTool extends ToolContext {
  async execute(input: { userId: string; status?: string }) {
    return await this.billing.getInvoices(input.userId, input.status);
  }
}

// Configure CodeCall with secure settings
const codecallPlugin = CodeCallPlugin.init({
  mode: 'codecall_only', // Hide all tools, expose via CodeCall
  topK: 8,
  maxDefinitions: 8,

  directCalls: {
    enabled: true, // Enable direct calls for simple cases
    allowedTools: ['users:getById'], // Only allow safe read operations
  },

  vm: {
    preset: 'secure', // Production-safe preset
    timeoutMs: 5000, // 5 second timeout
    allowLoops: false, // Disable loops for safety
    allowConsole: true, // Enable logging for debugging
    disabledBuiltins: ['eval', 'Function'],
    disabledGlobals: ['require', 'process', 'fetch', 'setTimeout'],
  },
});

@App({
  id: 'user',
  name: 'User Management',
  tools: [ListUsersTool, GetUserByIdTool],
  plugins: [codecallPlugin],
})
class UserApp {}

@App({
  id: 'billing',
  name: 'Billing',
  tools: [ListInvoicesTool],
  plugins: [codecallPlugin],
})
class BillingApp {}

@FrontMcp({
  info: { name: 'Multi-App Server', version: '1.0.0' },
  apps: [UserApp, BillingApp],
  http: { port: 3000 },
})
export default class Server {}

/*
Example model workflow:

1. Search for tools:
   codecall.search({
     query: "show unpaid invoices for active admin users",
     filter: { appIds: ["user", "billing"] }
   })

2. Describe relevant tools:
   codecall.describe({
     tools: ["users:list", "billing:listInvoices"]
   })

3. Execute orchestration plan:
   codecall.execute({
     script: `
       async function main() {
         // Get active admin users
         const users = await callTool('users:list', {
           limit: 100,
           filter: { role: 'admin', active: true }
         });

         // Get unpaid invoices for each admin
         const results = [];
         for (const user of users.items) {
           const invoices = await callTool('billing:listInvoices', {
             userId: user.id,
             status: 'unpaid'
           });

           if (invoices.items.length > 0) {
             results.push({
               userId: user.id,
               userName: user.name,
               unpaidCount: invoices.items.length,
               totalAmount: invoices.items.reduce((sum, inv) => sum + inv.amount, 0)
             });
           }
         }

         return results;
       }

       return main();
     `,
     allowedTools: ["users:list", "billing:listInvoices"]
   })
*/
```

---

## Links & Resources

<CardGroup cols={2}>
  <Card title="Source Code" icon="github" href="https://github.com/agentfront/frontmcp/tree/main/libs/plugins/src/codecall">
    View the CodeCall plugin source code
  </Card>

  <Card title="Demo Application" icon="code" href="https://github.com/agentfront/frontmcp/tree/main/apps/demo">
    See CodeCall in action with real examples
  </Card>

  <Card title="Plugin Guide" icon="puzzle-piece" href="/docs/servers/extensibility/plugins">
    Learn more about FrontMCP plugins
  </Card>

  <Card title="vm2 Documentation" icon="shield-halved" href="https://github.com/patriksimek/vm2">
    Official vm2 sandbox documentation
  </Card>
</CardGroup>
