---
title: Remember Plugin
description: Encrypted session memory with scoped storage and tool approval system for secure AI agent interactions.
icon: brain
---

The Remember Plugin provides encrypted session memory and a comprehensive approval system for FrontMCP servers, enabling AI agents to remember context across conversations and manage sensitive tool permissions.

## Why Use Remember?

<CardGroup cols={2}>
  <Card title="Session Memory" icon="brain">
    Store user preferences, conversation context, and state across tool invocations
  </Card>
  <Card title="Encrypted Storage" icon="lock">
    AES-256-GCM encryption protects sensitive data at rest
  </Card>

  <Card title="Tool Approvals" icon="shield-check">
    Claude Code-style permission system for sensitive tool authorization
  </Card>

  <Card title="Multiple Backends" icon="database">
    Redis, Vercel KV, or in-memory storage for different deployment needs
  </Card>
</CardGroup>

## Installation

```bash
npm install @frontmcp/plugin-remember
```

## How It Works

<Steps>
  <Step title="Context Extension">
    The plugin adds `this.remember` and `this.approval` to all execution contexts (ToolContext, AgentContext, etc.)
  </Step>
  <Step title="Scoped Storage">
    Data is organized by scope (session, user, tool, global) with automatic key prefixing
  </Step>

  <Step title="Encryption">
    Values are encrypted before storage using keys derived from session/user identifiers
  </Step>

  <Step title="TTL Management">
    Entries expire automatically based on configured TTL or scope lifetime
  </Step>
</Steps>

<Info>
  All stored values are **encrypted by default** using AES-256-GCM. Keys are derived using HKDF-SHA256 from session and user identifiers.
</Info>

---

## Quick Start

### Basic Setup

```ts
import { FrontMcp, App } from '@frontmcp/sdk';
import { RememberPlugin } from '@frontmcp/plugin-remember';

@App({
  id: 'my-app',
  name: 'My App',
  plugins: [RememberPlugin], // Default: memory store, encryption enabled
  tools: [
    /* your tools */
  ],
})
class MyApp {}

@FrontMcp({
  info: { name: 'My Server', version: '1.0.0' },
  apps: [MyApp],
})
export default class Server {}
```

### Using Memory in Tools

The plugin extends all execution contexts with `this.remember`:

<CodeGroup>

```ts Class-based tool
import { Tool, ToolContext } from '@frontmcp/sdk';
import { z } from 'zod';

@Tool({
  name: 'personalize-greeting',
  description: 'Greet user with their preferences',
  inputSchema: { name: z.string() },
})
export default class PersonalizeGreetingTool extends ToolContext {
  async execute(input: { name: string }) {
    // Get remembered preference (or default)
    const theme = await this.remember.get('theme', { defaultValue: 'light' });

    // Store for future use
    await this.remember.set('last_greeted', input.name);

    return `Hello ${input.name}! Your theme is ${theme}.`;
  }
}
```

```ts Function-based tool
import { tool } from '@frontmcp/sdk';
import { z } from 'zod';

export const PersonalizeGreeting = tool({
  name: 'personalize-greeting',
  description: 'Greet user with their preferences',
  inputSchema: { name: z.string() },
})(async (input, ctx) => {
  // Access remember through context
  const theme = await ctx.remember.get('theme', { defaultValue: 'light' });
  await ctx.remember.set('last_greeted', input.name);

  return `Hello ${input.name}! Your theme is ${theme}.`;
});
```

</CodeGroup>

---

## Memory Scopes

Memory is organized into four scopes with different visibility and lifetime:

| Scope     | Description                          | Use Case                          |
| --------- | ------------------------------------ | --------------------------------- |
| `session` | Current session only (default)       | Temporary state, conversation context |
| `user`    | Persists across user sessions        | User preferences, settings        |
| `tool`    | Tied to specific tool + session      | Tool-specific cache               |
| `global`  | Shared across all sessions/users     | Application-wide configuration    |

### Using Scopes

```ts
// Session scope (default)
await this.remember.set('temp_token', 'xyz');
await this.remember.get('temp_token');

// User scope - persists across sessions
await this.remember.set('language', 'en', { scope: 'user' });
const lang = await this.remember.get('language', { scope: 'user' });

// Tool scope - isolated per tool
await this.remember.set('last_query', query, { scope: 'tool' });

// Global scope - shared everywhere
await this.remember.set('maintenance_mode', true, { scope: 'global' });
```

---

## Storage Options

### In-Memory (Default)

Best for: Single-instance deployments, development, non-persistent data

```ts
RememberPlugin.init({
  type: 'memory',
  defaultTTL: 3600, // 1 hour
});
```

<Warning>Memory storage resets when the process restarts. Not shared across instances.</Warning>

### Redis (Recommended for Production)

Best for: Multi-instance deployments, persistent memory, production

<CodeGroup>

```ts Redis connection config
RememberPlugin.init({
  type: 'redis',
  defaultTTL: 86400, // 1 day
  config: {
    host: '127.0.0.1',
    port: 6379,
    password: process.env.REDIS_PASSWORD,
    db: 0,
  },
});
```

```ts Reuse existing Redis client
import { Redis } from 'ioredis';

const redis = new Redis({
  host: 'redis.example.com',
  port: 6379,
});

RememberPlugin.init({
  type: 'redis-client',
  client: redis,
});
```

</CodeGroup>

### Vercel KV

Best for: Vercel deployments, serverless environments

```ts
RememberPlugin.init({
  type: 'vercel-kv',
  // Uses KV_REST_API_URL and KV_REST_API_TOKEN env vars by default
});
```

### Global Store

Use the store configuration from `@FrontMcp` decorator:

```ts
RememberPlugin.init({
  type: 'global-store', // Uses redis/vercel-kv from FrontMcp config
});
```

---

## Encryption

All stored values are encrypted by default using AES-256-GCM.

### How Keys Are Derived

1. A master secret is derived from `FRONTMCP_SECRET` environment variable (or auto-generated)
2. Per-entry keys are derived using HKDF-SHA256 with session/user context as salt
3. Each entry gets a unique key based on its scope and identity

### Configuration

```ts
RememberPlugin.init({
  type: 'redis',
  encryption: {
    enabled: true, // default
    customKey: process.env.CUSTOM_ENCRYPTION_KEY, // optional override
  },
  config: { host: 'localhost', port: 6379 },
});
```

<Warning>
  Set `FRONTMCP_SECRET` environment variable in production to ensure consistent encryption keys across restarts.
</Warning>

---

## Tool Approval System

The approval system provides Claude Code-style permission management for sensitive tools.

### Enable Approval System

```ts
RememberPlugin.init({
  type: 'redis',
  approval: {
    enabled: true,
  },
  config: { host: 'localhost', port: 6379 },
});
```

### Require Approval on Tools

```ts
@Tool({
  name: 'file_write',
  description: 'Write to file system',
  inputSchema: { path: z.string(), content: z.string() },
  approval: {
    required: true,
    defaultScope: 'session',
    category: 'write',
    riskLevel: 'medium',
    approvalMessage: 'Allow writing to file system for this session?',
  },
})
export default class FileWriteTool extends ToolContext {
  async execute(input: { path: string; content: string }) {
    // Tool only executes if approved
    return await this.fs.write(input.path, input.content);
  }
}
```

### Approval Options

<ParamField path="approval.required" type="boolean" default="true">
  Whether this tool requires approval before execution
</ParamField>

<ParamField path="approval.defaultScope" type="ApprovalScope" default="'session'">
  Default scope for approvals: `session`, `user`, `time_limited`, `tool_specific`, `context_specific`
</ParamField>

<ParamField path="approval.category" type="string">
  Category for grouping: `read`, `write`, `delete`, `execute`, `admin`
</ParamField>

<ParamField path="approval.riskLevel" type="string">
  Risk level hint: `low`, `medium`, `high`, `critical`
</ParamField>

<ParamField path="approval.approvalMessage" type="string">
  Message shown to user when prompting for approval
</ParamField>

<ParamField path="approval.alwaysPrompt" type="boolean" default="false">
  Prompt every time, even if previously approved (for highly sensitive operations)
</ParamField>

<ParamField path="approval.skipApproval" type="boolean" default="false">
  Skip approval entirely (for safe, read-only operations)
</ParamField>

### Checking Approval Status

```ts
@Tool({ name: 'dangerous_tool' })
class DangerousTool extends ToolContext {
  async execute(input) {
    // Check if approved
    const isApproved = await this.approval.isApproved('dangerous_tool');

    if (!isApproved) {
      // Request approval from client
      return { needsApproval: true, message: 'Please approve this action' };
    }

    // Proceed with dangerous operation
    return await this.performDangerousAction(input);
  }
}
```

---

## API Reference

### RememberAccessor Methods

<ParamField path="set(key, value, options?)" type="Promise<void>">
  Store a value with optional scope, TTL, and metadata

```ts
await this.remember.set('key', { data: 'value' }, {
  scope: 'user',
  ttl: 3600, // seconds
  brand: 'preference',
  metadata: { source: 'api' },
});
```

</ParamField>

<ParamField path="get<T>(key, options?)" type="Promise<T | undefined>">
  Retrieve a value with optional default

```ts
const value = await this.remember.get('key', {
  scope: 'user',
  defaultValue: 'fallback',
});
```

</ParamField>

<ParamField path="knows(key, options?)" type="Promise<boolean>">
  Check if a key exists

```ts
if (await this.remember.knows('onboarded', { scope: 'user' })) {
  // Skip onboarding
}
```

</ParamField>

<ParamField path="forget(key, options?)" type="Promise<void>">
  Delete a key

```ts
await this.remember.forget('temp_token', { scope: 'session' });
```

</ParamField>

<ParamField path="list(options?)" type="Promise<string[]>">
  List keys with optional pattern matching

```ts
const keys = await this.remember.list({
  scope: 'session',
  pattern: 'user:*',
});
```

</ParamField>

---

## LLM-Accessible Tools

Enable built-in tools that let the LLM manage memory directly:

```ts
RememberPlugin.init({
  type: 'redis',
  tools: {
    enabled: true,
    allowedScopes: ['session', 'user'], // Restrict which scopes LLM can access
    prefix: 'memory_', // Tool name prefix
  },
  config: { host: 'localhost', port: 6379 },
});
```

This exposes tools like `memory_remember_this`, `memory_recall`, `memory_forget`, and `memory_list_memories`.

---

## Best Practices

<AccordionGroup>
  <Accordion title="1. Use Appropriate Scopes">
    - **Session**: Temporary data, current conversation context
    - **User**: Preferences, settings that should persist
    - **Tool**: Tool-specific cache to avoid scope pollution
    - **Global**: Only for true application-wide settings
  </Accordion>

  <Accordion title="2. Set TTLs for Sensitive Data">
    Don't store sensitive data forever:
    ```ts
    await this.remember.set('auth_token', token, {
      ttl: 300, // 5 minutes
      scope: 'session',
    });
    ```
  </Accordion>

  <Accordion title="3. Use Redis for Production">
    Redis provides:
    - Persistence across restarts
    - Sharing across multiple server instances
    - Better memory management with eviction policies
  </Accordion>

  <Accordion title="4. Configure Approval for Sensitive Tools">
    Any tool that:
    - Writes to external systems
    - Accesses sensitive data
    - Performs irreversible actions

    Should have `approval: { required: true }` configured.
  </Accordion>

  <Accordion title="5. Set FRONTMCP_SECRET in Production">
    ```bash
    # Generate a secure secret
    openssl rand -base64 32

    # Set in environment
    export FRONTMCP_SECRET="your-generated-secret"
    ```
  </Accordion>
</AccordionGroup>

---

## Complete Example

```ts
import { FrontMcp, App, Tool, ToolContext } from '@frontmcp/sdk';
import { RememberPlugin } from '@frontmcp/plugin-remember';
import { z } from 'zod';

// Configure with Redis and approval system
const rememberPlugin = RememberPlugin.init({
  type: 'redis',
  defaultTTL: 86400, // 1 day
  encryption: { enabled: true },
  approval: { enabled: true },
  config: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
  },
});

// Tool using memory
@Tool({
  name: 'set-preferences',
  description: 'Set user preferences',
  inputSchema: {
    theme: z.enum(['light', 'dark']),
    language: z.string(),
  },
})
class SetPreferencesTool extends ToolContext {
  async execute(input: { theme: string; language: string }) {
    await this.remember.set('theme', input.theme, { scope: 'user' });
    await this.remember.set('language', input.language, { scope: 'user' });

    return { success: true, message: 'Preferences saved' };
  }
}

// Tool requiring approval
@Tool({
  name: 'delete-account',
  description: 'Permanently delete user account',
  inputSchema: { confirm: z.boolean() },
  approval: {
    required: true,
    riskLevel: 'critical',
    category: 'delete',
    approvalMessage: 'This will permanently delete your account. Are you sure?',
    alwaysPrompt: true, // Always ask, even if previously approved
  },
})
class DeleteAccountTool extends ToolContext {
  async execute(input: { confirm: boolean }) {
    if (!input.confirm) {
      return { success: false, message: 'Deletion not confirmed' };
    }

    // Perform deletion - list and delete all user-scoped memories
    const userKeys = await this.remember.list({ scope: 'user' });
    for (const key of userKeys) {
      await this.remember.forget(key, { scope: 'user' });
    }

    return { success: true, message: 'Account deleted' };
  }
}

@App({
  id: 'user-management',
  name: 'User Management',
  plugins: [rememberPlugin],
  tools: [SetPreferencesTool, DeleteAccountTool],
})
class UserManagementApp {}

@FrontMcp({
  info: { name: 'User Server', version: '1.0.0' },
  apps: [UserManagementApp],
  http: { port: 3000 },
})
export default class Server {}
```

---

## Links & Resources

<CardGroup cols={2}>
  <Card
    title="Source Code"
    icon="github"
    href="https://github.com/agentfront/frontmcp/tree/main/plugins/plugin-remember"
  >
    View the remember plugin source code
  </Card>

  <Card title="Demo Application" icon="code" href="https://github.com/agentfront/frontmcp/tree/main/apps/demo">
    See memory and approvals in action
  </Card>

  <Card title="Plugin Guide" icon="puzzle-piece" href="/docs/extensibility/plugins">
    Learn more about FrontMCP plugins
  </Card>

  <Card title="Cache Plugin" icon="database" href="/docs/plugins/cache-plugin">
    For tool response caching
  </Card>
</CardGroup>
