---
title: Validation
sidebarTitle: Validation
icon: shield-check
description: FrontMCP UI uses Zod schemas to validate component options at runtime. Invalid inputs render a styled error box instead of crashing.
---

## How Validation Works

Every component validates its options using a Zod schema with `.strict()` mode:

```typescript
// Inside button component
const validation = validateOptions(options, {
  schema: ButtonOptionsSchema,
  componentName: 'button',
});

if (!validation.success) {
  return validation.error; // Renders error box HTML
}
```

## Invalid Option Handling

When you pass invalid options:

```typescript
// Invalid variant value
const html = button('Click', { variant: 'invalid' as any });
```

Instead of throwing an error, the component returns an error box:

```html
<div class="validation-error bg-red-50 border border-red-200 rounded-lg p-4"
     data-component="button"
     data-param="variant">
  <div class="flex items-center gap-2 text-red-700">
    <svg><!-- Warning icon --></svg>
    <span class="font-medium">Validation Error</span>
  </div>
  <p class="text-red-600 text-sm mt-2">
    Invalid value for "variant" in button component
  </p>
</div>
```

## Strict Mode

All component schemas use `.strict()` which rejects unknown properties:

```typescript
// Unknown property rejected
const html = button('Click', { unknownProp: true } as any);
// Returns error box: "Unrecognized key 'unknownProp'"
```

This catches typos and API misuse early.

## Schema Examples

### Button Schema

```typescript
const ButtonOptionsSchema = z.object({
  variant: z.enum(['primary', 'secondary', 'outline', 'ghost', 'danger', 'success', 'link']).optional(),
  size: z.enum(['xs', 'sm', 'md', 'lg', 'xl']).optional(),
  type: z.enum(['button', 'submit', 'reset']).optional(),
  disabled: z.boolean().optional(),
  loading: z.boolean().optional(),
  fullWidth: z.boolean().optional(),
  iconBefore: z.string().optional(),
  iconAfter: z.string().optional(),
  iconOnly: z.boolean().optional(),
  className: z.string().optional(),
  id: z.string().optional(),
  name: z.string().optional(),
  value: z.string().optional(),
  href: z.string().optional(),
  target: z.string().optional(),
  htmx: HtmxSchema.optional(),
  data: z.record(z.string()).optional(),
  ariaLabel: z.string().optional(),
}).strict();
```

### HTMX Schema

```typescript
const HtmxSchema = z.object({
  get: z.string().optional(),
  post: z.string().optional(),
  put: z.string().optional(),
  delete: z.string().optional(),
  target: z.string().optional(),
  swap: z.string().optional(),
  trigger: z.string().optional(),
  confirm: z.string().optional(),
  indicator: z.string().optional(),
}).strict();
```

## Using validateOptions

Create validated custom components:

```typescript
import { validateOptions, escapeHtml } from '@frontmcp/ui';
import { z } from 'zod';

// Define schema
const MyComponentSchema = z.object({
  variant: z.enum(['light', 'dark']).optional(),
  size: z.enum(['sm', 'md', 'lg']).optional(),
}).strict();

type MyComponentOptions = z.infer<typeof MyComponentSchema>;

// Create component
export function myComponent(content: string, options: MyComponentOptions = {}): string {
  // Validate options
  const validation = validateOptions(options, {
    schema: MyComponentSchema,
    componentName: 'myComponent',
  });

  if (!validation.success) {
    return validation.error; // Return error box
  }

  const { variant = 'light', size = 'md' } = validation.data;

  // Build HTML with validated options
  return `<div class="my-component my-component--${variant} my-component--${size}">
    ${escapeHtml(content)}
  </div>`;
}
```

## Validation Error Box

The error box is styled consistently:

```typescript
function renderErrorBox(componentName: string, errors: string[]): string {
  const errorList = errors
    .map(err => `<li>${escapeHtml(err)}</li>`)
    .join('');

  return `
    <div class="validation-error bg-red-50 border border-red-200 rounded-lg p-4"
         data-component="${escapeHtml(componentName)}">
      <div class="flex items-center gap-2 text-red-700">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <span class="font-medium">Validation Error</span>
      </div>
      <ul class="text-red-600 text-sm mt-2 list-disc list-inside">
        ${errorList}
      </ul>
    </div>
  `;
}
```

## Testing Validation

Always test invalid inputs in your component tests:

```typescript
describe('button validation', () => {
  it('should return error box for invalid variant', () => {
    const html = button('Test', { variant: 'invalid' as any });
    expect(html).toContain('validation-error');
    expect(html).toContain('data-component="button"');
  });

  it('should return error box for unknown properties', () => {
    const html = button('Test', { unknownProp: true } as any });
    expect(html).toContain('validation-error');
  });

  it('should accept valid options', () => {
    const html = button('Test', { variant: 'primary', size: 'lg' });
    expect(html).not.toContain('validation-error');
    expect(html).toContain('button');
  });
});
```

## Common Validation Patterns

### Required Fields

```typescript
const schema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email format'),
});
```

### Constrained Values

```typescript
const schema = z.object({
  count: z.number().min(0).max(100),
  percentage: z.number().min(0).max(1),
  items: z.array(z.string()).max(10),
});
```

### Conditional Validation

```typescript
const schema = z.object({
  type: z.enum(['text', 'number']),
  value: z.union([z.string(), z.number()]),
}).refine(
  data => (data.type === 'number' ? typeof data.value === 'number' : true),
  { message: 'Value must be a number when type is "number"' }
);
```

### Transform Values

```typescript
const schema = z.object({
  size: z.enum(['sm', 'md', 'lg']).transform(s => ({
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg',
  }[s])),
});
```

## Security Considerations

Validation helps with security but isn't a complete solution:

1. **Still escape output** - Validation doesn't sanitize HTML
2. **Validate user input** - Schema validation is for component options, not user data
3. **Don't expose internals** - Error messages shouldn't reveal sensitive details

```typescript
// ✅ Good - validates options AND escapes content
function card(content: string, options: CardOptions = {}): string {
  const validation = validateOptions(options, { schema: CardOptionsSchema, componentName: 'card' });
  if (!validation.success) return validation.error;

  return `<div class="card">${escapeHtml(content)}</div>`;
}

// ❌ Bad - validates but doesn't escape
function card(content: string, options: CardOptions = {}): string {
  const validation = validateOptions(options, { schema: CardOptionsSchema, componentName: 'card' });
  if (!validation.success) return validation.error;

  return `<div class="card">${content}</div>`; // XSS vulnerability!
}
```

## Best Practices

1. **Use `.strict()` on schemas** - Catches typos and unknown properties
2. **Provide good error messages** - Help developers fix issues quickly
3. **Test validation** - Ensure error handling works correctly
4. **Keep schemas close to components** - Colocate in `.schema.ts` files
5. **Export types** - Let consumers use TypeScript inference

## Template validation for UI widgets

Components are only half the story—Handlebars/HTML templates can still reference fields that no longer exist in your tool's Zod schemas. `@frontmcp/ui/validation` now ships a schema-aware template validator so you can lint widgets the same way you lint TypeScript.

```typescript title="validateTemplate.ts"
import { validateTemplate } from '@frontmcp/ui/validation';
import { z } from 'zod';

const outputSchema = z.object({
  location: z.string(),
  temperature: z.number(),
  forecast: z.object({ summary: z.string().optional() }),
});

const inputSchema = z.object({ units: z.enum(['celsius', 'fahrenheit']).optional() });

const template = `
  <div>
    {{output.location}}
    {{output.temperature}}
    {{output.forecast.summary}}
    {{input.units}}
    {{output.forecst.icon}}
  </div>
`;

const result = validateTemplate(template, outputSchema, {
  inputSchema,
  warnOnOptional: true,
  suggestSimilar: true,
  toolName: 'get_weather',
});
```

`result` reports every path the template tried to render:

- `result.valid` – `false` when any fields are missing.
- `result.errors` – detailed objects with the failing `path`, `line`, `column`, and typo suggestions (`output.forecst.icon` above recommends `output.forecast.summary`).
- `result.warnings` – non-blocking hints such as “accessing optional field without a guard.”
- `result.templatePaths` / `result.schemaPaths` – quick lists you can dump into CI logs or docs.

### Options reference

| Option                                     | Description                                                                                  |
| ------------------------------------------ | -------------------------------------------------------------------------------------------- |
| `inputSchema`                              | Validate `{{input.*}}` paths alongside `output.*` so prompts and widgets stay in sync.       |
| `warnOnOptional`                           | Emits warnings whenever an optional field is rendered without a surrounding `{{#if}}` guard. |
| `suggestSimilar` + `maxSuggestionDistance` | Controls typo suggestions using Levenshtein distance.                                        |
| `toolName`                                 | Annotates log output so CI errors point back to the problematic tool.                        |

<Note>
Mintlify recommends surfacing actionable guidance inside docs. Mirror that in CI: pipe `result.errors` into your test output so contributors immediately see suggested field names instead of digging through schemas manually.
</Note>

### Fail builds early with `assertTemplateValid`

For critical widgets, throw immediately instead of manually checking `result.valid`:

```typescript title="weather.tool.spec.ts"
import { assertTemplateValid } from '@frontmcp/ui/validation';
import template from '../templates/weather.handlebars';
import { WeatherOutputSchema } from '../schemas/weather.schema';

describe('weather template', () => {
  it('matches the output schema', () => {
    expect(() =>
      assertTemplateValid(template, WeatherOutputSchema, 'get_weather'),
    ).not.toThrow();
  });
});
```

### Surface warnings while developing

`formatValidationWarnings(result, toolName)` turns the error objects into a ready-to-log string, and `logValidationWarnings` automatically calls `console.warn`. Use them in dev servers so engineers get immediate feedback before opening a PR.

```typescript
templateValidator.logValidationWarnings(result, 'get_weather');
```

### Quick checks and missing fields

Need a lightweight guard for scripts? `isTemplateValid(template, schema)` returns a boolean, while `getMissingFields(template, schema)` hands back just the failing paths—perfect for custom lint rules or editor diagnostics.

<Warning>
Template validation complements, not replaces, escaping. Continue to run `ctx.helpers.escapeHtml` for user-provided fields even when validators pass; you are checking schema parity, not sanitizing strings.
</Warning>
