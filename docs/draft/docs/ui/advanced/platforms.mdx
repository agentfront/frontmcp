---
title: Platform Support
sidebarTitle: Platforms
icon: globe
description: FrontMCP UI adapts to different AI platform capabilities. Each platform has different constraints for widget rendering.
---

## Platform Capabilities

| Platform        | Network | External Scripts    | Widget Modes            | Response Format    |
| --------------- | ------- | ------------------- | ----------------------- | ------------------ |
| **OpenAI**      | Open    | CDN allowed         | inline, fullscreen, pip | `_meta['ui/html']` |
| **ext-apps**    | Open    | CDN allowed         | inline, fullscreen, pip | `_meta['ui/html']` |
| **Cursor**      | Open    | CDN allowed         | inline                  | `_meta['ui/html']` |
| **Claude**      | Blocked | Cloudflare CDN only | Artifacts               | Dual-payload       |
| **Continue**    | Limited | Inline only         | inline                  | `_meta['ui/html']` |
| **Cody**        | Limited | Inline only         | inline                  | `_meta['ui/html']` |
| **Gemini**      | Limited | Inline preferred    | Basic                   | JSON only          |
| **generic-mcp** | Varies  | CDN/Inline          | inline, static          | `_meta['ui/html']` |

## Build Modes & Data Injection

FrontMCP supports three build modes that behave differently per platform:

| Mode        | OpenAI             | Claude/Other  |
| ----------- | ------------------ | ------------- |
| **static**  | Data baked in      | Data baked in |
| **dynamic** | Event subscription | Placeholders  |
| **hybrid**  | Placeholders       | Placeholders  |

For OpenAI, **dynamic mode** subscribes to `window.openai.canvas.onToolResult` for real-time updates.
For Claude and other platforms, **dynamic mode** uses placeholders that must be replaced before sending.

<Card title="Build Modes Documentation" icon="hammer" href="/docs/ui/advanced/build-modes">
  Learn about static, dynamic, and hybrid build modes with platform-aware data injection.
</Card>

## Platform Detection

FrontMCP automatically detects the platform:

```typescript
import { getPlatform, OPENAI_PLATFORM, CLAUDE_PLATFORM } from '@frontmcp/uipack/theme';

// Auto-detect from user agent or context
const platform = getPlatform();

// Check capabilities
if (platform.network === 'open') {
  // Can fetch external resources
}

if (platform.scripts === 'inline') {
  // Must inline all scripts
}
```

## ext-apps (SEP-1865)

ext-apps is the MCP Apps Extension protocol that standardizes bidirectional widget communication across AI hosts.

### Features

- Full network access
- JSON-RPC 2.0 over postMessage
- Bidirectional communication (widget â†” host)
- Tool invocation from widgets
- Model context updates
- Dynamic tool registration
- Widget logging

### Configuration

```typescript
import { EXT_APPS_PLATFORM } from '@frontmcp/uipack/theme';

// Platform preset
console.log(EXT_APPS_PLATFORM);
// {
//   id: 'ext-apps',
//   network: 'open',
//   scripts: 'external',
//   capabilities: {
//     callTool: true,        // Depends on serverToolProxy
//     sendMessage: true,
//     openExternal: true,    // Depends on openLink capability
//     requestDisplayMode: true,
//     widgetState: true,
//     updateModelContext: true,  // Depends on modelContextUpdate
//     registerTool: true,    // Depends on widgetTools
//   },
// }
```

### Host Capabilities

ext-apps uses capability negotiation during initialization. The host advertises supported features:

```typescript
interface ExtAppsHostCapabilities {
  serverToolProxy?: boolean;    // Can proxy tool calls to MCP server
  openLink?: boolean;           // Can open external URLs
  modelContextUpdate?: boolean; // Supports model context updates
  widgetTools?: boolean;        // Supports widget-defined tools
  displayModes?: ('inline' | 'fullscreen' | 'pip')[];
  logging?: boolean;            // Supports widget logging
}
```

### JSON-RPC Communication

ext-apps widgets communicate via JSON-RPC 2.0 over postMessage:

```typescript
// Widget sends request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "ui/callServerTool",
  "params": { "name": "get_weather", "arguments": { "city": "NYC" } }
}

// Host responds
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": { "temperature": 72, "conditions": "Sunny" }
}
```

### Tool Discovery Metadata

Tools with UI templates expose ext-apps metadata in `tools/list`:

```typescript
@Tool({
  name: 'weather',
  ui: {
    template: WeatherWidget,
    resourceUri: 'ui://my-app/weather.html',  // Custom URI (optional)
    widgetCapabilities: {
      toolListChanged: false,
      supportsPartialInput: true,
    },
  },
})
```

The discovery response includes:

```json
{
  "ui/resourceUri": "ui://my-app/weather.html",
  "ui/capabilities": {
    "toolListChanged": false,
    "supportsPartialInput": true
  }
}
```

### MIME Types

ext-apps uses specific MIME types:

```typescript
import { getExtAppsMimeType } from '@frontmcp/uipack/adapters';

getExtAppsMimeType('standard');  // 'text/html+mcp'
getExtAppsMimeType('profile');   // 'text/html;profile=mcp-app'
```

## OpenAI

OpenAI's Apps SDK provides full widget capabilities:

### Features

- Full network access
- External CDN scripts (Tailwind, HTMX)
- Multiple display modes (inline, fullscreen, pip)
- Theme detection
- Tool invocation from widgets
- Widget state persistence

### Configuration

```typescript
import { OPENAI_PLATFORM } from '@frontmcp/uipack/theme';

// Platform preset
console.log(OPENAI_PLATFORM);
// {
//   id: 'openai',
//   network: 'open',
//   scripts: 'external',
//   capabilities: {
//     callTool: true,
//     sendMessage: true,
//     openExternal: true,
//     requestDisplayMode: true,
//     widgetState: true,
//   },
// }
```

### Runtime API

OpenAI exposes `window.openai`:

```typescript
// Properties
window.openai.theme         // 'light' | 'dark'
window.openai.displayMode   // 'inline' | 'fullscreen' | 'pip'
window.openai.toolInput     // Tool input arguments
window.openai.toolOutput    // Tool output/result
window.openai.userAgent     // Device info

// Methods
window.openai.callTool(name, args)        // Call MCP tool
window.openai.sendFollowUpMessage({ prompt }) // Send chat message
window.openai.openExternal({ href })      // Open link
window.openai.requestDisplayMode({ mode }) // Change display mode
window.openai.setWidgetState(state)       // Persist state
```

## Claude

Claude uses Artifacts with restricted capabilities and a special **dual-payload** response format.

### Constraints

- **Network blocked** - Cannot fetch most external resources
- **Cloudflare CDN allowed** - Resources from `cdnjs.cloudflare.com` are trusted
- **Limited interactivity** - No tool invocation from widgets

### Dual-Payload Response Format

When `servingMode: 'auto'` detects a Claude client, FrontMCP returns a special two-block response:

````json
{
  "content": [
    { "type": "text", "text": "{\"temperature\":72,\"unit\":\"F\"}" },
    { "type": "text", "text": "Here is the visual result:\n\n```html\n<!DOCTYPE html>...\n```" }
  ]
}
````

- **Block 0**: Pure JSON data for programmatic parsing
- **Block 1**: Markdown-wrapped HTML that Claude displays as an Artifact

Claude automatically detects the `html` code fence and offers to render it as an interactive Artifact.

### Customizing the HTML Prefix

Control the text shown before the HTML block:

````typescript
@Tool({
  name: 'get_weather',
  ui: {
    template: WeatherWidget,
    htmlResponsePrefix: 'Here is the weather dashboard',
  },
})
// Output: "Here is the weather dashboard:\n\n```html\n..."
````

Default: `'Here is the visual result'`

### Cloudflare CDN for Tailwind

Claude trusts resources from `cdnjs.cloudflare.com`. FrontMCP uses pre-built Tailwind CSS from Cloudflare:

```typescript
// Pre-built Tailwind CSS (loaded automatically with resourceMode: 'cdn')
const TAILWIND_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css';
```

<Warning>
Other CDNs like `esm.sh`, `unpkg.com`, and `jsdelivr.net` are blocked by Claude's CSP. Only use `cdnjs.cloudflare.com` for maximum compatibility.
</Warning>

### resourceMode Configuration

Control how external resources are loaded:

```typescript
ui: {
  template: MyWidget,
  resourceMode: 'cdn',    // Load from Cloudflare CDN (default)
  // or
  resourceMode: 'inline', // Embed all scripts in HTML (fully offline)
}
```

### Configuration

```typescript
import { CLAUDE_PLATFORM } from '@frontmcp/uipack/theme';

// Platform preset
console.log(CLAUDE_PLATFORM);
// {
//   id: 'claude',
//   network: 'blocked',
//   scripts: 'inline',
//   capabilities: {
//     callTool: false,
//     sendMessage: false,
//     openExternal: true,
//     requestDisplayMode: false,
//     widgetState: false,
//   },
// }
```

### Handling Fully Blocked Networks

For environments without any network access, inline all scripts:

```typescript
import { baseLayout } from '@frontmcp/ui/layouts';
import { fetchAndCacheScriptsFromTheme } from '@frontmcp/uipack/theme';

// Pre-fetch and cache scripts at startup
await fetchAndCacheScriptsFromTheme(theme);

// Then build with inline scripts
const html = baseLayout({
  content: '...',
  theme,
  platform: 'claude',
  scripts: true, // Will inline cached scripts
});
```

## Gemini

Gemini has limited widget support:

### Configuration

```typescript
import { GEMINI_PLATFORM } from '@frontmcp/uipack/theme';

// Platform preset
console.log(GEMINI_PLATFORM);
// {
//   id: 'gemini',
//   network: 'limited',
//   scripts: 'inline',
//   capabilities: {
//     callTool: false,
//     sendMessage: false,
//     openExternal: true,
//     requestDisplayMode: false,
//     widgetState: false,
//   },
// }
```

### Best Practices

For Gemini, keep widgets simple:

- Use inline styles
- Avoid complex interactivity
- Focus on data display

## Platform-Aware Templates

Create templates that adapt to the platform:

```typescript
import { getPlatform, canUseCdn, needsInlineScripts } from '@frontmcp/uipack/theme';

@Tool({
  name: 'my_tool',
  ui: {
    template: (ctx) => {
      const platform = getPlatform();

      // Use CDN on capable platforms
      const useExternalScripts = canUseCdn(platform);

      // Build appropriate HTML
      return buildWidgetHtml({
        content: ctx.output,
        inlineScripts: needsInlineScripts(platform),
        useExternalScripts,
      });
    },
  },
})
```

## Fallback Modes

Handle missing capabilities gracefully:

```typescript
import { supportsFullInteractivity, getFallbackMode } from '@frontmcp/uipack/theme';

const platform = getPlatform();

if (supportsFullInteractivity(platform)) {
  // Full widget with tool calls
  return interactiveWidget(ctx);
} else {
  // Static display only
  const fallback = getFallbackMode(platform);
  return staticWidget(ctx, fallback);
}
```

## Custom Platforms

Define custom platform configurations:

```typescript
import { createPlatform } from '@frontmcp/uipack/theme';

const myPlatform = createPlatform({
  id: 'my-platform',
  network: 'open',
  scripts: 'external',
  capabilities: {
    callTool: true,
    sendMessage: true,
    openExternal: true,
    requestDisplayMode: false,
    widgetState: true,
  },
});
```

## Content Security Policy

Configure CSP based on platform:

```typescript
@Tool({
  name: 'my_tool',
  ui: {
    template: ...,
    csp: {
      // OpenAI: Allow CDNs
      connectDomains: ['api.example.com'],
      resourceDomains: ['cdn.example.com', 'fonts.googleapis.com'],
    },
  },
})
```

For Claude (blocked network), CSP is largely irrelevant since external resources can't be fetched anyway.

## Testing Across Platforms

Test your widgets on each platform:

```typescript
// Mock platform for testing
import { getPlatform } from '@frontmcp/uipack/theme';

// Override for testing
jest.mock('@frontmcp/uipack/theme', () => ({
  ...jest.requireActual('@frontmcp/uipack/theme'),
  getPlatform: jest.fn().mockReturnValue({
    id: 'claude',
    network: 'blocked',
    scripts: 'inline',
  }),
}));
```

## Best Practices

1. **Design for constraints** - Start with Claude's limitations, enhance for OpenAI
2. **Progressive enhancement** - Add features based on platform capabilities
3. **Test on all platforms** - Verify appearance and functionality
4. **Cache scripts** - Pre-fetch for blocked-network platforms
5. **Provide fallbacks** - Graceful degradation when features unavailable
6. **Document platform differences** - Help users understand what to expect
