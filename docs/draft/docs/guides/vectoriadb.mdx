---
title: Semantic Search with VectoriaDB
slug: guides/vectoriadb
description: Index your FrontMCP tools with VectoriaDB or the zero-dependency TF-IDF engine to power on-device semantic discovery.
icon: magnifying-glass
---

VectoriaDB is FrontMCP's in-memory vector database built on transformers.js. It now ships with two complementary engines:

- **VectoriaDB (ML embeddings)** for high-recall semantic search with cosine similarity, metadata filters, persistence, and optional HNSW acceleration.
- **TFIDFVectoria** for ultra-lightweight deployments that cannot download a model but still need ranked search.

Use them to suggest the right tool, snippet, or knowledge-base entry without leaking data to third-party services.

<CardGroup cols={3}>
  <Card title="Offline embeddings" icon="bolt">
    Run Xenova transformers entirely on your server, with no API keys and no request latency.
  </Card>
  <Card title="Zero-dependency fallback" icon="feather">
    TF-IDF indexing works anywhere (even CI) and is the default strategy used by the CodeCall plugin.
  </Card>
  <Card title="Operational guardrails" icon="shield">
    Rate limits, batch validation, storage adapters, and HNSW indices keep the index production ready.
  </Card>
</CardGroup>

## What you'll build

- A typed document shape for every tool, adapter, or document you want to search.
- An indexing routine that stays in sync with `toolRegistry.getTools(true)`.
- Natural-language queries with metadata filters, thresholds, and pagination.
- Optional persistence so restarts do not require re-embedding everything.
- Tuned performance knobs (HNSW, TF-IDF reindexing, limits).

<Note>
  The default Xenova `all-MiniLM-L6-v2` model is about 22 MB. The first initialization downloads and caches it under `cacheDir`;
  subsequent boots reuse the local copy. The TF-IDF engine requires no downloads at all.
</Note>

## Prerequisites

- Node.js 22 or later (Node 24 is recommended and is what FrontMCP tests against).
- A FrontMCP server with at least one app and tool registry.
- Ability to install npm packages (plus optional write access for cache directories).

## Install the library

<CodeGroup>
```bash npm
npm install vectoriadb
```
```bash pnpm
pnpm add vectoriadb
```
```bash yarn
yarn add vectoriadb
```
</CodeGroup>

## Option A - ML embeddings with VectoriaDB

```ts
import { VectoriaDB, DocumentMetadata } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  owner: string;
  tags: string[];
  risk: 'safe' | 'destructive';
}

export const toolIndex = new VectoriaDB<ToolDocument>({
  cacheDir: './.cache/transformers',
  defaultSimilarityThreshold: 0.45,
  useHNSW: true,
  hnsw: { M: 16, efConstruction: 200, efSearch: 64 },
});

await toolIndex.initialize(); // downloads and warms the embedding model once
```

`initialize()` must run before calling `add`, `search`, or `update`. Calling it twice is safe; VectoriaDB short-circuits when it is already ready.

## Option B - zero-dependency TF-IDF indexing

```ts
import { TFIDFVectoria, DocumentMetadata } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  owner: string;
  tags: string[];
}

export const toolIndex = new TFIDFVectoria<ToolDocument>({
  defaultTopK: 10,
  defaultSimilarityThreshold: 0,
});

toolIndex.addDocuments([
  {
    id: 'crm.users:list',
    text: 'List CRM users filtered by role or status',
    metadata: {
      id: 'crm.users:list',
      toolName: 'crm.users:list',
      owner: 'crm',
      tags: ['crm', 'users'],
    },
  },
]);

toolIndex.reindex(); // build the TF-IDF matrix (call after bulk changes)
```

Use TF-IDF when you cannot download ML models (CI, offline dev boxes, restricted tenants) but still want ranked search. You can mix and match strategies per environment by reading from configuration.

<Tip>
  The CodeCall plugin uses TF-IDF by default. Flip to ML embeddings by setting `embedding.strategy: 'ml'` when initializing the plugin.
</Tip>

## Step 2: Index your tools

Collect metadata from the tool registry and write it into the database. Each document needs a unique `id`, searchable `text`, and metadata extending `DocumentMetadata`.

```ts
import type { ToolEntry, ToolRegistryInterface } from '@frontmcp/sdk';

function collectToolDocuments(tools: ToolEntry[]): Array<{ id: string; text: string; metadata: ToolDocument }> {
  return tools.map((tool) => {
    const docId = `${tool.owner.id}:${tool.name}`;
    return {
      id: docId,
      text: [
        tool.metadata.description ?? tool.name,
        `Inputs: ${Object.keys(tool.metadata.inputSchema ?? {}).join(', ') || 'none'}`,
        `Tags: ${(tool.metadata.tags ?? []).join(', ') || 'none'}`,
      ].join('\n'),
      metadata: {
        id: docId,
        toolName: tool.name,
        owner: tool.owner.id,
        tags: tool.metadata.tags ?? [],
        risk: tool.metadata.annotations?.destructiveHint ? 'destructive' : 'safe',
      },
    };
  });
}

export async function indexTools(toolRegistry: ToolRegistryInterface) {
  const tools = toolRegistry.getTools(true); // include hidden tools
  await toolIndex.addMany(collectToolDocuments(tools));
}
```

`addMany` validates every document, enforces `maxBatchSize`, and prevents duplicates.

## Step 3: Run semantic search

```ts
const matches = await toolIndex.search('reset a billing password', {
  topK: 5,
  threshold: 0.45,
  filter: (metadata) => metadata.owner === 'billing' && !metadata.tags.includes('deprecated'),
});

for (const match of matches) {
  console.log(`${match.metadata.toolName} (${match.score.toFixed(2)})`);
}
```

`search` returns the best matches sorted by cosine similarity (VectoriaDB) or TF-IDF score. Use `filter` to enforce authorization, `includeVector` to inspect raw vectors, and `threshold` to drop low-confidence hits.

<Tip>
  Keep the index current with `updateMetadata`, `update`, or `updateMany`. Metadata-only updates never trigger re-embedding, while text changes re-embed only the affected documents.
</Tip>

## Persist embeddings between restarts

Swap the default in-memory adapter with a file or Redis adapter plus a deterministic tools hash.

```ts
import { FileStorageAdapter, createToolsHash, VectoriaDB } from 'vectoriadb';

export async function warmToolIndex(toolRegistry: ToolRegistryInterface) {
  const documents = collectToolDocuments(toolRegistry.getTools(true));

  const toolIndex = new VectoriaDB<ToolDocument>({
    storageAdapter: new FileStorageAdapter({
      cacheDir: './.cache/vectoriadb',
      namespace: 'tool-index',
    }),
    toolsHash: createToolsHash(documents),
    version: process.env.npm_package_version,
  });

  await toolIndex.initialize();

  if (toolIndex.size() === 0) {
    await toolIndex.addMany(documents);
    await toolIndex.saveToStorage();
  }

  return toolIndex;
}
```

`toolsHash` automatically invalidates the cache when your tool list or descriptions change. Call `saveToStorage()` after indexing; `initialize()` loads the cache on the next boot.

<Note>
  Need a shared cache across pods? Swap in `RedisStorageAdapter` with your preferred Redis client and namespace. TTLs and key prefixes are configurable per adapter.
</Note>

## Scale and tune search

- Enable `useHNSW` when you have more than 10k documents. HNSW provides sub-millisecond queries with more than 95 percent recall.
- Adjust `threshold` and `topK` for each query to trade recall for precision.
- Guard resource usage with `maxDocuments`, `maxDocumentSize`, and `maxBatchSize`.
- TF-IDF indexes recompute synchronously; call `reindex()` after large batch updates to refresh the matrix.

```ts
const toolIndex = new VectoriaDB<ToolDocument>({
  useHNSW: true,
  hnsw: { M: 16, efConstruction: 200, efSearch: 64 },
  maxDocuments: 150_000,
  maxBatchSize: 2_000,
});
```

## Handle errors and monitor health

All errors extend `VectoriaError` and ship with machine-readable `code` values.

```ts
import {
  VectoriaError,
  VectoriaNotInitializedError,
  DocumentValidationError,
} from 'vectoriadb';

try {
  await toolIndex.add(doc.id, doc.text, doc.metadata);
} catch (error) {
  if (error instanceof VectoriaNotInitializedError) {
    await toolIndex.initialize();
  } else if (error instanceof DocumentValidationError) {
    console.warn({ tool: error.documentId }, 'invalid document skipped');
  } else if (error instanceof VectoriaError) {
    console.error({ code: error.code }, error.message);
    throw error;
  } else {
    throw error;
  }
}
```

Use `toolIndex.getStats()` for dashboards or health endpoints:

```ts
const stats = toolIndex.getStats();
/*
{
  totalEmbeddings: number;
  dimensions: number;
  estimatedMemoryBytes: number;
  modelName: string;
}
*/
```

<Info>
  Pair stats with `toolIndex.size()`, `toolIndex.clear()`, and `toolIndex.clearStorage()` to expose maintenance commands or admin tooling.
</Info>
