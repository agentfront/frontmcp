---
title: Secure Code Execution with Enclave
slug: guides/enclave
description: Execute untrusted JavaScript safely using Enclave's defense-in-depth security model combining AST validation, code transformation, and runtime sandboxing.
icon: shield-halved
---

Enclave is FrontMCP's secure execution environment for running untrusted JavaScript code. It provides a defense-in-depth security model that combines AST validation (via ast-guard), code transformation, and runtime sandboxing to safely execute model-generated code.

<CardGroup cols={3}>
  <Card title="AST Validation" icon="shield-check">
    Block dangerous constructs before execution using ast-guard's AgentScript preset
  </Card>
  <Card title="Code Transformation" icon="arrows-rotate">
    Automatically transform code for safe execution with proxied functions and loop limits
  </Card>
  <Card title="Runtime Sandboxing" icon="lock">
    Execute in isolated Node.js vm context with controlled globals and resource limits
  </Card>
</CardGroup>

## When to Use Enclave

Enclave is designed for scenarios where you need to execute JavaScript code from untrusted sources:

- **LLM-generated code** - Execute code written by AI models safely
- **User-provided scripts** - Run user scripts in a controlled environment
- **Plugin/extension systems** - Allow third-party code to run securely
- **Workflow automation** - Execute orchestration logic with tool access

<Note>
  Enclave is used internally by the [CodeCall Plugin](/docs/plugins/codecall-plugin) to execute JavaScript execution plans. You can also use it directly for custom use cases.
</Note>

## Installation

Enclave is available as a separate package:

<CodeGroup>
```bash npm
npm install @frontmcp/enclave
```
```bash pnpm
pnpm add @frontmcp/enclave
```
```bash yarn
yarn add @frontmcp/enclave
```
</CodeGroup>

## Quick Start

```ts
import { Enclave } from '@frontmcp/enclave';

// Create an enclave with a tool handler
const enclave = new Enclave({
  timeout: 5000, // 5 second timeout
  maxToolCalls: 50, // Max 50 tool calls
  maxIterations: 10000, // Max 10K loop iterations
  toolHandler: async (toolName, args) => {
    // Handle tool calls from the script
    console.log(`Tool called: ${toolName}`, args);
    return { result: 'data' };
  },
});

// Execute AgentScript code
const code = `
  const users = await callTool('users:list', { limit: 10 });
  const filtered = users.filter(u => u.active);
  return filtered.length;
`;

const result = await enclave.run(code);

if (result.success) {
  console.log('Result:', result.value);
  console.log('Stats:', result.stats);
} else {
  console.error('Error:', result.error);
}

// Clean up
enclave.dispose();
```

## Defense-in-Depth Security Model

Enclave uses a four-layer security approach:

### Layer 1: AST Validation

Before any code runs, Enclave validates the AST using ast-guard's AgentScript preset:

```ts
// These are automatically blocked:
eval('code');                    // ❌ eval blocked
new Function('return 1')();       // ❌ Function constructor blocked
setTimeout(() => {}, 100);        // ❌ setTimeout blocked
process.exit();                   // ❌ process access blocked
window.location;                  // ❌ window access blocked
this.constructor;                 // ❌ this access blocked
```

The AgentScript preset blocks:

| Category                   | Blocked Constructs                                                 |
| -------------------------- | ------------------------------------------------------------------ |
| **Eval-like**              | `eval`, `Function`, `setTimeout`, `setInterval`                    |
| **Globals**                | `process`, `require`, `window`, `document`, `global`, `globalThis` |
| **Context access**         | `this`, `self`, `parent`, `top`, `frames`                          |
| **Prototype manipulation** | `__proto__`, `constructor`, `prototype` access                     |

### Layer 2: Code Transformation

Valid code is transformed for safe execution:

```ts
// Original code:
const users = await callTool('users:list', {});
for (const user of users) {
  console.log(user.name);
}

// Transformed code:
async function __ag_main() {
  const users = await __safe_callTool('users:list', {});
  __safe_forOf(users, (user) => {
    __safe_console.log(user.name);
  });
}
```

Transformations include:

- **Main wrapper**: Wrap code in `async function __ag_main()` for top-level await
- **Safe callTool**: Transform `callTool` → `__safe_callTool` (proxied through Enclave)
- **Safe loops**: Transform `for`, `while`, `do-while` → safe versions with iteration limits
- **Safe console**: Transform `console` → `__safe_console` (captured for logging)

### Layer 3: Runtime Sandboxing

Code executes in an isolated Node.js vm context:

- **Isolated context**: Fresh context with no access to host environment
- **Controlled globals**: Only whitelisted globals available (`Math`, `JSON`, `Array`, etc.)
- **Resource limits**: Timeout, iteration count, and tool call limits enforced
- **Stack sanitization**: Error stack traces sanitized to prevent information leakage

### Layer 4: Reference Sidecar (Optional)

When enabled, large data is handled separately:

- **Large data extraction**: Strings exceeding the threshold are stored in sidecar storage
- **Reference tokens**: Large strings are replaced with safe reference tokens (`__ref_abc123`)
- **Lazy resolution**: Data is only resolved when explicitly accessed
- **Composite blocking**: String concatenation with references can be blocked (`allowComposites: false`)

## Configuration Options

<ParamField path="timeout" type="number" default="30000">
  Maximum execution time in milliseconds (default 30 seconds)
</ParamField>

<ParamField path="maxToolCalls" type="number" default="100">
  Maximum number of tool calls allowed per execution
</ParamField>

<ParamField path="maxIterations" type="number" default="10000">
  Maximum loop iterations allowed (prevents infinite loops)
</ParamField>

<ParamField path="toolHandler" type="function">
  Async function that handles `callTool()` invocations from the script.
  Signature: `(toolName: string, args: Record<string, unknown>) => Promise<unknown>`
</ParamField>

<ParamField path="globals" type="object">
  Additional globals to make available in the script context
</ParamField>

<ParamField path="validate" type="boolean" default="true">
  Whether to validate code with ast-guard before execution
</ParamField>

<ParamField path="transform" type="boolean" default="true">
  Whether to transform code before execution
</ParamField>

<ParamField path="allowFunctionsInGlobals" type="boolean" default="false">
  Allow functions in the `globals` object. Required when providing callback functions or utilities.
</ParamField>

<ParamField path="sidecar" type="object">
  Configuration for handling large data via reference tokens

  <Expandable title="properties">
    <ResponseField name="enabled" type="boolean" default="false">
      Enable the sidecar feature for large data handling
    </ResponseField>
    <ResponseField name="maxTotalSize" type="number" default="10485760">
      Maximum total size of all stored references in bytes (default 10MB)
    </ResponseField>
    <ResponseField name="maxReferenceSize" type="number" default="1048576">
      Maximum size of a single reference in bytes (default 1MB)
    </ResponseField>
    <ResponseField name="extractionThreshold" type="number" default="1024">
      Minimum string size to extract to sidecar. Smaller strings stay inline.
    </ResponseField>
    <ResponseField name="maxResolvedSize" type="number" default="5242880">
      Maximum size when resolving references (default 5MB)
    </ResponseField>
    <ResponseField name="allowComposites" type="boolean" default="false">
      Allow string concatenation with reference tokens. Keep `false` for security.
    </ResponseField>
  </Expandable>
</ParamField>

## Reference Sidecar

The sidecar is a powerful feature for handling large data in AgentScript without embedding it in the script. This keeps script size small for reliable AST validation while allowing tools to return large datasets.

### How It Works

1. **Extraction**: When a tool returns data with large strings (> `extractionThreshold`), those strings are stored in the sidecar and replaced with reference tokens (`__ref_abc123`)
2. **Lazy Resolution**: When script code accesses a reference token, it's resolved just-in-time to the actual data
3. **Safe Property Access**: Only explicit property accesses trigger resolution, preventing data exfiltration

```ts
const enclave = new Enclave({
  toolHandler: async (name, args) => {
    if (name === 'documents:get') {
      // Returns a 2MB document - automatically stored in sidecar
      return { content: '...2MB of text...' };
    }
  },
  sidecar: {
    enabled: true,
    extractionThreshold: 1024,    // Extract strings > 1KB
    allowComposites: false,        // Block: ref + "_suffix" (security)
  },
});

const result = await enclave.run(`
  const doc = await callTool('documents:get', { id: 'doc-123' });
  // doc.content is a reference token, resolved on access
  return { wordCount: doc.content.split(' ').length };
`);
```

### Security: allowComposites

The `allowComposites: false` setting (default) blocks string concatenation with reference tokens:

```js
// When allowComposites: false (default, secure)
const result = ref + "_suffix";  // ❌ BLOCKED - prevents prototype pollution

// When allowComposites: true (less secure)
const result = ref + "_suffix";  // ✅ ALLOWED - use with caution
```

Keep `allowComposites: false` unless you specifically need string concatenation with large data.

## Execution Results

Enclave returns a structured result with success/error status and execution stats:

```ts
interface ExecutionResult<T> {
  success: boolean;
  value?: T;              // Result value (if success)
  error?: {               // Error details (if failed)
    name: string;
    message: string;
    code: string;
    stack?: string;
  };
  stats: {
    duration: number;      // Execution time in ms
    toolCallCount: number; // Number of tool calls made
    iterationCount: number; // Number of loop iterations
  };
}
```

### Error Codes

| Code               | Meaning                    | Action                                |
| ------------------ | -------------------------- | ------------------------------------- |
| `VALIDATION_ERROR` | AST validation failed      | Fix the code - blocked construct used |
| `EXECUTION_ERROR`  | Runtime error in script    | Fix script logic                      |
| `TIMEOUT`          | Execution exceeded timeout | Optimize or increase timeout          |
| `TOOL_ERROR`       | Tool call failed           | Check tool input/availability         |

## Advanced Usage

### Custom Globals

Provide custom globals for scripts to access:

```ts
const enclave = new Enclave({
  toolHandler: async (name, args) => { /* ... */ },
  globals: {
    // Custom read-only context
    context: {
      userId: 'user-123',
      tenantId: 'tenant-456',
    },
    // Custom utility function
    formatDate: (date: Date) => date.toISOString(),
  },
});

const code = `
  const userId = context.userId;
  const timestamp = formatDate(new Date());
  return { userId, timestamp };
`;

const result = await enclave.run(code);
```

### One-Shot Execution

For simple cases, use the convenience function:

```ts
import { runAgentScript } from '@frontmcp/enclave';

const result = await runAgentScript(`
  return Math.max(1, 2, 3);
`, {
  timeout: 1000,
});

console.log(result.value); // 3
```

### Tool Handler Integration

Integrate with your existing tool system:

```ts
import { Enclave } from '@frontmcp/enclave';
import { ToolRegistry } from './tools';

const enclave = new Enclave({
  timeout: 10000,
  toolHandler: async (toolName, args) => {
    // Look up tool in registry
    const tool = ToolRegistry.get(toolName);
    if (!tool) {
      throw new Error(`Unknown tool: ${toolName}`);
    }

    // Execute with your pipeline (auth, logging, etc.)
    return tool.execute(args);
  },
});
```

## Security Considerations

<Warning>
  While Enclave provides strong security guarantees, it should be used as part of a defense-in-depth strategy. Always:
  - Validate tool inputs before execution
  - Limit what tools are available to scripts
  - Monitor execution for anomalies
  - Keep Enclave and ast-guard updated
</Warning>

### What Enclave Protects Against

- **Code injection** - Blocked by AST validation
- **Infinite loops** - Limited by `maxIterations`
- **Resource exhaustion** - Limited by `timeout` and `maxToolCalls`
- **Global access** - Blocked by AST validation and isolated context
- **Prototype pollution** - Blocked by AST validation
- **Information leakage** - Stack traces sanitized

### What Enclave Does NOT Protect Against

- **Tool abuse** - Scripts can call allowed tools; limit what's available
- **Algorithmic complexity** - Scripts can run O(n²) algorithms within limits
- **Memory exhaustion** - Large arrays/objects within timeout
- **Side effects** - Tool calls have real effects; use read-only tools where possible

## Integration with CodeCall

The [CodeCall Plugin](/docs/plugins/codecall-plugin) uses Enclave internally:

```ts
// CodeCall plugin configuration maps to Enclave
CodeCallPlugin.init({
  enclave: {
    timeoutMs: 5000,
    maxToolCalls: 100,
    maxIterations: 10000,
    allowConsole: true,
  },
});

// Equivalent to:
new Enclave({
  timeout: 5000,
  maxToolCalls: 100,
  maxIterations: 10000,
  globals: {
    console: { log: ..., warn: ..., error: ... },
  },
});
```

## Resources

<CardGroup cols={2}>
  <Card title="AST Guard Guide" icon="shield-check" href="/docs/guides/ast-guard">
    Learn about ast-guard's validation rules and presets
  </Card>
  <Card title="CodeCall Plugin" icon="code" href="/docs/plugins/codecall-plugin">
    See Enclave in action with the CodeCall plugin
  </Card>
  <Card title="Source Code" icon="github" href="https://github.com/agentfront/frontmcp/tree/main/libs/enclave">
    View the Enclave source code
  </Card>
  <Card title="Security Audit" icon="file-shield" href="https://github.com/agentfront/frontmcp/blob/main/libs/enclave/SECURITY-AUDIT.md">
    Review the security audit documentation
  </Card>
</CardGroup>
