---
title: Redis Setup
description: Configure Redis for development and production deployments
---

# Redis Setup

FrontMCP uses Redis for caching, session storage, and distributed state management.

## Requirements

| Environment | Redis        | Notes                                    |
| ----------- | ------------ | ---------------------------------------- |
| Development | Recommended  | Enables full feature testing             |
| Production  | **Required** | Essential for multi-instance deployments |

## Development Setup

### Option 1: Docker Compose (Recommended)

Projects created with `frontmcp create --target node` include Docker files in the `ci/` folder:

```bash
# Start Redis
docker compose -f ci/docker-compose.yml up redis -d

# Verify Redis is running
docker compose -f ci/docker-compose.yml exec redis redis-cli ping

# Start the full stack (app + Redis)
docker compose -f ci/docker-compose.yml up
```

<Tip>
When running inside Docker, use `redis` (the service name) as `REDIS_HOST`, not `localhost`.
Projects created with `frontmcp create` include a `ci/.env.docker` file with Docker-specific values.
</Tip>

### Option 2: Local Installation

```bash
# macOS
brew install redis
brew services start redis

# Ubuntu/Debian
sudo apt install redis-server
sudo systemctl start redis
```

### Configuration

```typescript
import { CachePlugin } from '@frontmcp/plugins';

CachePlugin.init({
  type: 'redis',
  config: {
    host: process.env.REDIS_HOST || 'localhost',
    port: Number(process.env.REDIS_PORT || 6379),
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB || '0'),
    tls: process.env.REDIS_TLS === 'true',
  }
});
```

For complete CachePlugin API documentation, see the [Cache Plugin Guide](/docs/plugins/cache-plugin).

## Production Setup

<Warning>
Redis is **required** in production. Without Redis, session data will be lost on restart and caching will not persist across instances.
</Warning>

### Managed Redis Services (Recommended)

| Provider    | Service               |
| ----------- | --------------------- |
| AWS         | ElastiCache for Redis |
| GCP         | Memorystore for Redis |
| Azure       | Azure Cache for Redis |
| Upstash     | Serverless Redis      |
| Redis Cloud | Redis Enterprise      |

### Self-Hosted Production

For self-hosted Redis in production:

```yaml
# docker-compose.prod.yml
services:
  redis:
    image: redis:7-alpine
    command: >
      redis-server
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
    volumes:
      - redis-data:/data
    restart: unless-stopped
```

### Security Best Practices

1. **Authentication**: Always set `REDIS_PASSWORD` in production
2. **Network**: Run Redis in private network, not exposed to internet
3. **TLS**: Enable TLS for encrypted connections
4. **Persistence**: Use AOF for durability (`appendonly yes`)

### Configuration Example

```typescript
// src/main.ts
import 'reflect-metadata';
import { FrontMcp } from '@frontmcp/sdk';
import { CachePlugin } from '@frontmcp/plugins';

@FrontMcp({
  info: { name: 'My Server', version: '1.0.0' },
  plugins: [
    CachePlugin.init({
      type: 'redis',
      config: {
        host: process.env.REDIS_HOST,
        port: Number(process.env.REDIS_PORT || 6379),
        password: process.env.REDIS_PASSWORD,
        tls: process.env.REDIS_TLS === 'true',
      },
    }),
  ],
})
export default class Server {}
```

## Session persistence & recovery

Redis now powers long-lived Streamable HTTP sessions via `transport.persistence`. Configure Redis once and enable persistence to survive process restarts or horizontal scaling.

### Configuration

```ts title="src/main.ts"
@FrontMcp({
  info: { name: 'My Server', version: '1.0.0' },
  redis: {
    host: process.env.REDIS_HOST!,
    port: Number(process.env.REDIS_PORT || 6379),
    password: process.env.REDIS_PASSWORD,
    keyPrefix: 'mcp:transport:',
    defaultTtlMs: 3600000,
  },
  transport: {
    persistence: {
      enabled: true,
      defaultTtlMs: 3600000, // Override per environment
    },
  },
})
```

1. **Configure `redis`** once at the server level. The same connection is reused for auth token storage and persistence.
2. **Enable `transport.persistence`** to persist Streamable HTTP sessions. TTL defaults to one hourâ€”tune it based on how long clients stay connected.

<Warning>Transport persistence currently targets Streamable HTTP. SSE/stateful HTTP traffic continues to use in-memory transports.</Warning>

### Health checks and graceful degradation

FrontMCP now pings Redis during boot. If the connection fails, the session store is disabled and the server falls back to in-memory transports instead of crashing. Successful pings log `Redis connection validated successfully`; failures log a warning explaining that persistence was skipped.

<Tip>Watch for `[TransportService] Redis session store initialized` when enabling persistence. If you change Redis credentials, restart the server so the health check runs again.</Tip>

### Recovery flow

When persistence is enabled:

- **Creation**: Every Streamable HTTP transport stores an authorization hash, protocol, and timestamps inside Redis.
- **Lookup**: Incoming requests call `wasSessionCreatedAsync()` which now checks Redis via `getStoredSession()` before deciding whether to recreate or reject the session.
- **Recreation**: If a matching session exists, `recreateTransporter()` acquires a mutex, rebuilds the transport, and updates `lastAccessedAt`. If the token hash mismatches, the session is dropped and a warning is logged.

This allows users to refresh a client after a deploy without breaking long-running conversations, while still enforcing token integrity.

## Environment Variables

| Variable           | Required  | Default     | Description                                                                    |
| ------------------ | --------- | ----------- | ------------------------------------------------------------------------------ |
| `REDIS_HOST`       | Yes       | `localhost` | Redis server hostname                                                          |
| `REDIS_PORT`       | No        | `6379`      | Redis server port                                                              |
| `REDIS_PASSWORD`   | Prod only | -           | Redis authentication password                                                  |
| `REDIS_DB`         | No        | `0`         | Redis database number                                                          |
| `REDIS_TLS`        | No        | `false`     | Enable TLS encryption                                                          |
| `REDIS_KEY_PREFIX` | No        | `mcp:`      | Key prefix for cache namespacing (CachePlugin uses content hashing by default) |

## Health Checks

```typescript
import Redis from 'ioredis';

async function checkRedisHealth(): Promise<boolean> {
  const redis = new Redis({
    host: process.env.REDIS_HOST,
    port: Number(process.env.REDIS_PORT || 6379),
    password: process.env.REDIS_PASSWORD,
    lazyConnect: true,
  });

  try {
    await redis.connect();
    await redis.ping();
    await redis.quit();
    return true;
  } catch {
    return false;
  }
}
```

## Troubleshooting

### Connection Refused

- Verify Redis is running: `redis-cli ping`
- Check firewall rules
- Verify host/port configuration

### Authentication Failed

- Ensure `REDIS_PASSWORD` matches server config
- Check for special characters in password (may need URL encoding)

### Memory Issues

- Set `maxmemory` and `maxmemory-policy` in Redis config
- Monitor with `redis-cli INFO memory`

### Docker Network Issues

When using Docker Compose, the app container should use `redis` as the hostname (the service name), not `localhost`:

```bash
# Inside Docker container
REDIS_HOST=redis

# Outside Docker (local development)
REDIS_HOST=localhost
```
