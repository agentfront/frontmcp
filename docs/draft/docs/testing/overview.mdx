---
title: Testing
sidebarTitle: Overview
slug: testing/overview
icon: flask-vial
description: End-to-end testing framework for FrontMCP servers
---

`@frontmcp/testing` is the official testing library for FrontMCP, providing a complete toolkit for end-to-end testing of MCP servers. Test your tools, resources, prompts, authentication, plugins, and the full MCP protocol.

<Columns cols={3}>
  <Card title="Fixture-Based" icon="puzzle-piece">
    Playwright-inspired fixtures inject ready-to-use test clients
  </Card>
  <Card title="Full Protocol" icon="code">
    Test tools, resources, prompts, and raw JSON-RPC
  </Card>
  <Card title="Offline Testing" icon="wifi-slash">
    Mock HTTP calls for fully offline test suites
  </Card>
</Columns>

---

## Installation

```bash
npm install -D @frontmcp/testing
```

<Info>
  `@frontmcp/testing` requires `@frontmcp/sdk` as a peer dependency and uses Jest as the test runner.
</Info>

---

## Quick Start

### 1. Configure Jest

Create or update your `jest.e2e.config.ts`:

```ts title="jest.e2e.config.ts"
import type { Config } from 'jest';

const config: Config = {
  displayName: 'e2e',
  preset: '@frontmcp/testing/jest-preset',
  testMatch: ['**/*.e2e.ts'],
  testTimeout: 30000,
};

export default config;
```

### 2. Write Your First Test

```ts title="server.e2e.ts"
import { test, expect } from '@frontmcp/testing';

// Point to your FrontMCP server entry file
test.use({
  server: './src/main.ts',
  port: 3003,
});

test('server exposes tools', async ({ mcp }) => {
  const tools = await mcp.tools.list();
  expect(tools).toContainTool('my-tool');
});

test('tool execution works', async ({ mcp }) => {
  const result = await mcp.tools.call('my-tool', { input: 'test' });
  expect(result).toBeSuccessful();
  expect(result.json()).toHaveProperty('success', true);
});
```

### 3. Run Tests

```bash
# Using jest directly
npx jest --config jest.e2e.config.ts

# Using nx
nx e2e my-app
```

The library automatically:

- Starts your FrontMCP server on the specified port
- Connects an MCP client using Streamable-HTTP transport
- Runs your tests with injected fixtures
- Cleans up after all tests complete

---

## Key Features

### Fixture System

Tests receive pre-configured fixtures via dependency injection:

| Fixture  | Description                                               |
| -------- | --------------------------------------------------------- |
| `mcp`    | Auto-connected MCP client for making requests             |
| `server` | Server control (restart, logs, create additional clients) |
| `auth`   | Token factory for authentication testing                  |

```ts
test('example with all fixtures', async ({ mcp, server, auth }) => {
  // mcp: ready-to-use MCP client
  const tools = await mcp.tools.list();

  // auth: create test tokens
  const token = await auth.createToken({ sub: 'user-123', scopes: ['read'] });

  // server: create additional clients
  const client2 = await server.createClient({ token });
});
```

### Custom Jest Matchers

MCP-specific matchers for cleaner assertions:

```ts
// Tool matchers
expect(tools).toContainTool('create-note');

// Result matchers
expect(result).toBeSuccessful();
expect(result).toBeError(-32602);

// Content matchers
expect(result).toHaveTextContent();
expect(content).toHaveMimeType('application/json');

// Resource matchers
expect(resources).toContainResource('notes://all');
expect(templates).toContainResourceTemplate('notes://note/{id}');
```

### HTTP Mocking

Mock external HTTP calls made by your tools for offline testing:

```ts
import { httpMock } from '@frontmcp/testing';

test('tool with external API', async ({ mcp }) => {
  const interceptor = httpMock.interceptor();

  interceptor.get('https://api.example.com/users', {
    body: [{ id: 1, name: 'John' }],
  });

  const result = await mcp.tools.call('fetch-users', {});
  expect(result).toBeSuccessful();

  interceptor.restore();
});
```

### MCP Request Interception

Mock or modify MCP protocol requests:

```ts
test('mock tool response', async ({ mcp }) => {
  mcp.mock.tool('expensive-tool', { cached: true });

  const result = await mcp.tools.call('expensive-tool', {});
  expect(result.json()).toEqual({ cached: true });
});
```

---

## Test Configuration

Configure tests using `test.use()`:

```ts
test.use({
  // Server configuration
  server: './src/main.ts',    // Entry file path
  port: 3003,                  // Port (default: auto-select)
  startupTimeout: 30000,       // Startup timeout in ms

  // Transport
  transport: 'streamable-http', // 'sse' | 'streamable-http'

  // Authentication
  auth: {
    mode: 'public',            // 'public' | 'orchestrated'
    type: 'local',             // 'local' | 'remote'
  },

  // Debugging
  logLevel: 'debug',           // 'debug' | 'info' | 'warn' | 'error'
  env: { API_KEY: 'test' },    // Environment variables
});
```

<Tip>
  Use `port: 0` to automatically select an available port. This prevents conflicts when running multiple test suites in parallel.
</Tip>

---

## Demo reference stack

<Info>
FrontMCP now ships a single playground server plus scenario-specific Nx projects so you can copy realistic setups without reverse-engineering the repo history. Both stacks mirror the same provider, plugin, and transport patterns you will use in production.
</Info>

### apps/demo: hands-on playground

Spin up `apps/demo` when you want to poke at features manually in an MCP Inspector or Claude Desktop. The entry point (`apps/demo/src/main.ts`) wires multiple mini-apps you can toggle on and off by editing the `apps` array. Highlights include:

- **Weather UI** – richly designed `@frontmcp/ui` widgets that stream dual-payload responses for OpenAI, Claude, and ext-apps.
- **CRM + CodeCall** – CodeCall-only tools that showcase search/describe/execute flows with TF-IDF search defaults.
- **Expenses** – OpenAPI Adapter, prompts, resources, and Redis-backed cache plugin living side-by-side.
- **Employee time tracking** – Provider factories, site-level authorization plugin, and Redis session persistence.
- **Calculator** – Deterministic math tools cached behind the shared cache plugin for quick experiments.

```bash title="Run the playground server"
pnpm nx serve demo --port 3002
```

<Tip>
Uncomment additional apps in `apps/demo/src/main.ts` to focus on a specific domain, or fork the directory as your internal sandbox so you never prototype directly in production code.
</Tip>

### Scenario-focused e2e suites

Every capability now has a dedicated Nx project under `apps/e2e/<target>` with its own `src/main.ts` and Jest suite under `apps/e2e/<target>/e2e`. Run them individually to reproduce bugs or copy the spec files into your workspace.

| Nx target               | Focus area                                                                          | Quick command                        |
| ----------------------- | ----------------------------------------------------------------------------------- | ------------------------------------ |
| `demo-e2e-public`       | Anonymous/public auth with Streamable HTTP + JSON fallbacks                         | `pnpm nx test demo-e2e-public`       |
| `demo-e2e-orchestrated` | Built-in OAuth consent flow, incremental scopes, and session persistence            | `pnpm nx test demo-e2e-orchestrated` |
| `demo-e2e-transparent`  | Transparent auth that proxies remote IdPs while honoring local transport guards     | `pnpm nx test demo-e2e-transparent`  |
| `demo-e2e-ui`           | `@frontmcp/ui` renderers, dual-payload Claude output, and widget discovery metadata | `pnpm nx test demo-e2e-ui`           |
| `demo-e2e-codecall`     | CodeCall plugin meta-tools plus CRM orchestration scripts                           | `pnpm nx test demo-e2e-codecall`     |
| `demo-e2e-cache`        | CachePlugin hit/miss tracking, metrics resources, and prompts                       | `pnpm nx test demo-e2e-cache`        |
| `demo-e2e-openapi`      | OpenAPI Adapter generation with `MockAPIServer`-backed HTTP mocks                   | `pnpm nx test demo-e2e-openapi`      |
| `demo-e2e-redis`        | Redis session store recreation and corruption recovery                              | `pnpm nx test demo-e2e-redis`        |
| `demo-e2e-serverless`   | Vercel/Lambda/Workers packaging and cold-start safe checks                          | `pnpm nx test demo-e2e-serverless`   |

<Note>
Need a quick reference for UI matchers, auth fixtures, or hooks? Open the corresponding `apps/e2e/**/e2e/*.e2e.test.ts` file and copy the patterns wholesale. They already use the `test.use()` defaults documented above, so you can paste them into your own suite without extra wiring.
</Note>

```ts title="tests/demo-auth.e2e.ts"
import { test, expect, TestServer } from '@frontmcp/testing';

let serverProcess: TestServer | undefined;

test.beforeAll(async () => {
  serverProcess = await TestServer.startNx('demo-e2e-public', { port: 4001 });
});

test.afterAll(async () => {
  await serverProcess?.stop();
});

test('anonymous sessions resolve scoped tools', async ({ mcp }) => {
  const tools = await mcp.tools.list();
  expect(tools).toContainTool('public-status');
});
```

<Tip>
Pair the suites with `httpMock.interceptor()` or `server.createClient()` helpers when you need to stub upstream APIs or impersonate multiple MCP clients. The demos already include those helpers, giving you ready-made snippets for offline testing.
</Tip>

---

## Next Steps

<Columns cols={2}>
  <Card title="Test Fixtures" icon="puzzle-piece" href="/docs/testing/fixtures">
    Deep dive into the fixture system and available APIs
  </Card>
  <Card title="Custom Matchers" icon="check-double" href="/docs/testing/matchers">
    Full reference for all MCP-specific Jest matchers
  </Card>
  <Card title="Auth Testing" icon="key" href="/docs/testing/authentication">
    Test authentication flows with token generation
  </Card>
  <Card title="HTTP Mocking" icon="globe" href="/docs/testing/http-mocking">
    Mock external API calls for offline testing
  </Card>
</Columns>
