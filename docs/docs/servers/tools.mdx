---
title: Tools
slug: servers/tools
icon: wrench
---

Tools are **typed actions** your server can execute. They’re described with Zod schemas and exposed via MCP. Implement as a class with `@Tool({...})` or as a function via `tool()`.

## Minimal tool (class)

```ts
import { Tool } from '@frontmcp/sdk';
import { z } from 'zod';

@Tool({
  name: 'greet',
  description: 'Greets a user by name',
  inputSchema: { name: z.string() },
})
export default class GreetTool {
  async execute({ name }: { name: string }) {
    return `Hello, ${name}!`;
  }
}
```

Register it on an app:

```ts
@App({ id: 'hello', name: 'Hello', tools: [GreetTool] })
export default class HelloApp {}
```

## Inline tool (function builder)

```ts
import { tool } from '@frontmcp/sdk';
import { z } from 'zod';

export const Add = tool({
  name: 'add',
  description: 'Add two numbers',
  inputSchema: { a: z.number(), b: z.number() },
})((input) => input.a + input.b);
```

Add to app:

```ts
@App({ name: 'Calc', tools: [Add] })
class CalcApp {}
```

---

## Tool metadata

```ts
@Tool({
  id?: string,
  name: string,
  description?: string,
  inputSchema: { [key: string]: z.ZodTypeAny } | z.ZodObject<any>,
  rawInputSchema?: JSONSchema7,
  outputSchema?: 'string' | 'number' | 'boolean' | 'date' | 'image' | 'audio' | 'resource' | 'resource_link' | z.ZodTypeAny | readonly ('string' | 'number' | 'boolean' | 'date' | 'image' | 'audio' | 'resource' | 'resource_link' | z.ZodTypeAny)[],
  tags?: string[],
  annotations?: {
    title?: string,
    readOnlyHint?: boolean,
    destructiveHint?: boolean,
    idempotentHint?: boolean,
    openWorldHint?: boolean,
  },
  hideFromDiscovery?: boolean, // default false
})
```

**Notes**

- `annotations` hint model & UI behavior (read-only, idempotent, etc.).
- `hideFromDiscovery` keeps a tool callable but off `tool/list`.
- Tools can attach **per-tool hooks** (see _Advanced → Hooks_).
- `rawInputSchema` lets you share a JSON Schema version of the input (handy for inspector tooling) while still passing a raw Zod shape to `inputSchema`.

### Input & output schema shapes

`inputSchema` can be a full `z.object({...})` or a raw shape (`{ name: z.string() }`). The SDK wraps raw shapes in an object internally, so you can keep declarations terse.

`outputSchema` now accepts:

- Literal primitives (`'string'`, `'number'`, `'boolean'`, `'date'`) when you return scalars.
- `'image'`, `'audio'`, `'resource'`, or `'resource_link'` when you emit MCP resource descriptors.
- Any Zod schema (objects, unions, arrays, discriminated unions, etc.).
- An array of the above to build tuple-like content (each entry becomes a separate structured content item).

```ts
@Tool({
  name: 'add',
  description: 'Add two numbers and echo the math',
  inputSchema: { a: z.number(), b: z.number() },
  outputSchema: ['string', 'number'],
})
export default class AddTool {
  async execute({ a, b }: { a: number; b: number }) {
    const result = a + b;
    return [`${a} + ${b} = ${result}`, result];
  }
}
```

## Return values

- Return primitives, structured objects, or tuple-like arrays. When `outputSchema` is provided (literal or Zod), the SDK validates the response and propagates the right metadata to clients.
- Errors are surfaced via MCP error responses; you can also throw typed errors inside executors.
