name: "Codex ‚Üí PR: update Mintlify docs & changelog (next/*)"

on:
  push:
    branches:
      - "next/**"
    # Prevent loop: if a push ONLY touches these paths, Codex won't run
    paths-ignore:
      - "docs/**"
      - "CHANGELOG.md"
      - "libs/**/README.md"
      - "libs/**/CHANGELOG.md"
      - "README.md"
      - ".github/workflows/codex-mintlify-docs.yml"

  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: codex-docs-${{ github.ref }}
  cancel-in-progress: false

jobs:
  docs:
    # For PRs: only run if head branch is next/*
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'next/')
    runs-on: ubuntu-latest
    environment: release

    env:
      CODEX_OUT: .codex-docs/patches.json

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Fail fast if env secret is not available
      - name: Ensure CODEX_OPENAI_KEY secret is set
        run: |
          if [ -z "${{ secrets.CODEX_OPENAI_KEY }}" ]; then
            echo "::error::CODEX_OPENAI_KEY (env: release) is not set. Add it under Settings ‚Üí Environments ‚Üí release ‚Üí Secrets." >&2
            exit 1
          fi

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version-file: ".nvmrc"
          cache: "yarn"
          registry-url: "https://registry.npmjs.org/"

      - name: Install validator deps
        run: yarn install

      # ========================================
      # MCP Integration: Query Mintlify docs for context
      # ========================================
      - name: Setup MCP server for enhanced context
        id: mcp
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/codex/mcp-context

          echo "Setting up Mintlify MCP context..."

          # Query Mintlify MCP for documentation best practices
          # This provides Codex with official Mintlify guidelines
          cat > .github/codex/mcp-context/mintlify-guidelines.md <<'GUIDELINES'
          # Mintlify Documentation Guidelines

          ## Structure
          - Use clear, hierarchical organization
          - Group related pages under common sections
          - Keep navigation depth to 3 levels max

          ## Content
          - Start with conceptual overview, then details
          - Include code examples for all features
          - Use callouts for important notes (Note, Warning, Tip)
          - Keep paragraphs short and scannable

          ## Versioning
          - Latest version uses `docs/...` paths (no version prefix)
          - Archived versions use `docs/v/<minor>/...` paths
          - Update `docs.json` versions array when archiving
          - Mark latest with `"default": true` and `"(latest)"` in version string

          ## Code Blocks
          - Specify language for syntax highlighting
          - Include comments for complex examples
          - Show both TypeScript and JavaScript when relevant

          ## Navigation (docs.json)
          - Each version has its own groups array
          - Use descriptive group names
          - Add icons to enhance visual hierarchy
          - Include tags for filtering ("latest", "version X.Y")
          GUIDELINES

          echo "‚úì MCP context prepared"
          echo "mcp_enabled=true" >> "$GITHUB_OUTPUT"

      - name: Prepare diff context for Codex
        id: ctx
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/codex/prompts .codex-docs

          # ----------------------------------------
          # Resolve branch name for this run
          # ----------------------------------------
          if [ -n "${GITHUB_HEAD_REF:-}" ]; then
            # Pull request: source branch (e.g., next/0.3.1)
            BRANCH="$GITHUB_HEAD_REF"
          else
            # Push: branch name (e.g., next/0.3.1)
            BRANCH="${GITHUB_REF_NAME:-$(git rev-parse --abbrev-ref HEAD)}"
          fi
          echo "Using branch: $BRANCH"
          echo "$BRANCH" > .github/codex/prompts/branch.txt
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

          # ----------------------------------------
          # Base for diff/log = last published tag
          # ----------------------------------------
          # Find last stable semver tag reachable from HEAD:
          # - tags like v1.2.3 or 1.2.3
          # - no pre-release suffixes (no "-alpha.1", etc)
          LAST_TAG=$(
            git tag --merged HEAD \
            | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' \
            | sort -V \
            | tail -n 1 \
            || true
          )

          if [ -n "$LAST_TAG" ]; then
            BASE=$(git rev-list -n 1 "$LAST_TAG")
            echo "Using last published version tag as base: ${LAST_TAG} (${BASE})"
          else
            echo "No semver release tag reachable from HEAD; falling back to default-branch merge-base."
            BASE=$(git merge-base HEAD "origin/${{ github.event.repository.default_branch }}") || \
                  BASE=$(git rev-list --max-parents=0 HEAD)
          fi

          echo "$BASE" > .github/codex/prompts/base.txt

          # Unified diff: from last published release -> current next/x.y.z HEAD
          git diff "$BASE"...HEAD --unified=3 > .github/codex/prompts/diff.patch || true

          # ----------------------------------------
          # Derive release version from package.json
          # ----------------------------------------
          VERSION=$(node -e "try{console.log(require('./package.json').version || '0.0.0')}catch{console.log('0.0.0')}")
          VERSION_MINOR=$(echo "$VERSION" | awk -F. '{print $1"."$2}')

          echo "Resolved version: $VERSION (minor: $VERSION_MINOR)"

          echo "$VERSION" > .github/codex/prompts/version.txt
          echo "$VERSION_MINOR" > .github/codex/prompts/version-minor.txt

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "version_minor=$VERSION_MINOR" >> "$GITHUB_OUTPUT"

          # Commit list (for changelog / docs / README synthesis)
          git log "$BASE"...HEAD --pretty=format:'%H%x09%s%x09%b' > .github/codex/prompts/commits.txt || true

          # ISO date
          date -u +"%Y-%m-%d" > .github/codex/prompts/date.txt

          # Detect independent libraries published in this release
          # Look for changed package.json versions in libs with versioning:independent tag
          echo "Detecting independent libraries published in this release..."
          node - <<'DETECT_LIBS'
          const { execSync } = require('child_process');
          const fs = require('fs');

          try {
            // Get all independent libraries
            const independentLibs = execSync(
              'npx nx show projects -p tag:versioning:independent --type lib --json',
              { encoding: 'utf8' }
            );
            const libs = JSON.parse(independentLibs);

            const published = [];
            for (const lib of libs) {
              const pkgPath = `libs/${lib}/package.json`;
              if (fs.existsSync(pkgPath)) {
                const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                const name = pkg.name || lib;
                const version = pkg.version || '0.0.0';
                published.push({ name, version, lib });
              }
            }

            fs.writeFileSync(
              '.github/codex/prompts/independent-libs.json',
              JSON.stringify({ published }, null, 2),
              'utf8'
            );

            console.log(`Found ${published.length} independent libraries:`, published);
          } catch (e) {
            // If no independent libs found, write empty array
            fs.writeFileSync(
              '.github/codex/prompts/independent-libs.json',
              JSON.stringify({ published: [] }, null, 2),
              'utf8'
            );
            console.log('No independent libraries found');
          }
          DETECT_LIBS

      - name: Add Codex prompt & schema
        run: |
          cat > .github/codex/prompts/update-docs.md <<'MDX'
          You are Codex. Task: propose minimal, precise updates to our **Mintlify** docs (under `docs/live/docs/`), our root `CHANGELOG.md`, READMEs, and the Mintlify navigation (`docs/live/docs.json`) for the current release.

          INPUTS (read-only files in workspace):
          - Unified diff:              `.github/codex/prompts/diff.patch`
          - Commit list (TSV):         `.github/codex/prompts/commits.txt`        # columns: sha<TAB>subject<TAB>body
          - Release version:           `.github/codex/prompts/version.txt`        # e.g., 0.3.1
          - Release minor:             `.github/codex/prompts/version-minor.txt`  # e.g., 0.3
          - Release date (UTC, ISO):   `.github/codex/prompts/date.txt`           # e.g., 2025-11-13
          - Independent libs:          `.github/codex/prompts/independent-libs.json`  # JSON: {"published": [{"name": "@pkg/name", "version": "1.2.0", "lib": "lib-name"}]}
          - MCP Context Guidelines:    `.github/codex/mcp-context/mintlify-guidelines.md`  # Best practices from Mintlify MCP

          DOCS LAYOUT & VERSIONING

          **IMPORTANT: Follow the MCP guidelines in `.github/codex/mcp-context/mintlify-guidelines.md`**

          Folders:
          - `docs/live/docs/**`
            - The canonical **latest** docs for the current minor (`version-minor.txt`).
            - Paths in Mintlify nav for the latest docs use the `docs/...` prefix (e.g., `"docs/getting-started/welcome"`).
            - These are published to production and managed by the release workflow.
          - `docs/live/docs/v/<minor>/**`
            - **Archived** docs for older minor versions (e.g., `docs/live/docs/v/0.2/**`).
            - These are **read-only**. Do **NOT** modify or create files under `docs/live/docs/v/**`.
            - Created automatically by the release workflow when a new minor version is released.
          - `docs/draft/docs/**`
            - Draft docs where new documentation is authored.
            - You may **read** these for context and to understand upcoming changes.
            - Do **NOT** modify draft docs - they're managed by a separate workflow on main branch.
          - `docs/live/blog/**`
            - Blog posts. These must **not** be modified or created by Codex.
          - `docs/draft/blog/**`
            - Draft blog posts. These must **not** be modified or created by Codex.

          - `docs/live/updates.mdx`
            - **Production** release notes page (Mintlify route `updates`), independent of version folders.
          - `docs/draft/updates.mdx`
            - Draft release notes (do NOT modify - managed separately)

          SCOPE & PATHS

          You are allowed to modify/create only:

          - Latest version docs (live/production):
            - `docs/live/docs/**/*.mdx`
            - `docs/live/docs/**/*.md`
          - Shared global release notes (live/production):
            - `docs/live/updates.mdx`
          - Navigation (production):
            - `docs/live/docs.json`
          - Changelog:
            - `CHANGELOG.md`
          - Root README:
            - `README.md`
          - Library READMEs:
            - `libs/**/README.md`

          You must **not** touch:
          - `docs/live/docs/v/**` (archived versioned docs)
          - `docs/draft/**` (draft docs - managed separately)
          - `docs/live/blog/**` (blog posts)
          - `docs/draft/blog/**` (draft blog posts)
          or any other file types outside the allowed list.

          RULES ‚Äì RELEASE NOTES (`docs/live/updates.mdx`)

          **CRITICAL: Preserve frontmatter metadata**
          - The file starts with YAML frontmatter (lines 1-6):
            ```yaml
            ---
            title: 'Updates'
            slug: 'updates'
            icon: 'sparkles'
            mode: 'center'
            ---
            ```
          - This frontmatter is **critical** for Mintlify to detect the page
          - **MUST** be preserved exactly as-is at the top of the file

          **Structure for updates:**

          Read `.github/codex/prompts/independent-libs.json` to see which independent libraries are being published.

          Create **separate** `<Update>` components for:

          1. **FrontMCP (synchronized packages)** - One component for all synchronized libs:
             - Label: `"v<version>"` (e.g., `"v0.4.0"`)
             - Title: `"FrontMCP v<version>: <short-description>"`
             - href: `"https://github.com/agentfront/frontmcp/releases/tag/v<version>"`
             - cta: `"View full changlog"` (note: keep this exact spelling)
             - Tags: `{["Releases"]}`
             - Content: **User-friendly highlights** (NOT technical changelog)
               - Use emojis at start of each line (üöÄ üõ°Ô∏è üîê üìö ‚ö° üé® üîß üß© etc.)
               - Format: `emoji **Bold feature name** ‚Äì Description of what users can do.`
               - Each feature on its own line
               - Focus on benefits and practical capabilities
               - NO changelog link at the end (href already points to releases)
             - This is for the main FrontMCP framework and all synchronized libraries

          2. **Each independent library published** - Separate component per library:
             - Check `independent-libs.json` for the list of published independent libraries
             - For each library in the `published` array, create a separate `<Update>`:
               - Label: `"<library-name> v<version>"` (use `name` and `version` from JSON)
               - Title: `"<library-name> v<version>"` (use `name` and `version` from JSON)
               - href: `"https://github.com/agentfront/frontmcp/tree/main/libs/<lib-folder-name>"` (use `lib` field from JSON)
               - cta: `"Explore the library"`
               - Tags: `{["Independent"]}`
               - Content: **User-friendly highlights** (NOT technical changelog)
                 - Use emojis at start of each line
                 - Format: `emoji **Bold feature name** ‚Äì Description.`
                 - Each feature on its own line
                 - Focus on practical use cases
                 - NO changelog link at the end
             - If `published` array is empty, skip independent library updates

          **Format example:**
          ```mdx
          ---
          title: 'Updates'
          slug: 'updates'
          icon: 'sparkles'
          mode: 'center'
          ---

          <Update label="v0.5.0" description="2025-11-22" tags={["Releases"]}>
            <Card
              title="FrontMCP v0.5.0: Enhanced streaming and error handling"
              href="https://github.com/agentfront/frontmcp/releases/tag/v0.5.0"
              cta="View full changlog"
            >
              üöÄ **Streaming API** ‚Äì Build real-time experiences with backpressure support and automatic reconnection.

              üõ°Ô∏è **Enhanced Errors** ‚Äì Get detailed stack traces and user-friendly error messages that help you debug faster.

              üîê **Authentication Flow** ‚Äì Simplified auth setup with better provider integration and clearer error messages.

              üìö **Documentation** ‚Äì New streaming guide and updated authentication examples to get you started quickly.
            </Card>
          </Update>

          <Update label="json-schema-to-zod-v3 v1.2.0" description="2025-11-22" tags={["Independent"]}>
            <Card
              title="json-schema-to-zod-v3 v1.2.0"
              href="https://github.com/agentfront/frontmcp/tree/main/libs/json-schema-to-zod-v3"
              cta="Explore the library"
            >
              ‚ú® **JSON Schema Draft 2020-12** ‚Äì Full support for the latest JSON Schema specification with all new features.

              üîç **Enhanced Validation** ‚Äì More accurate regex pattern validation catches edge cases before runtime.

              üõ†Ô∏è **Better DX** ‚Äì Improved TypeScript types and error messages make integration smoother.
            </Card>
          </Update>

          <Update label="v0.4.0" description="2025-11-21" tags={["Releases"]}>
            ... (previous release)
          </Update>
          ```

          - Add new updates at the **top** (after frontmatter, before existing updates)
          - Use consistent date format: `YYYY-MM-DD`
          - Keep all existing updates below the new ones
          - Maintain valid MDX syntax

          RULES ‚Äì LATEST DOCS (`docs/live/docs/**`)

          - Treat `docs/live/docs/` as the **canonical docs root for the current minor** (`version-minor.txt`).
          - When updating or creating docs, stay inside `docs/live/docs/` and keep structure consistent with what already exists there.
          - Do **not** modify `docs/live/docs/v/**` or `docs/draft/**`.
          - Keep tone and style consistent with existing docs.

          RULES ‚Äì NAVIGATION (`docs/live/docs.json`)

          Structure:
          - The root has a `dropdowns` array.
          - There is at least:
            - One dropdown with `"dropdown": "Documentation"`, containing:
              - `"icon": "book"`
              - `"versions": [ ... ]`
            - One dropdown with `"dropdown": "Blog"`, containing blog groups.

          You MUST:
          - Only modify the `"Documentation"` dropdown and its `versions` array.
          - **Do not** modify the `"Blog"` dropdown or any blog navigation.
          - This is the production navigation file that will be published immediately.

          Versions:
          - The documentation dropdown has a `versions` array similar to:

            ```jsonc
            {
              "dropdown": "Documentation",
              "icon": "book",
              "versions": [
                {
                  "version": "v0.3 (latest)",
                  "default": true,
                  "groups": [ ... paths like "docs/getting-started/welcome", "updates", ... ]
                },
                {
                  "version": "v0.2",
                  "groups": [ ... paths like "docs/v/0.2/getting-started/welcome" ... ]
                },
                {
                  "version": "v0.1",
                  "groups": [ ... ]
                }
              ]
            }
            ```

          Semantics:
          - The **latest minor** (matching `version-minor.txt`) must:
            - Appear as the first entry in `versions`.
            - Have `"version": "v<minor> (latest)"` (e.g., `"v0.3 (latest)"`).
            - Have `"default": true`.
            - Use paths **without** the `/v/<minor>` prefix (latest routes):
              - e.g., `"docs/getting-started/welcome"`, `"docs/servers/server"`, `"updates"`.
          - Older minors (archived) must:
            - Use `"version": "v<minor>"` (no ‚Äú(latest)‚Äù).
            - Have **no** `"default": true` (or explicitly `false`).
            - Use paths that start with `docs/v/<minor>/...`:
              - e.g., `"docs/v/0.2/getting-started/welcome"`.

          When the current `version-minor.txt` **already matches** the existing latest entry:
          - Example: latest entry is `"v0.3 (latest)"` and `version-minor.txt` is `0.3`.
          - Treat this release as a **patch** within the same minor.
          - Keep the `"v0.3 (latest)"` entry as the default.
          - Add or adjust page entries within that entry's `groups` so that every new/renamed doc file under `docs/live/docs/` is reflected in `pages`.
          - Do **not** add or modify entries for `docs/live/docs/v/**`.

          If `version-minor.txt` does **not** match the minor in the current "(latest)" entry:
          - The archival is handled by a separate script, so you only need to update the navigation.
          - Your responsibility is to ensure:
            - The **latest** entry refers to `docs/...` paths and matches `version-minor.txt`.
            - Older entries refer to `docs/v/<minor>/...` paths and are correctly labeled.
          - However, **do not** create or modify `docs/live/docs/v/**` files; the archived folders are managed by a separate script.

          Tags:
          - You may see `tag` fields like `"latest"` or `"version 0.2"` on groups.
          - Preserve and update them logically:
            - The latest version can have `tag: "latest"`.
            - Older versions can have `tag: "version <minor>"` (e.g., `"version 0.2"`).
          - Do not introduce noisy or inconsistent tags.

          Keep `docs/live/docs.json`:
          - Valid JSON.
          - As close as reasonable to existing formatting (but correctness > formatting).

          RULES ‚Äì CHANGELOG (`CHANGELOG.md`)

          - Follow Keep a Changelog style.
          - Add a new section at the top with heading:
            - `## [v<version>] - <YYYY-MM-DD>`
          - Categorize entries using Conventional Commits (feat/fix/docs/perf/refactor/build/ci/chore) and mark **BREAKING CHANGES** clearly.
          - Use short, imperative bullets; avoid internal-only noise.

          RULES ‚Äì ROOT README (`README.md`)

          - Update only if there are meaningful repo-level changes for this release.
          - Ensure:
            - Install commands, quickstart snippets, and any mentioned versions are accurate for the current release.
            - Top-level feature overview is up-to-date.
          - If there are no meaningful changes, leave it unchanged.

          RULES ‚Äì LIBRARY READMEs (`libs/**/README.md`)

          - Focus on libs that are clearly user-facing or affected by the diff:
            - Their code changed.
            - Their `package.json` version changed.
            - Commits explicitly mention them.
          - For each updated README:
            - Ensure install instructions are correct (package name, registry, version ranges if relevant).
            - Update usage examples and API sections to match current behavior.
            - Optionally highlight notable changes that impact consumers.
          - Keep Markdown simple and valid; avoid large rewrites unless the current content is clearly misleading.

          GENERAL

          - Prefer small, surgical edits.
          - Never modify:
            - `docs/live/docs/v/**` (archived docs)
            - `docs/draft/**` (draft docs - managed separately)
            - `docs/live/blog/**` (blog posts)
            - `docs/draft/blog/**` (draft blog posts)
          - Always keep:
            - `docs/live/docs.json` consistent with actual docs under `docs/live/docs/`.
            - `docs/live/updates.mdx` and `CHANGELOG.md` consistent in terms of high-level content (but adapted tone).
          - If no changes are needed, return an empty patch set.

          OUTPUT (STRICT)

          - Return JSON that matches the output schema provided by the runner.
          - Each patch replaces the entire file content.

          HINTS

          - Use subjects/bodies in `commits.txt` to infer categories; de-duplicate merges.
          - If the same content belongs in multiple places (e.g., `docs/live/updates.mdx`, `CHANGELOG.md`, and a lib's README), adapt tone:
            - docs = narrative highlights,
            - changelog = terse, categorized bullets,
            - README = practical "how to use this" guidance and upgrade notes.

          Produce ONLY the JSON per schema.
          MDX

          cat > .github/codex/codex-output-schema.json <<'JSON'
          {
            "type": "object",
            "properties": {
              "patches": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "pattern": "^(docs\\/live\\/docs\\/.+\\.(md|mdx)|docs\\/live\\/updates\\.mdx|docs\\/live\\/docs\\.json|CHANGELOG\\.md|README\\.md|libs\\/.+\\/README\\.md)$"
                    },
                    "content": { "type": "string", "minLength": 1, "maxLength": 500000 }
                  },
                  "required": ["path", "content"],
                  "additionalProperties": false
                }
              }
            },
            "required": ["patches"],
            "additionalProperties": false
          }
          JSON

      - name: Run Codex (read-only, structured output)
        id: codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_OPENAI_KEY }}
          prompt-file: .github/codex/prompts/update-docs.md
          output-file: ${{ env.CODEX_OUT }}
          model: "gpt-5.1-codex"
          sandbox: read-only
          safety-strategy: drop-sudo
          output-schema-file: .github/codex/codex-output-schema.json

      - name: Apply & validate patches
        id: apply
        run: |
          set -euo pipefail

          node scripts/apply-doc-patches.mjs "$CODEX_OUT" | tee .codex-docs/apply.log

          # Any change in the working tree means Codex actually updated something
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Delete existing docs branch for this version (if any)
        if: ${{ steps.apply.outputs.changed == 'true' }}
        env:
          VERSION: ${{ steps.ctx.outputs.version }}
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="docs/codex/v${VERSION}"

          echo "Checking for existing branch ${BRANCH}..."

          # Fetch the branch ref if it exists on origin
          git fetch origin "+refs/heads/${BRANCH}:refs/remotes/origin/${BRANCH}" || true

          if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH}"; then
            echo "Remote branch ${BRANCH} exists. Deleting remote..."
            git push origin --delete "${BRANCH}" || true
          else
            echo "No remote branch ${BRANCH}."
          fi

          if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
            echo "Local branch ${BRANCH} exists. Deleting local..."
            git branch -D "${BRANCH}" || true
          else
            echo "No local branch ${BRANCH}."
          fi

      - name: Create PR with docs & changelog & READMEs
        if: ${{ steps.apply.outputs.changed == 'true' }}
        uses: peter-evans/create-pull-request@v7
        with:
          branch: docs/codex/v${{ steps.ctx.outputs.version }}
          base: ${{ steps.ctx.outputs.branch }}
          title: "docs: release notes, changelog & READMEs for v${{ steps.ctx.outputs.version }} (Codex)"
          commit-message: "docs(codex): update Mintlify docs, CHANGELOG & READMEs [auto]"
          labels: "documentation, automated, codex, release-notes"
          add-paths: |
            docs/live/**
            CHANGELOG.md
            README.md
            libs/**/README.md
          delete-branch: true
          body: |
            Codex proposed updates to:
            - **docs/live/updates.mdx** (Mintlify release notes - production)
            - **docs/live/docs.json** (Mintlify navigation / versions - production)
            - **docs/live/docs/** (latest docs only - production)
            - **CHANGELOG.md**
            - **README.md** (root)
            - **libs/**/README.md** (affected publishable libs)

            for `v${{ steps.ctx.outputs.version }}` on branch `${{ steps.ctx.outputs.branch }}`.

            Note: `docs/live/` is the production documentation and will be published directly to Mintlify.

            See `.codex-docs/apply.log` for validation details.

      - name: Upload artifacts (debug)
        uses: actions/upload-artifact@v4
        with:
          name: codex-docs-artifacts
          path: |
            .codex-docs/**
            .github/codex/prompts/**
