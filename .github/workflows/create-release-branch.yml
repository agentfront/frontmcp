name: Create release branch (next/{semver})

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Semver bump"
        required: true
        type: choice
        options: [patch, minor, major]
        default: patch

permissions:
  contents: write
  pull-requests: write

jobs:
  create:
    runs-on: ubuntu-latest
    environment: release
    env:
      # Disable Nx daemon in CI for determinism
      NX_DAEMON: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # we need tags & history

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version-file: ".nvmrc"
          cache: "yarn"
          registry-url: "https://registry.npmjs.org/"

      - name: Install deps
        run: yarn

      - name: Configure git user
        run: |
          git config user.name "agentfront[bot]"
          git config user.email "agentfront[bot]@users.noreply.github.com"

      # üî¢ Compute next semver strictly from root package.json + bump input
      - name: Compute next semver from root package.json
        id: next
        shell: bash
        run: |
          set -euo pipefail

          # Run node with BUMP provided as env var
          NEXT=$(BUMP="${{ inputs.bump }}" node - << 'EOF'
          const fs = require('fs');

          const bump = (process.env.BUMP || 'patch').trim();

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const raw = String(pkg.version || '0.0.0').trim();

          const parts = raw.split('.').map((n) => {
            const v = Number.parseInt(n, 10);
            return Number.isFinite(v) ? v : 0;
          });

          let [M, m, p] = [parts[0] || 0, parts[1] || 0, parts[2] || 0];

          if (bump === 'major') {
            M += 1;
            m = 0;
            p = 0;
          } else if (bump === 'minor') {
            m += 1;
            p = 0;
          } else {
            // default: patch
            p += 1;
          }

          const next = [M, m, p].join('.');
          process.stdout.write(next);
          EOF
          )

          echo "Next version: $NEXT"
          echo "value=$NEXT" >> "$GITHUB_OUTPUT"

      - name: Get current and last release versions
        id: versions
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          # Get last release tag
          LAST_TAG=$(git tag --list "v*" --sort=-version:refname | head -n1 || echo "")
          if [ -n "$LAST_TAG" ]; then
            # Extract version from tag (remove 'v' prefix)
            LAST_VERSION="${LAST_TAG#v}"
            # Get minor version (e.g., 0.3 from 0.3.1)
            LAST_MINOR=$(echo "$LAST_VERSION" | awk -F. '{print $1"."$2}')
          else
            LAST_VERSION=""
            LAST_MINOR=""
          fi

          NEXT_MINOR=$(echo "$NEXT" | awk -F. '{print $1"."$2}')

          echo "last_version=$LAST_VERSION" >> "$GITHUB_OUTPUT"
          echo "last_minor=$LAST_MINOR" >> "$GITHUB_OUTPUT"
          echo "next_version=$NEXT" >> "$GITHUB_OUTPUT"
          echo "next_minor=$NEXT_MINOR" >> "$GITHUB_OUTPUT"

          echo "Last release: $LAST_VERSION (minor: $LAST_MINOR)"
          echo "Next release: $NEXT (minor: $NEXT_MINOR)"

      - name: Create branch next/${{ steps.next.outputs.value }} from base
        id: branch
        shell: bash
        run: |
          set -euo pipefail
          BASE="main"
          NEXT="${{ steps.next.outputs.value }}"

          git fetch origin "$BASE" --tags
          git switch -c "next/$NEXT" "origin/$BASE"

          echo "Created branch next/$NEXT from $BASE"
          echo "name=next/$NEXT" >> "$GITHUB_OUTPUT"

      # ========================================
      # STEP 1: Identify affected independent libraries
      # ========================================
      - name: Identify affected independent libraries
        id: independent
        shell: bash
        run: |
          set -euo pipefail

          # Get all independent libraries
          ALL_INDEPENDENT=$(node -e "
            const { execSync } = require('child_process');
            try {
              const out = execSync('npx nx show projects -p tag:versioning:independent --type lib --json', { encoding: 'utf8' });
              const arr = JSON.parse(out);
              process.stdout.write(arr.join(','));
            } catch (e) {
              process.stdout.write('');
            }
          ")

          if [ -z "$ALL_INDEPENDENT" ]; then
            echo 'independent_projects=' >> "$GITHUB_OUTPUT"
            echo "No independent libraries found"
            exit 0
          fi

          echo "All independent libs: $ALL_INDEPENDENT"

          # Get affected libraries (changed since last release)
          LAST_TAG="${{ steps.versions.outputs.last_version }}"
          if [ -n "$LAST_TAG" ]; then
            LAST_TAG="v$LAST_TAG"
          else
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          AFFECTED=$(node -e "
            const { execSync } = require('child_process');
            try {
              const out = execSync('npx nx show projects --affected --base=\"${LAST_TAG}\" --type lib --json', { encoding: 'utf8' });
              const arr = JSON.parse(out);
              process.stdout.write(arr.join(','));
            } catch (e) {
              process.stdout.write('');
            }
          ")

          # Find intersection: affected AND independent
          AFFECTED_INDEPENDENT=$(node -e "
            const all = '$ALL_INDEPENDENT'.split(',').filter(Boolean);
            const affected = '$AFFECTED'.split(',').filter(Boolean);
            const intersection = all.filter(lib => affected.includes(lib));
            process.stdout.write(intersection.join(','));
          ")

          echo "independent_projects=$AFFECTED_INDEPENDENT" >> "$GITHUB_OUTPUT"
          if [ -n "$AFFECTED_INDEPENDENT" ]; then
            echo "Affected independent libs: $AFFECTED_INDEPENDENT"
          else
            echo "No affected independent libraries"
          fi

      # ========================================
      # STEP 2: Use Codex to analyze independent libs
      # ========================================
      - name: Prepare context for Codex lib analysis
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/codex/lib-analysis

          INDEPENDENT="${{ steps.independent.outputs.independent_projects }}"
          LAST_TAG="${{ steps.versions.outputs.last_version }}"
          if [ -n "$LAST_TAG" ]; then
            LAST_TAG="v$LAST_TAG"
          else
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          TODAY=$(date -u +"%Y-%m-%d")

          # Collect changes for all independent libraries
          IFS=',' read -ra LIBS <<< "$INDEPENDENT"
          LIBS_DATA=""

          for lib in "${LIBS[@]}"; do
            DIFF=$(git diff "$LAST_TAG"...HEAD -- "libs/$lib" 2>/dev/null || echo "")
            COMMITS=$(git log "$LAST_TAG"...HEAD --oneline -- "libs/$lib" 2>/dev/null || echo "")

            if [ -z "$DIFF" ] && [ -z "$COMMITS" ]; then
              continue
            fi

            CURRENT_VERSION=$(node -e "console.log(require('./libs/$lib/package.json').version)")

            LIBS_DATA+="
          ================================================================================
          LIBRARY: $lib
          CURRENT VERSION: $CURRENT_VERSION
          ================================================================================

          COMMITS:
          $COMMITS

          DIFF (truncated to 8000 chars):
          ${DIFF:0:8000}

          "
          done

          # Create single prompt for all libraries
          cat > .github/codex/lib-analysis/prompt.md <<EOF
          Analyze the following independent libraries and determine:
          1. The appropriate semantic version bump (MAJOR/MINOR/PATCH)
          2. A changelog entry for each library

          Today's date: $TODAY

          Semantic Versioning Rules:
          - MAJOR: Breaking changes, incompatible API changes
          - MINOR: New features, backwards-compatible functionality additions
          - PATCH: Backwards-compatible bug fixes, documentation, refactoring, minor improvements

          Libraries to analyze:
          $LIBS_DATA

          For each library, respond with version bump recommendation and changelog.
          The changelog should start with ## [NEW_VERSION] - $TODAY and include appropriate sections.
          EOF

          # Create output schema
          cat > .github/codex/lib-analysis/schema.json <<'SCHEMA'
          {
            "type": "object",
            "properties": {
              "libraries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": { "type": "string" },
                    "bump": { "type": "string", "enum": ["major", "minor", "patch"] },
                    "changelog": { "type": "string", "minLength": 10 }
                  },
                  "required": ["name", "bump", "changelog"],
                  "additionalProperties": false
                }
              }
            },
            "required": ["libraries"],
            "additionalProperties": false
          }
          SCHEMA

      - name: Run Codex to analyze independent libraries
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        id: codex_libs
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_OPENAI_KEY }}
          prompt-file: .github/codex/lib-analysis/prompt.md
          output-file: .github/codex/lib-analysis/results.json
          sandbox: read-only
          safety-strategy: drop-sudo
          output-schema-file: .github/codex/lib-analysis/schema.json

      # ========================================
      # STEP 3: Apply all version bumps
      # ========================================
      - name: Bump synchronized libraries
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          echo "Bumping synchronized libraries to version $NEXT..."
          node scripts/bump-synchronized-versions.mjs "$NEXT"

      - name: Bump independent libraries and write changelogs
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        shell: bash
        run: |
          set -euo pipefail

          RESULTS_FILE=".github/codex/lib-analysis/results.json"
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "No Codex results found, skipping independent lib bumps"
            exit 0
          fi

          # Process each library from Codex results
          LIBS_COUNT=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries.length)")

          for ((i=0; i<LIBS_COUNT; i++)); do
            LIB_NAME=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].name)")
            BUMP_TYPE=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].bump)")
            CHANGELOG_ENTRY=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].changelog)")

            echo "================================"
            echo "Processing: $LIB_NAME"
            echo "Bump: $BUMP_TYPE"
            echo "================================"

            # Bump version
            node scripts/bump-version.mjs "$LIB_NAME" "$BUMP_TYPE"

            # Get new version after bump
            NEW_VERSION=$(node -e "console.log(require('./libs/${LIB_NAME}/package.json').version)")
            CHANGELOG_PATH="libs/$LIB_NAME/CHANGELOG.md"

            echo "Writing CHANGELOG for $LIB_NAME v$NEW_VERSION..."

            if [ -f "$CHANGELOG_PATH" ]; then
              # Prepend to existing changelog
              echo "$CHANGELOG_ENTRY" > "$CHANGELOG_PATH.new"
              echo "" >> "$CHANGELOG_PATH.new"
              cat "$CHANGELOG_PATH" >> "$CHANGELOG_PATH.new"
              mv "$CHANGELOG_PATH.new" "$CHANGELOG_PATH"
            else
              # Create new changelog
              cat > "$CHANGELOG_PATH" <<CLEOF
          # Changelog

          All notable changes to $LIB_NAME will be documented in this file.

          $CHANGELOG_ENTRY
          CLEOF
            fi

            echo "‚úì Bumped $LIB_NAME to $NEW_VERSION and updated CHANGELOG"
          done

      # ========================================
      # STEP 4: Archive old docs and update docs.json
      # ========================================
      - name: Archive previous version docs
        shell: bash
        run: |
          set -euo pipefail

          LAST_MINOR="${{ steps.versions.outputs.last_minor }}"
          NEXT_MINOR="${{ steps.next.outputs.next_minor }}"

          if [ -z "$LAST_MINOR" ]; then
            echo "No previous version to archive"
            exit 0
          fi

          # Only archive if this is a new minor version
          if [ "$LAST_MINOR" = "$NEXT_MINOR" ]; then
            echo "Same minor version ($NEXT_MINOR), skipping docs archival"
            exit 0
          fi

          echo "Archiving v$LAST_MINOR docs to docs/v/$LAST_MINOR/"

          # Create archive directory
          mkdir -p "docs/v/$LAST_MINOR"

          # Move current docs to archive (if not already there)
          if [ -d "docs/docs" ]; then
            cp -r docs/docs/* "docs/v/$LAST_MINOR/" || true
            echo "‚úì Archived docs/docs/ to docs/v/$LAST_MINOR/"
          fi

      - name: Copy draft docs to current docs
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d "docs/draft/docs" ]; then
            echo "No draft docs found, skipping"
            exit 0
          fi

          echo "Copying docs/draft/docs/ to docs/docs/"

          # Clear current docs and copy from draft
          rm -rf docs/docs
          cp -r docs/draft/docs docs/docs

          echo "‚úì Copied draft docs to docs/docs/"

      - name: Update docs.json versioning
        shell: bash
        run: |
          set -euo pipefail

          LAST_MINOR="${{ steps.versions.outputs.last_minor }}"
          NEXT_MINOR="${{ steps.next.outputs.next_minor }}"

          if [ -z "$LAST_MINOR" ]; then
            echo "No previous version, skipping docs.json update"
            exit 0
          fi

          # Only update if this is a new minor version
          if [ "$LAST_MINOR" = "$NEXT_MINOR" ]; then
            echo "Same minor version, skipping docs.json version update"
            exit 0
          fi

          echo "Updating docs.json: v$LAST_MINOR -> v$NEXT_MINOR"

          node - <<'NODESCRIPT'
          const fs = require('fs');
          const lastMinor = process.env.LAST_MINOR;
          const nextMinor = process.env.NEXT_MINOR;

          const docsPath = 'docs/docs.json';
          const docs = JSON.parse(fs.readFileSync(docsPath, 'utf8'));

          // Find Documentation dropdown
          const docDropdown = docs.navigation.dropdowns.find(d => d.dropdown === 'Documentation');
          if (!docDropdown || !docDropdown.versions) {
            console.log('No Documentation dropdown with versions found');
            process.exit(0);
          }

          // Find current latest version
          const latestIndex = docDropdown.versions.findIndex(v => v.default === true);
          if (latestIndex === -1) {
            console.log('No default version found');
            process.exit(0);
          }

          const oldLatest = docDropdown.versions[latestIndex];

          // Update old latest to archived version
          oldLatest.version = `v${lastMinor}`;
          oldLatest.default = false;
          oldLatest.tag = undefined;

          // Update all paths in old latest to point to archived location
          function updatePaths(groups, prefix) {
            for (const group of groups) {
              if (group.pages) {
                group.pages = group.pages.map(page => {
                  if (typeof page === 'string') {
                    if (page.startsWith('docs/') && !page.startsWith('docs/v/')) {
                      return page.replace('docs/', `docs/v/${lastMinor}/`);
                    }
                    return page;
                  } else if (page.pages) {
                    updatePaths([page], prefix);
                    return page;
                  }
                  return page;
                });
              }
              if (group.tag === 'latest') {
                group.tag = `version ${lastMinor}`;
              }
            }
          }

          updatePaths(oldLatest.groups);

          // Create new latest version (copy structure from old latest)
          const newLatest = {
            version: `v${nextMinor} (latest)`,
            default: true,
            groups: JSON.parse(JSON.stringify(oldLatest.groups))
          };

          // Restore paths in new latest to point to current docs
          function restorePaths(groups) {
            for (const group of groups) {
              if (group.pages) {
                group.pages = group.pages.map(page => {
                  if (typeof page === 'string') {
                    if (page.startsWith(`docs/v/${lastMinor}/`)) {
                      return page.replace(`docs/v/${lastMinor}/`, 'docs/');
                    }
                    return page;
                  } else if (page.pages) {
                    restorePaths([page]);
                    return page;
                  }
                  return page;
                });
              }
              if (group.tag === `version ${lastMinor}`) {
                group.tag = 'latest';
              }
            }
          }

          restorePaths(newLatest.groups);

          // Insert new latest at the beginning
          docDropdown.versions.unshift(newLatest);

          // Write updated docs.json
          fs.writeFileSync(docsPath, JSON.stringify(docs, null, 2) + '\n', 'utf8');

          console.log(`‚úì Updated docs.json: added v${nextMinor} (latest), moved v${lastMinor} to archive`);
          NODESCRIPT
        env:
          LAST_MINOR: ${{ steps.versions.outputs.last_minor }}
          NEXT_MINOR: ${{ steps.next.outputs.next_minor }}

      # ========================================
      # STEP 5: Commit all changes
      # ========================================
      - name: Commit release preparation
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          # Check if there are changes
          if [ -n "$(git status --porcelain)" ]; then
            git add -A

            # Create detailed commit message
            cat > /tmp/commit-msg <<COMMITMSG
          chore(release): prepare v$NEXT

          - Bump synchronized libs to v$NEXT
          - Bump independent libs (Codex-analyzed)
          - Update CHANGELOGs for independent libs
          - Archive v${{ steps.versions.outputs.last_minor }} docs
          - Update docs.json versioning
          COMMITMSG

            git commit -F /tmp/commit-msg
            echo "‚úì Created release preparation commit"
          else
            echo "No changes to commit"
            git commit --allow-empty -m "chore(release): prepare v$NEXT"
          fi

      # üö´ Push ONLY the branch, NOT tags ‚Äì tags will be created & pushed by the publish workflow on merge
      - name: Push branch (no tags)
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          git push --set-upstream origin "next/$NEXT"

      # Open PR main <- next/{semver} with title v{semver}
      - name: Open PR for next/${{ steps.next.outputs.value }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh CLI will use this
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          BASE="main"
          HEAD="next/$NEXT"
          TITLE="v$NEXT"

          echo "Checking for existing PR from $HEAD to $BASE..."
          EXISTING_PR=$(gh pr list \
            --base "$BASE" \
            --head "$HEAD" \
            --state open \
            --json number \
            --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for $HEAD -> $BASE. Skipping creation."
            exit 0
          fi

          echo "Creating PR: $TITLE ($HEAD -> $BASE)"
          gh pr create \
            --base "$BASE" \
            --head "$HEAD" \
            --title "$TITLE" \
            --body "Release $TITLE"

      - name: Summary
        run: |
          echo "‚úÖ Created branch: next/${{ steps.next.outputs.value }}"
          echo "‚û°Ô∏è  Bump: ${{ inputs.bump }}"
          echo "üì¶ PR title: v${{ steps.next.outputs.value }}"
