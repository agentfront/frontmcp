name: Create release branch (next/{semver})

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Semver bump"
        required: true
        type: choice
        options: [patch, minor, major]
        default: patch

permissions:
  contents: write
  pull-requests: write

jobs:
  create:
    runs-on: ubuntu-latest
    environment: release
    env:
      # Disable Nx daemon in CI for determinism
      NX_DAEMON: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # we need tags & history

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version-file: ".nvmrc"
          cache: "yarn"
          registry-url: "https://registry.npmjs.org/"

      - name: Install deps
        run: yarn
        env:
          npm_config_onnxruntime_node_install_cuda: skip

      - name: Configure git user
        run: |
          git config user.name "agentfront[bot]"
          git config user.email "agentfront[bot]@users.noreply.github.com"

      # üî¢ Compute next semver strictly from root package.json + bump input
      - name: Compute next semver from root package.json
        id: next
        shell: bash
        run: |
          set -euo pipefail

          # Run node with BUMP provided as env var
          NEXT=$(BUMP="${{ inputs.bump }}" node - << 'EOF'
          const fs = require('fs');

          const bump = (process.env.BUMP || 'patch').trim();

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const raw = String(pkg.version || '0.0.0').trim();

          const parts = raw.split('.').map((n) => {
            const v = Number.parseInt(n, 10);
            return Number.isFinite(v) ? v : 0;
          });

          let [M, m, p] = [parts[0] || 0, parts[1] || 0, parts[2] || 0];

          if (bump === 'major') {
            M += 1;
            m = 0;
            p = 0;
          } else if (bump === 'minor') {
            m += 1;
            p = 0;
          } else {
            // default: patch
            p += 1;
          }

          const next = [M, m, p].join('.');
          process.stdout.write(next);
          EOF
          )

          echo "Next version: $NEXT"
          echo "value=$NEXT" >> "$GITHUB_OUTPUT"

      - name: Get current and last release versions
        id: versions
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          # Get last release tag
          LAST_TAG=$(git tag --list "v*" --sort=-version:refname | head -n1 || echo "")
          if [ -n "$LAST_TAG" ]; then
            # Extract version from tag (remove 'v' prefix)
            LAST_VERSION="${LAST_TAG#v}"
            # Get minor version (e.g., 0.3 from 0.3.1)
            LAST_MINOR=$(echo "$LAST_VERSION" | awk -F. '{print $1"."$2}')
          else
            LAST_VERSION=""
            LAST_MINOR=""
          fi

          NEXT_MINOR=$(echo "$NEXT" | awk -F. '{print $1"."$2}')

          echo "last_version=$LAST_VERSION" >> "$GITHUB_OUTPUT"
          echo "last_minor=$LAST_MINOR" >> "$GITHUB_OUTPUT"
          echo "next_version=$NEXT" >> "$GITHUB_OUTPUT"
          echo "next_minor=$NEXT_MINOR" >> "$GITHUB_OUTPUT"

          echo "Last release: $LAST_VERSION (minor: $LAST_MINOR)"
          echo "Next release: $NEXT (minor: $NEXT_MINOR)"

      - name: Create branch next/${{ steps.next.outputs.value }} from base
        id: branch
        shell: bash
        run: |
          set -euo pipefail
          BASE="main"
          NEXT="${{ steps.next.outputs.value }}"

          git fetch origin "$BASE" --tags
          git switch -c "next/$NEXT" "origin/$BASE"

          echo "Created branch next/$NEXT from $BASE"
          echo "name=next/$NEXT" >> "$GITHUB_OUTPUT"

      # ========================================
      # STEP 1: Identify affected independent libraries
      # ========================================
      - name: Identify affected independent libraries
        id: independent
        shell: bash
        run: |
          set -euo pipefail

          # Get all independent libraries
          ALL_INDEPENDENT=$(node -e "
            const { execSync } = require('child_process');
            try {
              const out = execSync('npx nx show projects -p tag:versioning:independent --type lib --json', { encoding: 'utf8' });
              const arr = JSON.parse(out);
              process.stdout.write(arr.join(','));
            } catch (e) {
              process.stdout.write('');
            }
          ")

          if [ -z "$ALL_INDEPENDENT" ]; then
            echo 'independent_projects=' >> "$GITHUB_OUTPUT"
            echo "No independent libraries found"
            exit 0
          fi

          echo "All independent libs: $ALL_INDEPENDENT"

          # Get affected libraries (changed since last release)
          LAST_TAG="${{ steps.versions.outputs.last_version }}"
          if [ -n "$LAST_TAG" ]; then
            LAST_TAG="v$LAST_TAG"
          else
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          AFFECTED=$(node -e "
            const { execSync } = require('child_process');
            try {
              const out = execSync('npx nx show projects --affected --base=\"${LAST_TAG}\" --type lib --json', { encoding: 'utf8' });
              const arr = JSON.parse(out);
              process.stdout.write(arr.join(','));
            } catch (e) {
              process.stdout.write('');
            }
          ")

          # Find intersection: affected AND independent
          AFFECTED_INDEPENDENT=$(node -e "
            const all = '$ALL_INDEPENDENT'.split(',').filter(Boolean);
            const affected = '$AFFECTED'.split(',').filter(Boolean);
            const intersection = all.filter(lib => affected.includes(lib));
            process.stdout.write(intersection.join(','));
          ")

          echo "independent_projects=$AFFECTED_INDEPENDENT" >> "$GITHUB_OUTPUT"
          if [ -n "$AFFECTED_INDEPENDENT" ]; then
            echo "Affected independent libs: $AFFECTED_INDEPENDENT"
          else
            echo "No affected independent libraries"
          fi

      # ========================================
      # STEP 2: Use Codex to analyze independent libs
      # ========================================
      - name: Prepare context for Codex lib analysis
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/codex/lib-analysis

          INDEPENDENT="${{ steps.independent.outputs.independent_projects }}"
          LAST_TAG="${{ steps.versions.outputs.last_version }}"
          if [ -n "$LAST_TAG" ]; then
            LAST_TAG="v$LAST_TAG"
          else
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          TODAY=$(date -u +"%Y-%m-%d")

          # Collect changes for all independent libraries
          IFS=',' read -ra LIBS <<< "$INDEPENDENT"
          LIBS_DATA=""

          for lib in "${LIBS[@]}"; do
            DIFF=$(git diff "$LAST_TAG"...HEAD -- "libs/$lib" 2>/dev/null || echo "")
            COMMITS=$(git log "$LAST_TAG"...HEAD --oneline -- "libs/$lib" 2>/dev/null || echo "")

            if [ -z "$DIFF" ] && [ -z "$COMMITS" ]; then
              continue
            fi

            CURRENT_VERSION=$(node -e "console.log(require('./libs/$lib/package.json').version)")

            LIBS_DATA+="
          ================================================================================
          LIBRARY: $lib
          CURRENT VERSION: $CURRENT_VERSION
          ================================================================================

          COMMITS:
          $COMMITS

          DIFF (truncated to 8000 chars):
          ${DIFF:0:8000}

          "
          done

          # Create single prompt for all libraries
          cat > .github/codex/lib-analysis/prompt.md <<EOF
          IMPORTANT: You MUST ONLY analyze the libraries explicitly listed below. Do NOT explore the codebase or include any other libraries.

          Analyze the following independent libraries and determine:
          1. The appropriate semantic version bump (MAJOR/MINOR/PATCH)
          2. A changelog entry for each library

          Today's date: $TODAY

          Semantic Versioning Rules:
          - MAJOR: Breaking changes, incompatible API changes
          - MINOR: New features, backwards-compatible functionality additions
          - PATCH: Backwards-compatible bug fixes, documentation, refactoring, minor improvements

          CRITICAL: Return the library name EXACTLY as shown in the "LIBRARY:" field below (the folder name like "sdk", NOT the npm package name like "@frontmcp/sdk").

          Libraries to analyze (ONLY these, no others):
          $LIBS_DATA

          For each library listed above, respond with:
          - name: The EXACT folder name from the "LIBRARY:" field (e.g., "sdk", "adapters", "cli")
          - bump: major, minor, or patch
          - changelog: Starting with ## [NEW_VERSION] - $TODAY and including appropriate sections

          DO NOT include any libraries not listed above.
          EOF

          # Create output schema
          cat > .github/codex/lib-analysis/schema.json <<'SCHEMA'
          {
            "type": "object",
            "properties": {
              "libraries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": { "type": "string" },
                    "bump": { "type": "string", "enum": ["major", "minor", "patch"] },
                    "changelog": { "type": "string", "minLength": 10 }
                  },
                  "required": ["name", "bump", "changelog"],
                  "additionalProperties": false
                }
              }
            },
            "required": ["libraries"],
            "additionalProperties": false
          }
          SCHEMA

      - name: Run Codex to analyze independent libraries
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        id: codex_libs
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_OPENAI_KEY }}
          prompt-file: .github/codex/lib-analysis/prompt.md
          output-file: .github/codex/lib-analysis/results.json
          sandbox: read-only
          safety-strategy: drop-sudo
          output-schema-file: .github/codex/lib-analysis/schema.json

      # ========================================
      # STEP 3: Apply all version bumps
      # ========================================
      - name: Bump synchronized libraries
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${{ inputs.bump }}"

          echo "Bumping all synchronized libraries ($BUMP version bump)..."
          # Use Nx native release versioning - includes both libs/* and plugins/*
          # --git-tag=false: Don't create git tags (done in publish workflow)
          # --git-commit=false: Don't commit (we commit everything together later)
          npx nx release version "$BUMP" --git-tag=false --git-commit=false

      - name: Bump independent libraries and write changelogs
        if: ${{ steps.independent.outputs.independent_projects != '' }}
        shell: bash
        run: |
          set -euo pipefail

          RESULTS_FILE=".github/codex/lib-analysis/results.json"
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "No Codex results found, skipping independent lib bumps"
            exit 0
          fi

          # Get the list of valid independent libraries for validation
          VALID_LIBS="${{ steps.independent.outputs.independent_projects }}"

          # Process each library from Codex results
          LIBS_COUNT=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries.length)")

          for ((i=0; i<LIBS_COUNT; i++)); do
            RAW_LIB_NAME=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].name)")
            BUMP_TYPE=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].bump)")
            CHANGELOG_ENTRY=$(node -e "const data=require('./${RESULTS_FILE}'); console.log(data.libraries[$i].changelog)")

            # Normalize library name: handle @frontmcp/name, @scope/name, or plain name formats
            LIB_NAME=$(node -e "
              const raw = '$RAW_LIB_NAME';
              // Remove @scope/ prefix if present (e.g., @frontmcp/sdk -> sdk)
              let name = raw.replace(/^@[^/]+\//, '');
              // Handle special case: 'frontmcp (CLI)' -> 'cli'
              if (raw.toLowerCase().includes('cli')) name = 'cli';
              // Handle 'frontmcp' -> 'cli' (the CLI package name)
              if (name === 'frontmcp') name = 'cli';
              console.log(name);
            ")

            echo "================================"
            echo "Processing: $RAW_LIB_NAME (normalized: $LIB_NAME)"
            echo "Bump: $BUMP_TYPE"
            echo "================================"

            # Validate that this library is in the independent libs list
            if ! echo ",$VALID_LIBS," | grep -q ",$LIB_NAME,"; then
              echo "‚ö†Ô∏è  Skipping $LIB_NAME - not in independent libraries list: $VALID_LIBS"
              continue
            fi

            # Validate that the library directory exists
            if [ ! -d "libs/$LIB_NAME" ]; then
              echo "‚ö†Ô∏è  Skipping $LIB_NAME - directory libs/$LIB_NAME does not exist"
              continue
            fi

            # Bump version
            node scripts/bump-version.mjs "$LIB_NAME" "$BUMP_TYPE"

            # Get new version after bump
            NEW_VERSION=$(node -e "console.log(require('./libs/${LIB_NAME}/package.json').version)")
            CHANGELOG_PATH="libs/$LIB_NAME/CHANGELOG.md"

            echo "Writing CHANGELOG for $LIB_NAME v$NEW_VERSION..."

            if [ -f "$CHANGELOG_PATH" ]; then
              # Prepend to existing changelog
              echo "$CHANGELOG_ENTRY" > "$CHANGELOG_PATH.new"
              echo "" >> "$CHANGELOG_PATH.new"
              cat "$CHANGELOG_PATH" >> "$CHANGELOG_PATH.new"
              mv "$CHANGELOG_PATH.new" "$CHANGELOG_PATH"
            else
              # Create new changelog
              cat > "$CHANGELOG_PATH" <<CLEOF
          # Changelog

          All notable changes to $LIB_NAME will be documented in this file.

          $CHANGELOG_ENTRY
          CLEOF
            fi

            echo "‚úì Bumped $LIB_NAME to $NEW_VERSION and updated CHANGELOG"
          done

      # ========================================
      # STEP 4: Archive docs and publish draft to live
      # ========================================
      - name: Archive and publish docs
        shell: bash
        run: |
          set -euo pipefail

          LAST_MINOR="${{ steps.versions.outputs.last_minor }}"
          NEXT_MINOR="${{ steps.versions.outputs.next_minor }}"

          if [ -z "$LAST_MINOR" ]; then
            echo "No previous version to archive, skipping docs archival"
            exit 0
          fi

          # Only archive and publish if this is a new minor version
          if [ "$LAST_MINOR" = "$NEXT_MINOR" ]; then
            echo "Same minor version ($NEXT_MINOR), skipping docs archival and publishing"
            exit 0
          fi

          echo "Running archive and publish docs script..."
          node scripts/archive-and-publish-docs.mjs "$LAST_MINOR" "$NEXT_MINOR"

      # ========================================
      # STEP 5: Commit all changes
      # ========================================
      - name: Commit release preparation
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          # Check if there are changes
          if [ -n "$(git status --porcelain)" ]; then
            git add -A

            # Create detailed commit message
            cat > /tmp/commit-msg <<COMMITMSG
          chore(release): prepare v$NEXT

          - Bump synchronized libs to v$NEXT
          - Bump independent libs (Codex-analyzed)
          - Update CHANGELOGs for independent libs
          - Archive v${{ steps.versions.outputs.last_minor }} docs to docs/live/docs/v/${{ steps.versions.outputs.last_minor }}
          - Publish draft docs to live (docs/draft ‚Üí docs/live)
          - Update docs/live/docs.json versioning

          Note: updates.mdx will be updated by Codex workflow
          COMMITMSG

            git commit -F /tmp/commit-msg
            echo "‚úì Created release preparation commit"
          else
            echo "No changes to commit"
            git commit --allow-empty -m "chore(release): prepare v$NEXT"
          fi

      # üö´ Push ONLY the branch, NOT tags ‚Äì tags will be created & pushed by the publish workflow on merge
      - name: Push branch (no tags)
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          git push --set-upstream origin "next/$NEXT"

      # Open PR main <- next/{semver} with title v{semver}
      - name: Open PR for next/${{ steps.next.outputs.value }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh CLI will use this
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          BASE="main"
          HEAD="next/$NEXT"
          TITLE="v$NEXT"

          echo "Checking for existing PR from $HEAD to $BASE..."
          EXISTING_PR=$(gh pr list \
            --base "$BASE" \
            --head "$HEAD" \
            --state open \
            --json number \
            --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for $HEAD -> $BASE. Skipping creation."
            exit 0
          fi

          echo "Creating PR: $TITLE ($HEAD -> $BASE)"
          gh pr create \
            --base "$BASE" \
            --head "$HEAD" \
            --title "$TITLE" \
            --body "Release $TITLE"

      - name: Summary
        run: |
          echo "‚úÖ Created branch: next/${{ steps.next.outputs.value }}"
          echo "‚û°Ô∏è  Bump: ${{ inputs.bump }}"
          echo "üì¶ PR title: v${{ steps.next.outputs.value }}"
