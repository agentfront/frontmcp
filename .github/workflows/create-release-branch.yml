name: Create release branch (next/{semver})

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Semver bump"
        required: true
        type: choice
        options: [ patch, minor, major ]
        default: patch

permissions:
  contents: write
  pull-requests: write

jobs:
  create:
    runs-on: ubuntu-latest
    env:
      # Disable Nx daemon in CI for determinism
      NX_DAEMON: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # we need tags & history

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'
          registry-url: 'https://registry.npmjs.org/'

      - name: Install deps
        run: yarn

      - name: Configure git user
        run: |
          git config user.name "agentfront[bot]"
          git config user.email "agentfront[bot]@users.noreply.github.com"

      # üî¢ Compute next semver strictly from root package.json + bump input
      - name: Compute next semver from root package.json
        id: next
        shell: bash
        run: |
          set -euo pipefail

          # Run node with BUMP provided as env var
          NEXT=$(BUMP="${{ inputs.bump }}" node - << 'EOF'
          const fs = require('fs');

          const bump = (process.env.BUMP || 'patch').trim();

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const raw = String(pkg.version || '0.0.0').trim();

          const parts = raw.split('.').map((n) => {
            const v = Number.parseInt(n, 10);
            return Number.isFinite(v) ? v : 0;
          });

          let [M, m, p] = [parts[0] || 0, parts[1] || 0, parts[2] || 0];

          if (bump === 'major') {
            M += 1;
            m = 0;
            p = 0;
          } else if (bump === 'minor') {
            m += 1;
            p = 0;
          } else {
            // default: patch
            p += 1;
          }

          const next = [M, m, p].join('.');
          process.stdout.write(next);
          EOF
          )

          echo "Next version: $NEXT"
          echo "value=$NEXT" >> "$GITHUB_OUTPUT"

      - name: Create branch next/${{ steps.next.outputs.value }} from base
        id: branch
        shell: bash
        run: |
          set -euo pipefail
          BASE="main"   # or ${{ github.event.repository.default_branch }} if you want it dynamic
          NEXT="${{ steps.next.outputs.value }}"

          git fetch origin "$BASE" --tags
          git switch -c "next/$NEXT" "origin/$BASE"

          echo "Created branch next/$NEXT from $BASE"
          echo "name=next/$NEXT" >> "$GITHUB_OUTPUT"

      # Let Nx update versions INSIDE this branch (no tags pushed from this workflow)
      - name: Version packages with Nx (makes or stages changes)
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${{ inputs.bump }}"

          # If there are no existing semver tags, hint Nx this is the first release
          if git tag --list | grep -qE '^[v]?[0-9]+\.[0-9]+\.[0-9]+$'; then
            FIRST=""
          else
            FIRST="--first-release"
          fi

          echo "Running: yarn nx release version --specifier \"$BUMP\" $FIRST --verbose"
          yarn nx release version --specifier "$BUMP" $FIRST --verbose

          echo "Nx version step completed for bump: $BUMP"

      # üß© NEW: ensure root package.json version == next/{semver}
      - name: Sync root package.json version with next/{semver}
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          NEXT_VERSION="$NEXT" node - << 'EOF'
          const fs = require('fs');
          const path = 'package.json';
          const next = process.env.NEXT_VERSION;

          if (!next) {
            console.error('NEXT_VERSION env is missing');
            process.exit(1);
          }

          const raw = fs.readFileSync(path, 'utf8');
          const pkg = JSON.parse(raw);

          if (pkg.version === next) {
            console.log(`Root package.json already at version ${next}`);
          } else {
            pkg.version = next;
            fs.writeFileSync(path, JSON.stringify(pkg, null, 2) + '\n', 'utf8');
            console.log(`Updated root package.json version -> ${next}`);
          }
          EOF

      # ‚úÖ Ensure the branch has at least one commit different from main
      - name: Ensure release branch has a commit
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"

          # If Nx and/or the sync step left changes unstaged/uncommitted, commit them.
          if [ -n "$(git status --porcelain)" ]; then
            echo "Detected uncommitted changes; creating release commit..."
            git add -A
            git commit -m "chore(release): start v$NEXT"
          else
            echo "No file changes to commit (Nx may have already committed)."
            echo "Creating an empty release marker commit to ensure branch differs from base..."
            git commit --allow-empty -m "chore(release): start v$NEXT"
          fi

      # üö´ Push ONLY the branch, NOT tags ‚Äì tags will be created & pushed by the publish workflow on merge
      - name: Push branch (no tags)
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          git push --set-upstream origin "next/$NEXT"

      # Open PR main <- next/{semver} with title v{semver}
      - name: Open PR for next/${{ steps.next.outputs.value }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # gh CLI will use this
        shell: bash
        run: |
          set -euo pipefail
          NEXT="${{ steps.next.outputs.value }}"
          BASE="main"
          HEAD="next/$NEXT"
          TITLE="v$NEXT"

          echo "Checking for existing PR from $HEAD to $BASE..."
          EXISTING_PR=$(gh pr list \
            --base "$BASE" \
            --head "$HEAD" \
            --state open \
            --json number \
            --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for $HEAD -> $BASE. Skipping creation."
            exit 0
          fi

          echo "Creating PR: $TITLE ($HEAD -> $BASE)"
          gh pr create \
            --base "$BASE" \
            --head "$HEAD" \
            --title "$TITLE" \
            --body "Release $TITLE"

      - name: Summary
        run: |
          echo "‚úÖ Created branch: next/${{ steps.next.outputs.value }}"
          echo "‚û°Ô∏è  Bump: ${{ inputs.bump }}"
          echo "üì¶ PR title: v${{ steps.next.outputs.value }}"
