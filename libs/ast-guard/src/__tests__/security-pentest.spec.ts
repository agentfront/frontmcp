/**
 * Penetration Testing Suite for AST Transformation Security
 *
 * This test suite attempts to bypass the AST transformation security layer
 * to identify vulnerabilities and ensure all dangerous patterns are caught.
 */

import { JSAstValidator } from '../index';
import { createPreset, PresetLevel } from '../presets';

describe('Penetration Testing: Transformation Bypass Attempts', () => {
  const createSecureValidator = () => {
    const rules = createPreset(PresetLevel.STRICT);
    return new JSAstValidator(rules);
  };

  const dangerousIdentifiers = ['eval', 'Function', 'setTimeout', 'setInterval', 'console'];

  describe('ATTACK VECTOR 1: String concatenation to build dangerous identifiers', () => {
    it('VULNERABILITY: Dynamic string concatenation bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const dangerousFunc = window['ev' + 'al'];
        dangerousFunc('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // This WILL bypass - dynamic concatenation not caught
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain("'ev'"); // Not transformed!
      console.log('âš ï¸  VULNERABILITY: String concatenation bypasses transformation');
    });

    it('VULNERABILITY: Template literal concatenation bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const dangerous = window[\`ev\${'al'}\`];
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // This WILL bypass - template expressions not caught
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: Template literal expressions bypass transformation');
    });
  });

  describe('ATTACK VECTOR 2: Indirect references to dangerous functions', () => {
    it('VULNERABILITY: Variable assignment bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = eval;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // eval is transformed to __safe_eval, but then assigned to 'e'
      // 'e' is not in the dangerous identifiers list
      expect(result.transformedCode).toContain('__safe_eval');
      expect(result.transformedCode).toContain('const e = __safe_eval');
      // This is actually SAFE because __safe_eval is a proxy
      console.log('âœ… SAFE: Variable assignment gets proxied reference');
    });

    it('VULNERABILITY: Destructuring bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const { eval: e } = window;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Destructuring from window bypasses our transformation
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain('eval: e'); // Not transformed in destructure!
      console.log('âš ï¸  VULNERABILITY: Destructuring from global object bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 3: Global object access', () => {
    it('VULNERABILITY: window[dynamicVar] bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const key = 'eval';
        const dangerous = window[key];
        dangerous('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Dynamic key access not caught
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain("const key = 'eval'");
      console.log('âš ï¸  VULNERABILITY: Dynamic property access bypasses transformation');
    });

    it('VULNERABILITY: globalThis access bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = globalThis.eval;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // globalThis.eval - member access to global object
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: globalThis member access bypasses transformation');
    });

    it('VULNERABILITY: this.eval bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = this.eval;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // this.eval member access
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: this.eval bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 4: Constructor chains', () => {
    it('PROTECTED: Function constructor is blocked by validation', async () => {
      const validator = createSecureValidator();
      const code = `
        Function('alert(1)')();
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'disallowed-identifier': true,
          'no-eval': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Should be blocked by validation rules
      expect(result.valid).toBe(false);
      console.log('âœ… SAFE: Function constructor blocked by validation');
    });

    it('VULNERABILITY: Array.constructor.constructor chain bypasses', async () => {
      const validator = createSecureValidator();
      const code = `
        [].constructor.constructor('alert(1)')();
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Constructor chain not blocked by transformation
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: Constructor chain bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 5: Reflection APIs', () => {
    it('VULNERABILITY: Reflect.get bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = Reflect.get(window, 'eval');
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Reflect API not blocked
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: Reflect.get bypasses transformation');
    });

    it('VULNERABILITY: Object.getOwnPropertyDescriptor bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const desc = Object.getOwnPropertyDescriptor(window, 'eval');
        const e = desc.value;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Property descriptor access not blocked
      expect(result.transformedCode).toBeDefined();
      console.log('âš ï¸  VULNERABILITY: Object.getOwnPropertyDescriptor bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 6: Loops (Current State)', () => {
    it('BLOCKED: for loop is blocked by validation (not transformed)', async () => {
      const validator = createSecureValidator();
      const code = `
        for (let i = 0; i < 10; i++) {
          console.log(i);
        }
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'forbidden-loop': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Currently blocked by validation
      expect(result.valid).toBe(false);
      console.log('âš ï¸  CURRENT: Loops blocked by validation, not transformed');
    });

    it('BLOCKED: while loop is blocked by validation (not transformed)', async () => {
      const validator = createSecureValidator();
      const code = `
        let i = 0;
        while (i < 10) {
          console.log(i);
          i++;
        }
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'forbidden-loop': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Currently blocked by validation
      expect(result.valid).toBe(false);
      console.log('âš ï¸  CURRENT: Loops blocked by validation, not transformed');
    });
  });

  describe('Verification: Check transformed code uses proxied functions', () => {
    it('Should verify all dangerous calls go through __safe_ prefix', async () => {
      const validator = new JSAstValidator([]);
      const code = `
        console.log('test');
        callTool('foo');
        const ctx = codecallContext;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: ['console', 'callTool', 'codecallContext'],
          transformComputed: true,
        },
      });

      // Verify transformation worked
      expect(result.transformedCode).toContain('__safe_console');
      expect(result.transformedCode).toContain('__safe_callTool');
      expect(result.transformedCode).toContain('__safe_codecallContext');

      // Verify NO direct references remain
      expect(result.transformedCode).not.toMatch(/(?<!__safe_)console\.log/);
      expect(result.transformedCode).not.toMatch(/(?<!__safe_)callTool\(/);

      console.log('âœ… VERIFIED: Direct identifier access is transformed');
    });
  });
});

describe('Summary: Transformation Security Analysis', () => {
  it('should document all attack vectors and mitigations', () => {
    console.log(`

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          TRANSFORMATION SECURITY ANALYSIS SUMMARY              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… PROTECTED ATTACK VECTORS:
------------------------------------------------------------
1. Direct identifier access (console, eval, etc.)
   â†’ MITIGATED by AST transformation to __safe_ prefix

2. Static computed member access (obj['eval'])
   â†’ MITIGATED by AST transformation

3. Function constructor
   â†’ MITIGATED by validation rules (no-eval)

4. Variable assignments (const e = eval)
   â†’ MITIGATED: Gets proxied reference from __safe_eval

âš ï¸  VULNERABLE ATTACK VECTORS:
------------------------------------------------------------
1. Dynamic string concatenation (window['ev' + 'al'])
   â†’ NOT CAUGHT: Dynamic expressions not analyzed
   â†’ MITIGATION: Block all member access to window/globalThis/this

2. Destructuring from globals ({ eval: e } = window)
   â†’ NOT CAUGHT: Destructure patterns not transformed
   â†’ MITIGATION: Block destructuring of dangerous objects

3. Dynamic property access (window[dynamicVar])
   â†’ NOT CAUGHT: Variable names not statically analyzable
   â†’ MITIGATION: Block all computed access to global objects

4. Global object member access (globalThis.eval, this.eval)
   â†’ NOT CAUGHT: Only top-level identifiers transformed
   â†’ MITIGATION: Block window/globalThis/this member access

5. Constructor chains ([].constructor.constructor)
   â†’ NOT CAUGHT: Constructor property access not blocked
   â†’ MITIGATION: Disallow .constructor property access

6. Reflection APIs (Reflect.get, Object.getOwnPropertyDescriptor)
   â†’ NOT CAUGHT: Reflection APIs not blocked
   â†’ MITIGATION: Disallow Reflect and meta-programming APIs

7. Loops (for, while, do-while)
   â†’ CURRENTLY BLOCKED by validation (not transformed)
   â†’ PROPOSED: Transform to __safe_for(), __safe_while()

RECOMMENDED DEFENSE-IN-DEPTH STRATEGY:
------------------------------------------------------------
1. âœ… AST Transformation (current implementation)
   - Transform direct identifier access
   - Transform static computed member access

2. âš ï¸  Enhanced Validation Rules (needed)
   - Block all window/globalThis/this member access
   - Block all destructuring patterns
   - Block .constructor property access
   - Block Reflect.* APIs
   - Block Object.getOwnPropertyDescriptor and similar

3. ğŸ’¡ Loop Transformation (proposed)
   - Transform for â†’ __safe_for()
   - Transform while â†’ __safe_while()
   - Transform do-while â†’ __safe_doWhile()
   - Allows loop execution with resource limits

4. ğŸ”’ Runtime Proxy Layer (already implemented)
   - __safe_* functions enforce runtime checks
   - Sandbox worker isolation
   - Message passing for async operations

CRITICAL VULNERABILITIES TO FIX:
------------------------------------------------------------
Priority 1: Block global object access patterns
Priority 2: Implement loop transformation
Priority 3: Block reflection and meta-programming APIs
Priority 4: Add runtime detection of bypass attempts
    `);

    expect(true).toBe(true);
  });
});
