/**
 * Penetration Testing Suite for AST Transformation Security
 *
 * This test suite attempts to bypass the AST transformation security layer
 * to identify vulnerabilities and ensure all dangerous patterns are caught.
 */

import { JSAstValidator } from '../index';
import { createPreset, PresetLevel } from '../presets';

describe('Penetration Testing: Transformation Bypass Attempts', () => {
  const createSecureValidator = () => {
    const rules = createPreset(PresetLevel.STRICT);
    return new JSAstValidator(rules);
  };

  const dangerousIdentifiers = ['eval', 'Function', 'setTimeout', 'setInterval', 'console'];

  describe('ATTACK VECTOR 1: String concatenation to build dangerous identifiers', () => {
    it('VULNERABILITY: Dynamic string concatenation bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const dangerousFunc = window['ev' + 'al'];
        dangerousFunc('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule blocks computed access to window)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks computed access to window');
        return;
      }

      // If validation didn't catch it, transformation may have been bypassed
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain("'ev'"); // Not transformed by transformation layer
      console.log('⚠️  VULNERABILITY: String concatenation bypasses transformation (validation may still catch)');
    });

    it('VULNERABILITY: Template literal concatenation bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const dangerous = window[\`ev\${'al'}\`];
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule blocks computed access to window)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks computed access to window');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: Template literal expressions bypass transformation');
    });
  });

  describe('ATTACK VECTOR 2: Indirect references to dangerous functions', () => {
    it('VULNERABILITY: Variable assignment bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = eval;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // eval is transformed to __safe_eval, but then assigned to 'e'
      // 'e' is not in the dangerous identifiers list
      expect(result.transformedCode).toContain('__safe_eval');
      expect(result.transformedCode).toContain('const e = __safe_eval');
      // This is actually SAFE because __safe_eval is a proxy
      console.log('✅ SAFE: Variable assignment gets proxied reference');
    });

    it('VULNERABILITY: Destructuring bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const { eval: e } = window;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule may block window access)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks destructuring from window');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain('eval: e'); // Not transformed in destructure!
      console.log('⚠️  VULNERABILITY: Destructuring from global object bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 3: Global object access', () => {
    it('VULNERABILITY: window[dynamicVar] bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const key = 'eval';
        const dangerous = window[key];
        dangerous('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule blocks computed access to window)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks dynamic property access on window');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      expect(result.transformedCode).toContain("const key = 'eval'");
      console.log('⚠️  VULNERABILITY: Dynamic property access bypasses transformation');
    });

    it('VULNERABILITY: globalThis access bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = globalThis.eval;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule blocks globalThis access)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks globalThis member access');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: globalThis member access bypasses transformation');
    });

    it('VULNERABILITY: this.eval bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = this.eval;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule blocks this access)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks this member access');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: this.eval bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 4: Constructor chains', () => {
    it('PROTECTED: Function constructor is blocked by validation', async () => {
      const validator = createSecureValidator();
      const code = `
        Function('alert(1)')();
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'disallowed-identifier': true,
          'no-eval': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Should be blocked by validation rules
      expect(result.valid).toBe(false);
      console.log('✅ SAFE: Function constructor blocked by validation');
    });

    it('VULNERABILITY: Array.constructor.constructor chain bypasses', async () => {
      const validator = createSecureValidator();
      const code = `
        [].constructor.constructor('alert(1)')();
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (DisallowedIdentifierRule may block .constructor)
      if (!result.valid) {
        console.log('✅ SAFE: DisallowedIdentifierRule blocks constructor chain');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: Constructor chain bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 5: Reflection APIs', () => {
    it('VULNERABILITY: Reflect.get bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const e = Reflect.get(window, 'eval');
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule may block window access)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks Reflect.get with window');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: Reflect.get bypasses transformation');
    });

    it('VULNERABILITY: Object.getOwnPropertyDescriptor bypasses transformation', async () => {
      const validator = createSecureValidator();
      const code = `
        const desc = Object.getOwnPropertyDescriptor(window, 'eval');
        const e = desc.value;
        e('alert(1)');
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Check if validation layer catches this (NoGlobalAccessRule may block window access)
      if (!result.valid) {
        console.log('✅ SAFE: NoGlobalAccessRule blocks Object.getOwnPropertyDescriptor with window');
        return;
      }

      // If validation didn't catch it, transformation was bypassed
      expect(result.transformedCode).toBeDefined();
      console.log('⚠️  VULNERABILITY: Object.getOwnPropertyDescriptor bypasses transformation');
    });
  });

  describe('ATTACK VECTOR 6: Loops (Current State)', () => {
    it('BLOCKED: for loop is blocked by validation (not transformed)', async () => {
      const validator = createSecureValidator();
      const code = `
        for (let i = 0; i < 10; i++) {
          console.log(i);
        }
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'forbidden-loop': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Currently blocked by validation
      expect(result.valid).toBe(false);
      console.log('⚠️  CURRENT: Loops blocked by validation, not transformed');
    });

    it('BLOCKED: while loop is blocked by validation (not transformed)', async () => {
      const validator = createSecureValidator();
      const code = `
        let i = 0;
        while (i < 10) {
          console.log(i);
          i++;
        }
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        rules: {
          'forbidden-loop': true,
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: dangerousIdentifiers,
          transformComputed: true,
        },
      });

      // Currently blocked by validation
      expect(result.valid).toBe(false);
      console.log('⚠️  CURRENT: Loops blocked by validation, not transformed');
    });
  });

  describe('Verification: Check transformed code uses proxied functions', () => {
    it('Should verify all dangerous calls go through __safe_ prefix', async () => {
      const validator = new JSAstValidator([]);
      const code = `
        console.log('test');
        callTool('foo');
        const ctx = codecallContext;
      `;

      const result = await validator.validate(code, {
        parseOptions: {
          ecmaVersion: 'latest',
          sourceType: 'script',
        },
        transform: {
          enabled: true,
          prefix: '__safe_',
          identifiers: ['console', 'callTool', 'codecallContext'],
          transformComputed: true,
        },
      });

      // Verify transformation worked
      expect(result.transformedCode).toContain('__safe_console');
      expect(result.transformedCode).toContain('__safe_callTool');
      expect(result.transformedCode).toContain('__safe_codecallContext');

      // Verify NO direct references remain
      expect(result.transformedCode).not.toMatch(/(?<!__safe_)console\.log/);
      expect(result.transformedCode).not.toMatch(/(?<!__safe_)callTool\(/);

      console.log('✅ VERIFIED: Direct identifier access is transformed');
    });
  });

  // Output security analysis summary after all tests complete
  afterAll(() => {
    console.log(`
╔════════════════════════════════════════════════════════════════╗
║          TRANSFORMATION SECURITY ANALYSIS SUMMARY              ║
╚════════════════════════════════════════════════════════════════╝

✅ PROTECTED BY TRANSFORMATION:
- Direct identifier access, Static computed member access
- Function constructor, Variable assignments

⚠️ REQUIRES VALIDATION RULES (Defense-in-Depth):
- String concatenation, Template literal concatenation
- Destructuring from globals, Dynamic property access
- Constructor chains, Reflection APIs

DEFENSE-IN-DEPTH: AST Transformation + Validation Rules + Runtime Proxy
    `);
  });
});
